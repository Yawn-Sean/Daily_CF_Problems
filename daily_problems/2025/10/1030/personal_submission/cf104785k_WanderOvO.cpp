/*
如何选择要删掉的边?
每个环上，删除掉一个边就好
但是有那种两个环共享边的情况
有平行边，我们把平行边合并，相当于每条边是有边权的
我们要保留的边的边权之和应该 >= m / 2
某个 u -> v，要么全保留，要么全删，否则没意义
能否直接 DFS 确定呢？可能不行，因为这样删的边和 DFS 顺序有关系
是否是找强连通分量呢？每个强连通分量需要想办法使之不强连通，就可以了
非也，比如：
1 2
2 3
3 1
3 4 
4 2
删除掉 3 1 后不再强连通，但是仍然有一个环

我们如果缩点了，则缩点后的图上的边必然是可以都保留的，只需要删缩的点内部的边
我们尽量每个强连通分量里删的边的条数尽可能少/总边权尽量小
能否每个强连通分量按照边权贪心，贪心删最小的一部分，然后检查是否这部分为 DAG 了？
不行，边权全都是 1 的时候处理不了
能否先考虑一下无解的情况呢？感觉似乎总是有解的
假如你能把所有边划分成两类，每类边都没有环，则至少有一类边的边数至少一半
如何分成无环的两个图？
DFS 一遍是可以得到一个 DFS 树的的，但没遍历到的那部分并不能保证无环
我们一个集合中只保留从编号小指向编号大的点的边，另一个只保留编号大指向编号小的边
这样两个集合一定没有环
*/

struct Edge {
    int u, v, id;
};

int n, m;
vector<int> e1, e2;

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        if (u < v) {
            e1.push_back(i);
        } else {
            e2.push_back(i);
        }
    }
    
    cout << "YES\n";
    if (e1.size() > e2.size()) {
        cout << e1.size() << "\n";
        for (auto v : e1) {
            cout << v << " ";
        }
    } else {
        cout << e2.size() << "\n";
        for (auto v : e2) {
            cout << v << " ";
        }
    }
    
}
