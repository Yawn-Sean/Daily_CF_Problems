**提示 1：** 只需将边分为两类，类内都没有环，则必然有一类的数量足够多。

我们要求留下来一半的边，最典型的想法就是分为两类，使得每个类内无环，则取其中较多的一定超过一半。

而这件事实际上很好构造，直接把从小到大的边存成一组，从大到小的存为另一组。这个有向图显然没有环。因此总能这么构造。

时间复杂度为 $\mathcal{O}(m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 10 ** 5
    mod = 998244353
    
    dp = [[0] * (M + 1) for _ in range(450)]
    dp[0][0] = 1
    
    for i in range(1, 450):
        for j in range(M + 1):
            dp[i][j] += dp[i - 1][j]
            if j >= i: dp[i][j] += dp[i][j - i]
            dp[i][j] %= mod
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        ans = 0
        
        for i in range(1, 450):
            if (n + i) % 2 == 0 and i * i <= n:
                ans += dp[i][(n - i * i) // 2]
        
        ans %= mod
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<int> idxs1, idxs2;

	for (int i = 1; i <= m; i ++) {
		int x, y;
		cin >> x >> y;
		if (x < y) idxs1.emplace_back(i);
		else idxs2.emplace_back(i);
	}

	cout << "YES\n";
	if (idxs1.size() > idxs2.size()) {
		cout << idxs1.size() << '\n';
		for (auto &v: idxs1) cout << v << ' ';
	}
	else {
		cout << idxs2.size() << '\n';
		for (auto &v: idxs2) cout << v << ' ';
	}

	return 0;
}
```
