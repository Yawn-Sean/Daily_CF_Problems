**提示 1：** 可以去掉一个左下角的正方形，剩余的是什么问题？

**提示 2：** 注意正方形的边长是有范围的。

**提示 3：** DP：换个角度求和。

我们找到对称轴，看对称轴上有几个方格。则左下角对应有这么一个正方形。

我们可以枚举这里的方格数量，注意正方形面积不超过 $M$ ，因此边长不超过 $\sqrt{M}$ ，因此枚举范围可以接受。

假设边长是 $i$ ，则又注意到正方形的右侧和上侧是对称的，所以每一侧的方格数量是 $\frac{n-i^2}{2}$ 。我们要用 $i$ 个非递增的数来凑这个和。

我们也可以换个视角来看这个问题。考虑从正方形出发，每一层的正方形数量。这样相当于用一堆不超过 $i$ 的数来凑 $\frac{n-i^2}{2}$ 的和。而只要使用的数的数量是一致的，最终对应的方案也是一致的（因为一定是从正方形往外，数值越来越小）。

所以就是一个无限物品的背包求方案数的问题，是很容易维护的。这里也要用到 $i$ 不超过 $\sqrt{M}$ 。

时间复杂度为 $\mathcal{O}((T+M)\sqrt{M})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 10 ** 5
    mod = 998244353
    
    dp = [[0] * (M + 1) for _ in range(450)]
    dp[0][0] = 1
    
    for i in range(1, 450):
        for j in range(M + 1):
            dp[i][j] += dp[i - 1][j]
            if j >= i: dp[i][j] += dp[i][j - i]
            dp[i][j] %= mod
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        ans = 0
        
        for i in range(1, 450):
            if (n + i) % 2 == 0 and i * i <= n:
                ans += dp[i][(n - i * i) // 2]
        
        ans %= mod
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int mod = 998244353, M = 1e5, CNT = 450;

	auto add = [&] (int &x, int y) -> void {
		x += y;
		if (x >= mod) x -= mod;
	};

	vector<vector<int>> dp(CNT, vector<int>(M + 1, 0));
	dp[0][0] = 1;

	for (int i = 1; i < 450; i ++) {
		for (int j = 0; j <= M; j ++) {
			add(dp[i][j], dp[i - 1][j]);
			if (j >= i) add(dp[i][j], dp[i][j - i]);
		}
	}

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		int ans = 0;
		for (int i = 1; i < 450; i ++) {
			if ((n + i) % 2 == 0 && i * i <= n) {
				add(ans, dp[i][(n - i * i) / 2]);
			}
		}

		cout << ans << '\n';
	}

	return 0;
}
```
