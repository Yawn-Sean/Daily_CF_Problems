**提示 1：** 知道 $p_n$ 这个问题就结束了。

**提示 2：** 可能的 $p_n$ 备选是什么？

只要知道 $p_n$ ，则 $p_i=(K-p_{i+1}^2)\bmod M$ ，显然前面的元素也都确定了。

所以关键在于找到所有的 $p_n$ 可能值。

我们统计所有的 $a_i,(K-a_i^2)\bmod M$ 的出现频率（总共 $2n$ 个数），则中间的 $p_{n-1},\dots,p_1$ 都出现了偶数次（除非跟 $(K-p_1^2)\bmod M,p_n$ 重复）。

而只要 $(K-p_1^2)\bmod M,p_n$ 不相等，就只有这两个元素只出现奇数次；否则就所有元素都出现偶数次。

为什么想到这么做呢？因为原本数据联系很浅，必须经过 $(K-p_i^2)\bmod M$ 产生联系，这样相当于形成了一系列 $p_i,p_{i+1}$ 的边，整体就是一个链的结构；要找到链头，肯定最方便的方式就是考虑度数，也就是这里的出现次数了。

所以，一旦出现次数是奇数的元素超过了 $2$ ，一定无法构造。

如果有 $2$ 个元素出现次数是奇数，我们分别枚举它们做 $p_n$ ，看构造的数组是否符合要求。

否则，每个元素都出现偶数次，也就意味着 $(K-p_1^2)\bmod M=p_n$ 。在这种情况下，我们前面提到的链一定成环了，我们随便挑选任意元素作为 $p_n$ 都可以拆环为链。而如果某个元素不符合要求，则用哪个元素都不符合要求，直接判不可构造即可。

所以本题表面上有点数论，但其实是个神秘的小图论。

时间复杂度是 $\mathcal{O}(n)$ ，如果你用哈希表统计，并且用哈希表判断两个数组构成是否一致。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m, k = MII()
    nums = LII()
    
    vis = set(nums)
    cnt = Counter()
    
    for x in nums:
        cnt[x] ^= 1
        cnt[(k - x * x) % m] ^= 1
    
    if sum(cnt.values()) > 2:
        exit(print('NO'))
    
    for x in cnt:
        if cnt[x]:
            ans = [x]
            for i in range(n - 1):
                ans.append((k - ans[-1] * ans[-1]) % m)
            
            if sorted(ans) == sorted(nums):
                ans.reverse()
                print('YES')
                exit(print(*ans))
    
    ans = [nums[0]]
    for i in range(n - 1):
        ans.append((k - ans[-1] * ans[-1]) % m)
    
    
    if sorted(ans) == sorted(nums):
        ans.reverse()
        print('YES')
        exit(print(*ans))
    
    print('NO')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m, k;
	cin >> n >> m >> k;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;
	vector<int> to_compare = nums;
	sort(to_compare.begin(), to_compare.end());

	map<int, int> mp;

	for (auto &v: nums) {
		mp[v] ^= 1;
		mp[((k - 1ll * v * v) % m + m) % m] ^= 1;
	}

	int total = 0;
	for (auto &[x, v]: mp) total += v;

	if (total > 2) return cout << "NO", 0;

	bool flg;

	for (auto &[x, v]: mp) {
		if (v) {
			vector<int> ans = {x};
			for (int i = 0; i < n - 1; i ++) {
				int v = ans.back();
				ans.emplace_back(((k - 1ll * v * v) % m + m) % m);
			}
			vector<int> compare_ans = ans;
			sort(compare_ans.begin(), compare_ans.end());

			flg = true;
			for (int i = 0; i < n; i ++) {
				if (to_compare[i] != compare_ans[i]) {
					flg = false;
				}
			}
			if (flg) {
				reverse(ans.begin(), ans.end());
				cout << "YES\n";
				for (auto &x: ans) cout << x << ' ';
				return 0;
			}
		}
	}

	vector<int> ans = {nums[0]};
	for (int i = 0; i < n - 1; i ++) {
		int v = ans.back();
		ans.emplace_back(((k - 1ll * v * v) % m + m) % m);
	}
	vector<int> compare_ans = ans;
	sort(compare_ans.begin(), compare_ans.end());

	flg = true;
	for (int i = 0; i < n; i ++) {
		if (to_compare[i] != compare_ans[i]) {
			flg = false;
		}
	}

	if (flg) {
		reverse(ans.begin(), ans.end());
		cout << "YES\n";
		for (auto &x: ans) cout << x << ' ';
		return 0;
	}
	else cout << "NO";

	return 0;
}
```