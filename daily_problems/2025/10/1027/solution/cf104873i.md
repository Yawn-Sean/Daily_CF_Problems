**提示 1：** 注意对于每个序列而言，序列中的元素都是互不相同的。

**提示 2：** 怎么快速找到分割点。

我们考虑 $A_i+A_i$ ，其中 $A_i$ 是一个序列， $+$ 表示拼接。

这样，我们可以根据 $A_i$ 第一个元素出现的位置，快速定位到第二个 $A_i$ 的开头。

因此，如果我们查询 $A+A+B+B+C+C+\dots$ ，我们可以根据 $A$ 的第一个元素的位置，确定 $A$ 的数值，再去掉开头的 $A+A$ ，进一步解决剩余的问题。

而查询长度有 $n$ 的限制，因此每次用这种方式可以查询 $\lfloor n/2\rfloor$ 个序列。最多只需要三次就能解决问题（当然你可以特殊处理下长度是奇数的情况，可以进一步优化）。

一个坑是 $n=1$ ，此时直接查询该序列即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def query(idxs):
        print('?', len(idxs), *idxs, flush=True)
        _, *res = MII()
        return res
    
    def answer(ans):
        print('!', ' '.join(f'{len(v)} {" ".join(map(str, v))}' for v in ans))
    
    n = II()
    ans = [[] for _ in range(n)]
    
    if n == 1: ans[0] = query([1])
    else:
        for i in range(0, n, n // 2):
            idxs = []
            for j in range(i, i + n // 2):
                if j >= n: break
                idxs.append(j + 1)
                idxs.append(j + 1)
            
            k = len(idxs) // 2
            res = query(idxs)
            
            pt = 0
            for j in range(i, i + k):
                npt = pt + 1
                while res[npt] != res[pt]:
                    npt += 1
                ans[j] = res[pt:npt]
                pt = 2 * npt - pt
    
    answer(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<vector<int>> ans(n);

	if (n == 1) {
		cout << "? 1 1" << endl;
		int k; cin >> k;
		ans[0].resize(k);
		for (auto &v: ans[0]) cin >> v;
	}
	else {
		for (int i = 0; i < n; i += n / 2) {
			vector<int> idxs;
			for (int j = i; j < i + n / 2 && j < n; j ++) {
				idxs.emplace_back(j + 1);
				idxs.emplace_back(j + 1);
			}

			int k = idxs.size() / 2;
			cout << '?' << ' ' << idxs.size();
			for (auto &v: idxs) cout << ' ' << v;
			cout << endl;

			int m;
			cin >> m;

			vector<int> res(m);
			for (auto &x: res) cin >> x;

			int pt = 0;

			for (int j = i; j < i + k; j ++) {
				int npt = pt + 1;
				while (res[npt] != res[pt]) npt ++;
				for (int k = pt; k < npt; k ++) ans[j].emplace_back(res[k]);
				pt = 2 * npt - pt;
			}
		}
	}

	cout << "!";
	for (auto &x: ans) {
		cout << ' ' << x.size();
		for (auto &y: x) cout << ' ' << y;
	}

	return 0;
}
```