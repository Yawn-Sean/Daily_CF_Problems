**提示 1：** 考虑 $k$ 的上界。

**提示 2：** 如何得到更小的数值？

显然， $k$ 不可能大于 $i\lt j$ 的 $(i,j)$ 总对数，即 $\frac{n(n-1)}{2}$ 。不符合的情况直接输出。

我们找到第一个满足 $\frac{n'(n'-1)}{2}\geq k$ 的 $n'$ 。我们用前 $n'$ 个元素来凑 $k$ 。如果总能凑出来，而又有 $n'\leq n$ （因为 $\frac{n(n-1)}{2}\geq k$ ，而 $n'$ 是满足 $\frac{n'(n'-1)}{2}\geq k$ 的最小的数），则对于上述排除情况之外的，我们也得出了合法构造。

此时前 $n'-1$ 个元素不妨两两成对，即互为倍数，用最后一个元素进行调整。最后一个元素需要跟前面的 $k'=k-\frac{(n'-1)(n'-2)}{2}$ 个元素成对（这个数是不超过 $n'-1$ 的，否则 $k\gt\frac{n'(n'-1)}{2}$ ）。

也就是前 $n'-1$ 个元素我们得给出差异性，使得其中 $k'$ 个数跟第 $n$ 个元素成对，其他不行。不妨让这 $k'$ 个元素相等，是 $x$ ，其他元素也相等，是 $y$ ，第 $n$ 个元素是 $z$。我们相当于要 $x,z$ 和 $x,y$ 有整除关系， $y,z$ 没有。这是很好构造的。

下面给出一种 $x=6,y=3,z=2$ 。而对于剩余的元素只需不是这里任何一个数的倍数和约数就好。我们取较大的关于 $6$ 取模结果是 $1/5$ 的数就行。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    k = II()
    
    if n * (n - 1) // 2 < k: exit(print(-1))
    
    for i in range(1, n + 1):
        if i * (i + 1) // 2 > k:
            ans = [3] * i
            k -= i * (i - 1) // 2
            for i in range(k):
                ans[i] = 6
            if k: ans.append(2)
            break
    
    for i in range(999997, 0, -6):
        if len(ans) < n: ans.append(i)
        if len(ans) < n: ans.append(i - 2)
    
    print(' '.join(map(str, ans)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k;
	cin >> n >> k;

	if (1ll * n * (n - 1) / 2 < k) return cout << -1, 0;

	vector<int> ans;

	for (int i = 1; i <= n; i ++) {
		if (i * (i + 1) / 2 > k) {
			for (int j = 0; j < i; j ++)
				ans.emplace_back(3);
			k -= i * (i - 1) / 2;
			for (int j = 0; j < k; j ++)
				ans[j] = 6;
			if (k) ans.emplace_back(2);
			break;
		}
	}

	for (int i = 999997; i >= 0; i -= 6) {
		if (ans.size() < n) ans.emplace_back(i);
		if (ans.size() < n) ans.emplace_back(i - 2);
	}

	for (auto &x: ans) cout << x << ' ';

	return 0;
}
```
