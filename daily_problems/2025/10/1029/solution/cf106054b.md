**提示 1：** 一些数是联动的。因此其实只要确定前面 $K$ 个数。

**提示 2：** 每个数需要满足什么条件？

首先，如果前 $K$ 个元素确定了，接下来每个元素也都确定了。所以只需看前 $K$ 个元素有多少种构造方法即可。

我们接下来考虑前 $K$ 个元素需要满足的限制。

我们先钦定前 $K$ 个元素都是 $0$ ，这样推出剩余所有的元素。

而第 $i,i+K,i+2K,\dots$ 个元素才是相互联动的，一个确定了可以确定其他所有的。且其两两之差都是固定的。

为了它们都是非负数，我们可以得到 $A_i$ 的下界。

如果 $A_1,A_2,\dots,A_K$ 的下界的和都已经超过了 $B_1$ ，则一定无法构造。否则这 $K$ 个元素的总增大量是 $B_1$ 减去下界和。

于是我们要求 $K$ 个非负整数和为 $S$ 的方案数，这是经典组合数学问题：

$1\leq (x_1+1)\lt (x_1+1)+(x_2+1)\lt\dots\lt (x_1+1)+(x_2+1)+\dots+(x_K+1)=S+K$

相当于 $1\sim S+K-1$ 中选取 $K-1$ 个数，从小到大依次作为 $(x_1+1),(x_1+1)+(x_2+1),\dots,(x_1+1)+(x_2+1)+\dots+(x_K+1)$ ，因此方案数是 $C_{S+K-1}^{K-1}$ 。

这个组合数可以用 $(S+K-1)(S+K-2)\dots S$ 除以 $(K-1)(K-2)\dots 1$ 计算，这两个分别都是好算的，后者再套个逆元就好了。

时间复杂度为 $\mathcal{O}(n+\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k = MII()
    nums = LII()
    mod = 998244353
    
    tmp = [0] * n
    
    for i in range(k, n):
        tmp[i] = tmp[i - k] + nums[i - k + 1] - nums[i - k]
    
    to_add = 0
    for i in range(k):
        val = 0
        for j in range(i, n, k):
            val = fmin(val, tmp[j])
        to_add -= val
    
    if to_add > nums[0]:
        print(0)
    else:
        tot = nums[0] - to_add
        v1 = 1
        v2 = 1
        
        for i in range(1, k):
            v1 = v1 * (tot + k - i) % mod
            v2 = v2 * i % mod
        
        print(v1 * pow(v2, -1, mod) % mod)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k, mod = 998244353;
	cin >> n >> k;

	vector<int> nums(n - k + 1), tmp(n, 0);
	for (auto &x: nums) cin >> x;

	for (int i = k; i < n; i ++)
		tmp[i] = tmp[i - k] + nums[i - k + 1] - nums[i - k];

	long long to_add = 0;
	for (int i = 0; i < k; i ++) {
		int val = 0;
		for (int j = i; j < n; j += k)
			val = min(val, tmp[j]);
		to_add -= val;
	}

	if (to_add > nums[0]) cout << 0;
	else {
		int tot = nums[0] - to_add, v1 = 1, v2 = 1;

		for (int i = 1; i < k; i ++) {
			v1 = 1ll * v1 * (tot + k - i) % mod;
			v2 = 1ll * v2 * i % mod;
		}

		cout << 1ll * v1 * quickPow(v2, mod - 2, mod) % mod;
	}

	return 0;
}
```
