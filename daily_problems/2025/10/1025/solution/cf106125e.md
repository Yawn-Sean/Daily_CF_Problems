**提示 1：** 想办法让 $1$ 的个数几乎不减。或者，尽可能增加。

我们假设某一段有 $x$ 个 $0$ ， $y$ 个 $1$ ，则操作后期望有 $(x+y)/2$ 个 $1$ ，变化量是 $(x-y)/2$ 。

所以我们选取 $0$ 的数量比 $1$ 的数量多得最多的一段操作，可以使得操作后 $1$ 的数量的期望最大化。

这样操作就行了，但是我确实不会分析这种做法的期望次数，但是可以本地随机数据跑一下看看要多少次，感觉安全就可以交了。（第一次没有严谨证明）

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def query(l, r):
        print(l + 2, r + 1, flush=True)
        nums = LII()
        if II() >= 70: exit()
        return nums
    
    n = II()
    nums = [0] * n
    
    while True:
        cur_mi = 0
        mi_idx = -1
        
        cur = 0
        
        max_seg = 0
        l, r = -1, 0
        
        for i in range(n):
            cur += -1 if nums[i] else 1
            if cur < cur_mi:
                cur_mi = cur
                mi_idx = i
            
            if cur - cur_mi > max_seg:
                max_seg = cur - cur_mi
                l, r = mi_idx, i
        
        nums = query(l, r)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n, 0);

	while (true) {
		int cur_mi = 0, mi_idx = -1, cur = 0, max_seg = 0, l = -1, r = 0;
		for (int i = 0; i < n; i ++) {
			cur += (nums[i] ? -1 : 1);
			if (cur < cur_mi) {
				cur_mi = cur;
				mi_idx = i;
			}
			if (cur - cur_mi > max_seg) {
				max_seg = cur - cur_mi;
				l = mi_idx, r = i;
			}
		}

		cout << l + 2 << ' ' << r + 1 << endl;
		for (auto &x: nums) cin >> x;

		int val;
		cin >> val;
		
		if (val >= 70) break;
	}

	return 0;
}
```