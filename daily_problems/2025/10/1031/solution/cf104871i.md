**提示 1：** 这个查询次数提示性比较强。

**提示 2：** 从叶子起步比较容易。

首先可以猜猜看查什么。查询次数大概是 $\mathcal{O}(\log n)$ 量级的。所以我们根据二进制位查询，第 $i$ 位的在第 $i$ 次查。

然后我们需要一个基准，发现查全 $1$ 字符串可以快速知道每个点的度数。

接下来怎么确定边呢？

发现度数为 $1$ 的结点出发是容易处理的。具体怎么做呢？我们可以根据前 $\mathcal{O}(\log n)$ 次查询找到。具体来说，如果第 $i$ 次查询中，这个结点的数值是 $1$ ，则跟它邻接的点的第 $i$ 个二进制位也是 $1$ ，否则是 $0$ 。于是我们就得到了对应的边。

其他点怎么办呢？其实也是类似的。我们可以直接在原树上去掉我们找到的边，再根据我们找到的边对原有的查询结果进行调整。这样我们就得到了一棵新树和新树对应的查询结果，也就转化为了规模更小的问题。

此时如果出现了新的度数为 $1$ 的点，我们再将其重新视为叶子节点。整个书写过程有点类似于拓扑排序。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    
    def query(s):
        print('QUERY', s, flush=True)
        return LII()
    
    total_deg = query('1' * n)
    notes = [query(''.join(str(i >> j & 1) for i in range(n))) for j in range(15)]
    
    stk = [i for i in range(n) if total_deg[i] == 1]
    ans = ['ANSWER']
    
    for _ in range(n - 1):
        u = stk.pop()
        v = 0
        for j in range(15):
            if notes[j][u]:
                v |= 1 << j
        
        for j in range(15):
            if u >> j & 1:
                notes[j][v] -= 1
        
        total_deg[v] -= 1
        if total_deg[v] == 1:
            stk.append(v)
        
        ans.append(f'{u + 1} {v + 1}')
    
    print('\n'.join(ans))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	cout << "QUERY " << string(n, '1') << endl;
	vector<int> total_deg(n);
	for (auto &x: total_deg) cin >> x;

	vector<vector<int>> notes(15, vector<int>(n));

	for (int j = 0; j < 15; j ++) {
		cout << "QUERY ";
		for (int i = 0; i < n; i ++)
			cout << (i >> j & 1);
		cout << endl;

		for (auto &x: notes[j]) cin >> x;
	}

	cout << "ANSWER\n";
	vector<int> stk;

	for (int i = 0; i < n; i ++) {
		if (total_deg[i] == 1) {
			stk.emplace_back(i);
		}
	}

	for (int i = 0; i < n - 1; i ++) {
		int u = stk.back(); stk.pop_back();
		int v = 0;

		for (int j = 0; j < 15; j ++) {
			if (notes[j][u]) {
				v |= 1 << j;
			}
		}

		for (int j = 0; j < 15; j ++) {
			if (u >> j & 1) {
				notes[j][v] --;
			}
		}

		total_deg[v] --;
		if (total_deg[v] == 1) stk.emplace_back(v);
		cout << u + 1 << ' ' << v + 1 << '\n';
	}

	return 0;
}
```
