**提示 1：** 只有两种需要处理的层。

**提示 2：** 考虑下必胜策略。

能进行操作的只有两种层，一种是满的，一种是只抽走了一侧的。

我们分别计数。假设有 $c_1$ 个是满的， $c_0$ 个是抽走了一侧的。

如果 $c_0,c_1$ 都是偶数，那么我们可以把这些层两两配对，每对要么都是满的，要么都抽走了一侧。当先手执行某个操作的时候，后手直接在另一个对应的层执行对应的操作。这样无论先手做什么，后手都能行动，因此后手胜利。

而如果 $c_1$ 是奇数，先手可以取走满的一层的中间，使得状态变为 $(c_1-1,c_0)$ ，也可以取走满的一层的一侧，使状态变为 $(c_1-1,c_0+1)$ ，两者至少有一个是后手必胜的。所以此时先手必胜。

只剩下 $c_1$ 偶数， $c_0$ 奇数的情况，我们此时直接抽走 $c_0$ 的某一层，即可到达状态 $(c_1,c_0-1)$ ，这种情况后手必胜。所以此时先手也必胜。

综上，只要 $c_0,c_1$ 有一个是奇数，就是先手必胜。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        c0 = 0
        c1 = 0
        
        for _ in range(n):
            s = I()
            if 'xxx' in s: c1 ^= 1
            elif 'xx' in s: c0 ^= 1
        
        outs.append('Monocarp' if c1 or c1 else 'Polycarp')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, c0 = 0, c1 = 0;
		cin >> n;

		while (n --) {
			string s;
			cin >> s;

			bool f = false;

			for (int i = 0; i < 4; i ++) {
				if (s.substr(i, 3) == "xxx") {
					f = true;
				}
			}

			if (f) {
				c1 ^= 1;
				continue;
			}

			for (int i = 0; i < 5; i ++) {
				if (s.substr(i, 2) == "xx") {
					f = true;
				}
			}

			if (f) c0 ^= 1;
		}

		cout << ((c0 | c1) ?  "Monocarp" : "Polycarp") << '\n';
	}

	return 0;
}
```
