**提示 1：** 对于一个确定的数组，如何确定最终成本。

**提示 2：** 越长的数组月不满足要求（指的是新增一个元素），所以可以使用什么经典算法呢？

对于某个确定的数组，分别凑是不方便的。我们直接减去下标，发现最后就是要凑到每个元素都相等。

那就往中位数凑就好了！所以只需找到中位数，计算比它大 / 小的元素的和和个数。这件事可以离散化后用树状数组维护，也可以对顶堆维护。

那么如何找到最长的子数组呢？

我们先将所有元素减去下标。接下来发现新增一个元素，成本只可能增大；删去一个元素，成本肯定变小。所以可以使用双指针，对于每个左端点找到符合条件的最大右端点。在这个过程中我们需要在增删过程种维护上面的东西，这也是可以办到的。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, k = MII()
        nums = LII()
        
        for i in range(n):
            nums[i] -= i
        
        vals = sorted(nums)
        
        fen_cnt = FenwickTree(n)
        fen_sum = FenwickTree(n)
        
        cnt = 0
        tot = 0
        
        l = 0
        r = -1
        
        ans = 0
        
        while l < n:
            while r < n:
                r += 1
                if r == n: break
                
                p = bisect.bisect_left(vals, nums[r])
                fen_cnt.add(p, 1)
                fen_sum.add(p, nums[r])
                
                cnt += 1
                tot += nums[r]
                pos = fen_cnt.bisect_min_larger((cnt + 1) // 2)
    
                left_cnt = fen_cnt.rsum(0, pos)
                left_sum = fen_sum.rsum(0, pos)
                
                right_cnt = cnt - left_cnt
                right_sum = tot - left_sum
                
                total = (left_cnt * vals[pos] - left_sum) + (right_sum - right_cnt * vals[pos])
                if total > k: break
            
            ans = fmax(ans, r - l)
            
            p = bisect.bisect_left(vals, nums[l])
            
            fen_cnt.add(p, -1)
            fen_sum.add(p, -nums[l])
            
            cnt -= 1
            tot -= nums[l]
            
            l += 1
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		long long k;
		cin >> n >> k;

		vector<int> nums(n);
		for (auto &x: nums) cin >> x;

		for (int i = 0; i < n; i ++) nums[i] -= i;

		multiset<int> left, right;
		long long total_left = 0, total_right = 0;

		int l = 0, r = -1, ans = 0;

		while (l < n) {
			while (r < n) {
				r ++;
				if (r == n) break;

				if (!left.empty() && *left.rbegin() < nums[r]) {
					right.insert(nums[r]);
					total_right += nums[r];
					while (left.size() < right.size()) {
						auto pt = *right.begin();
						right.erase(right.find(pt));
						total_right -= pt;
						left.insert(pt);
						total_left += pt;
					}
				}
				else {
					left.insert(nums[r]);
					total_left += nums[r];
					while (left.size() > right.size() + 1) {
						auto pt = *left.rbegin();
						left.erase(left.find(pt));
						total_left -= pt;
						right.insert(pt);
						total_right += pt;
					}
				}

				long long cur = total_right - total_left;
				if (left.size() > right.size()) cur += *left.rbegin();

				if (cur > k) break;
			}

			ans = max(ans, r - l);

			if (nums[l] <= *left.rbegin()) {
				left.erase(left.find(nums[l]));
				total_left -= nums[l];
				while (left.size() < right.size()) {
					auto pt = *right.begin();
					right.erase(right.find(pt));
					total_right -= pt;
					left.insert(pt);
					total_left += pt;
				}
			}
			else {
				right.erase(right.find(nums[l]));
				total_right -= nums[l];
				while (left.size() > right.size() + 1) {
					auto pt = *left.rbegin();
					left.erase(left.find(pt));
					total_left -= pt;
					right.insert(pt);
					total_right += pt;
				}
			}

			l ++;
		}
		cout << ans << '\n';
	}

	return 0;
}
```
