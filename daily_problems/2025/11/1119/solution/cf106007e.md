**提示 1：** 我们要求的点对满足什么条件？

**提示 2：** 如何简化运算。

我们要求所选的白色结点对不能有两个黑色的结点对之间的路径同时经过它们。

黑色结点对的路径如何考虑呢？我们将黑色结点之间路径上的点全部染成灰色，则我们只需求纯白的结点和灰色的结点的数量即可。纯白之间可以任意走，灰色结点可以跟白色结点走，我们最终答案就是这两者之和。

接下来关键就在于求灰色 / 白色结点。

本质上，灰色结点是黑色结点对应的虚树的路径上的点，用找 DFS 序上相邻的黑色结点的方式，可以快速得到新增结点时带来的新的灰色点数。有没有更方便的做法呢？

有的。我们可以钦定第一个变为黑色的点是根。这样，找虚树就只需不断向根节点找新的被染色结点了——因为深度最小的结点被染色了，为了跟它连通，只能不断往父节点找。只需遇到染色结点时，及时退出循环即可。因为每个点只被染色一次，因此复杂度是线性的。

最后按照第二段的说法计算答案就行。

时间复杂度为 $\mathcal{O}(n+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, q = MII()
        s = [int(c) for c in I()]
        
        path = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = GMI()
            path[u].append(v)
            path[v].append(u)
        
        queries = [II() - 1 for _ in range(q)]
        
        rt = queries[0]
        parent = [-1] * n
        
        que = [rt]
        
        for u in que:
            for v in path[u]:
                if parent[u] != v:
                    parent[v] = u
                    que.append(v)
        
        cols = [0] * n
        cnt = n
        
        for i in range(n):
            if s[i] == 0:
                u = i
                while u >= 0 and cols[u] == 0:
                    cols[u] = 1
                    cnt -= 1
                    u = parent[u]
        
        total = sum(s)
        
        for u in queries:
            if s[u]:
                s[u] = 0
                total -= 1
            
            while u >= 0 and cols[u] == 0:
                cols[u] = 1
                cnt -= 1
                u = parent[u]
            
            outs.append(cnt * (cnt + 1) // 2 + cnt * (total - cnt))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, q;
		cin >> n >> q;

		string s;
		cin >> s;

		vector<vector<int>> path(n);
		for (int i = 0; i < n - 1; i ++) {
			int u, v;
			cin >> u >> v;
			u --, v --;
			path[u].emplace_back(v);
			path[v].emplace_back(u);
		}

		vector<int> queries(q);
		for (auto &u: queries)
			cin >> u, u --;

		int rt = queries[0];
		vector<int> parent(n), cols(n, 0);

		auto dfs = [&] (auto &self, int u, int p) -> void {
			parent[u] = p;
			for (auto &v: path[u]) {
				if (v != p) {
					self(self, v, u);
				}
			}
		};

		dfs(dfs, rt, -1);

		int total = n, cnt = n;

		for (int i = 0; i < n; i ++) {
			if (s[i] == '0') {
				int u = i;
				total --;

				while (u >= 0 && !cols[u]) {
					cols[u] = 1;
					cnt --;
					u = parent[u];
				}
			}
		}

		for (auto &u: queries) {
			if (s[u] == '1') {
				s[u] = '0';
				total --;
			}

			while (u >= 0 && !cols[u]) {
				cols[u] = 1;
				cnt --;
				u = parent[u];
			}

			cout << 1ll * cnt * (cnt + 1) / 2 + 1ll * cnt * (total - cnt) << '\n';
		}
	}

	return 0;
}
```