**提示 1：** 最后的胜负关系实则形成一棵树。

**提示 2：** 这棵树要满足什么条件？

我们考虑最后比赛的选手之间连边，则这 $n-1$ 条边形成一棵树。

同时，以 $1$ 为根看这棵树，则更靠近 $1$ 的那个是获胜的人。

所以相当于要找这么一棵生成树。

直接从结点 $1$ 开始进行搜索即可，保证每次找到的子节点满足上述条件。

这么做相当于从一个结点向所有它可能战胜的结点连边，在这个图上进行搜索。

这样，一旦有个结点无法到达，则无论如何这个人无法被淘汰（在 $1$ 胜利的情况下），因为如果 $1$ 能最终胜利，一定能找到路径淘汰掉它。。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        grid = [[-1 if c == '?' else int(c) for c in I()] for _ in range(n)]
        
        parent = [-2] * n
        parent[0] = -1
        
        que = [0]
        for u in que:
            for v in range(n):
                if grid[u][v] and parent[v] == -2:
                    parent[v] = u
                    que.append(v)
        
        if len(que) == n:
            res = []
            res.append('Yes')
            for i in reversed(que):
                if i: res.append(f'{parent[i] + 1} {i + 1}')
            outs.append('\n'.join(res))
        else:
            outs.append('No')
    
    print('\n\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<string> grid(n);
		for (auto &s: grid) cin >> s;

		vector<pair<int, int>> ops;
		vector<int> vis(n, 0);

		auto dfs = [&] (auto &self, int u) -> void {
			vis[u] = 1;

			for (int v = 0; v < n; v ++) {
				if (grid[u][v] != '0' && !vis[v]) {
					ops.emplace_back(u, v);
					self(self, v);
				}
			}
		};

		dfs(dfs, 0);

		if (ops.size() + 1 == n) {
			cout << "Yes\n";
			reverse(ops.begin(), ops.end());
			for (auto &[u, v]: ops)
				cout << u + 1 << ' ' << v + 1 << '\n';
		}
		else cout << "No\n";

		if (t) cout << '\n';
	}

	return 0;
}
```