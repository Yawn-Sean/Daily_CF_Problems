**提示 1：** 交换操作有啥用？

**提示 2：** 选完两行后选哪列？

交换可以使得原来不连续的 1 变得连续。

我们枚举选取的是哪两行，那么因为 C 的上下边缘是对齐的，我们应该把所有同为 1 的列拼到一起，所以统计下同是 1 的列的个数。

接下来就考虑 C 的那条竖线，发现只需是已经选取的某一列就行，而这一列可以交换到 C 的第一列，同时所有 1 都可以插入到两个横线之间，所以只需取 1 最多的一列就行。为此，我们维护下每一列有多少个 1 就可以快速找到了。

因此在这种情况下，我们的 C 大小的最大值，就是横线和竖线的长度的最小值。

时间复杂度为 $\mathcal{O}(n^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    grid = [[int(c) for c in I()] for _ in range(n)]
    
    ans = 0
    
    cnt = [0] * n
    for i in range(n):
        for j in range(n):
            if grid[i][j]:
                cnt[j] += 1
                ans = 1
    
    for i in range(n):
        for j in range(i):
            v = 0
            w = 0
            for k in range(n):
                if grid[i][k] and grid[j][k]:
                    v += 1
                    w = fmax(w, cnt[k])
    
            ans = fmax(ans, fmin(v, w))
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<string> grid(n);
	for (auto &s: grid) cin >> s;

	int ans = 0;
	vector<int> cnt(n, 0);

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < n; j ++) {
			if (grid[i][j] == '1') {
				ans = 1;
				cnt[j] ++;
			}
		}
	}

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < i; j ++) {
			int v = 0, w = 0;
			for (int k = 0; k < n; k ++) {
				if (grid[i][k] == '1' && grid[j][k] == '1') {
					v ++;
					w = max(w, cnt[k]);
				}
			}
			ans = max(ans, min(v, w));
		}
	}

	cout << ans;

	return 0;
}
```