**提示 1：** 两侧的问号有用吗？

**提示 2：** 中间的每段问号可以分开考虑。每段最多对几个？可以做到吗？

首先，所有已经知道答案的题可以直接秒了。

而对于开头的一段问号，无论我们怎么填，我们可以从第一个非问号的位置出发，标准答案都可以强行避开我们的答案和自己的下一个答案（三种选择去掉两种肯定还有剩下的），所以我们最坏情况下一个都对不了。

结尾的一段问号也是类似的逻辑。

中间，每段问号都是独立的。

首先，每段问号我们最多猜对一个。因为我们可以把这段问号的最后一个拎出来，前面部分按照之前开头 / 结尾的逻辑，满足这些题的答案都和我们的答案不一致，同时满足相邻不相等。此时我们最多只能答对一题。

接下来看什么情况下我们能答对这一题。

如果问号段长度是 $1$ ，那么当且仅当两侧字母不同时，可以确定此题是能做对的，否则是无法保证的。

在问号段长度不小于 $2$ 时，我们设段落长度是 $k$ ，则我们可以在前 $k-1$ 个位置填入字母，使得如果标准答案跟我们完全不一致的只有一种填法。

比方说，目前是 `A????` 的局面，如果我们选择了 `AB???` ，那标准答案跟我们不一致就只能是 `AC???` 。

如果我们接下来想让完全不一致的标准答案的下一项是 `B` ，我们只需写入 `ABA??` 即可。类似地，可以控制答案的前 $k-1$ 项的任何一项（利用标准答案前一项的限制和我们的写出来的答案的限制），使其是任何一个合法的序列。

而问号段的末尾又给出了一个限制，只要这个限制和第 $k-1$ 项给出的限制不一致，那么我们就一定能保证在前 $k-1$ 都不对的情况下第 $k$ 项答对，也就保证了至少一题正确。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        s = I()
        
        ans = 0
        flg = 0
        
        for i in range(n):
            if s[i] != '?':
                ans += 1
                ans += flg
                flg = 0
            elif i and s[i - 1] != '?':
                if i + 1 < n and s[i + 1] != '?' and s[i - 1] != s[i + 1]:
                    ans += 1
                elif i + 1 < n and s[i + 1] == '?':
                    flg = 1
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		string s;

		cin >> n >> s;

		int ans = 0, flg = 0;

		for (int i = 0; i < n; i ++) {
			if (s[i] != '?') {
				ans += 1 + flg;
				flg = 0;
			}
			else if (i && s[i - 1] != '?') {
				if (i + 1 < n && s[i + 1] != '?' && s[i - 1] != s[i + 1])
					ans ++;
				else if (i + 1 < n && s[i + 1] == '?')
					flg = 1;
			}
		}

		cout << ans << '\n';
	}

	return 0;
}
```