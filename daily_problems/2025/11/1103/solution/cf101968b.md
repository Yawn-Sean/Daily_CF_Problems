**提示 1：** 如何求 $n$ 个矩形交？

**提示 2：** 最终的交的矩形是什么？

**提示 3：** 选择配对的矩形需要满足什么条件？

$n$ 个矩形的交也是矩形，其左边界等于所有矩形的左边界的最大值，右边界是所有矩形右边界的最小值，上边界等于所有矩形上边界的最小值，下边界是所有举行下边界的最大值。

如果算出来左边界大于等于右边界或者下边界大于等于上边界，则交的面积是 $0$ 。

而如果最后交非空，意味着所有 $x$ 中有一半当了左边界，有一半当了右边界；所有 $y$ 中有一半当了上边界，有一半当了下边界。（为啥一半？因为每个矩形都是占一半）于是是根据中位数进行分割的。

如果中位数附近两个数相同，则交面积是 $0$ ，因此无法构造方案，直接输出 $0$ 。

否则，我们考虑每个坐标和中位数的关系。横纵坐标两个都小的一定配两个都大的，(小，大) 一定配 (大，小)，所以我们只需分别统计数量，设横纵坐标都小的数量是 $x$ ，横坐标小但纵坐标大的一定是 $n-x$ 个（因为横坐标小的总共 $n$ 个），类似的，一小一大的点一定是 $n-x$ 个，横纵坐标两个都大的点一定是 $x$ 个。

两组 $x$ 可以任意相互匹配， 两组 $n-x$ 也可以。所以方案数就是 $x!(n-x)!$ 。

具体来说， $k$ 个物品和另外 $k$ 个物品相互匹配，方案数就是，第一个物品有 $k$ 种选择，第二个有 $k-1$ 种，以此类推。

时间复杂度为 $\mathcal{O}(n)$ ，如果你用线性解法求中位数。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    mod = 10 ** 9 + 7
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        xs = []
        ys = []
        
        for _ in range(n * 2):
            x, y = MII()
            xs.append(x)
            ys.append(y)
        
        vxs = sorted(xs)
        vys = sorted(ys)
        
        if vxs[n] == vxs[n - 1] or vys[n] == vys[n - 1]:
            outs.append(0)
        else:
            v1 = 0
            v2 = 0
            ans = 1
            for i in range(n * 2):
                if xs[i] < vxs[n]:
                    if ys[i] < vys[n]:
                        v1 += 1
                        ans = ans * v1 % mod
                    else:
                        v2 += 1
                        ans = ans * v2 % mod
            outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 1e9 + 7;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> xs(n * 2), ys(n * 2);
		for (int i = 0; i < 2 * n; i ++)
			cin >> xs[i] >> ys[i];

		vector<int> vxs = xs, vys = ys;
		sort(vxs.begin(), vxs.end());
		sort(vys.begin(), vys.end());

		if (vxs[n - 1] == vxs[n] || vys[n - 1] == vys[n]) cout << 0 << '\n';
		else {
			int v1 = 1, v2 = 1, ans = 1;
			for (int i = 0; i < 2 * n; i ++) {
				if (xs[i] < vxs[n]) {
					if (ys[i] < vys[n]) ans = 1ll * ans * (v1 ++) % mod;
					else ans = 1ll * ans * (v2 ++) % mod;
				}
			}
			cout << ans << '\n';
		}
	}

	return 0;
}
```