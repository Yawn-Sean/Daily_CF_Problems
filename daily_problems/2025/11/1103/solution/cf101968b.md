**提示 1：** 如何求 $n$ 个矩形交？

**提示 2：** 最终的交的矩形是什么？

**提示 3：** 选择配对的矩形需要满足什么条件？

$n$ 个矩形的交也是矩形，其左边界等于所有矩形的左边界的最大值，右边界是所有矩形右边界的最小值，上边界等于所有矩形上边界的最小值，下边界是所有举行下边界的最大值。

如果算出来左边界大于等于右边界或者下边界大于等于上边界，则交的面积是 $0$ 。

而如果最后交非空，意味着所有 $x$ 中有一半当了左边界，有一半当了右边界；所有 $y$ 中有一半当了上边界，有一半当了下边界。（为啥一半？因为每个矩形都是占一半）于是是根据中位数进行分割的。

如果中位数附近两个数相同，则交面积是 $0$ ，因此无法构造方案，直接输出 $0$ 。

否则，我们考虑每个坐标和中位数的关系。横纵坐标两个都小的一定配两个都大的，(小，大) 一定配 (大，小)，所以我们只需分别统计数量，设横纵坐标都小的数量是 $x$ ，横坐标小但纵坐标大的一定是 $n-x$ 个（因为横坐标小的总共 $n$ 个），类似的，一小一大的点一定是 $n-x$ 个，横纵坐标两个都大的点一定是 $x$ 个。

两组 $x$ 可以任意相互匹配， 两组 $n-x$ 也可以。所以方案数就是 $x!(n-x)!$ 。

具体来说， $k$ 个物品和另外 $k$ 个物品相互匹配，方案数就是，第一个物品有 $k$ 种选择，第二个有 $k-1$ 种，以此类推。

时间复杂度为 $\mathcal{O}(n)$ ，如果你用线性解法求中位数。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 2 * 10 ** 5
    n = II()
    
    cnt1 = [0] * M
    cnt2 = [0] * M
    
    xs = []
    ys = []
    
    for _ in range(n):
        x, y = GMI()
        cnt1[x] += 1
        cnt2[y] += 1
        xs.append(x)
        ys.append(y)
    
    total = 0
    
    dp0, dp1, dp2, dp3 = 1, 0, 0, 0
    for x in cnt1:
        dp3 += dp2 * x
        dp2 += dp1 * x
        dp1 += dp0 * x
    
    total += dp3
    
    dp0, dp1, dp2, dp3 = 1, 0, 0, 0
    for x in cnt2:
        dp3 += dp2 * x
        dp2 += dp1 * x
        dp1 += dp0 * x
    
    total += dp3
    
    dup = math.comb(n, 3)
    
    for v in cnt1:
        dup -= math.comb(v, 2) * (n - v)
    
    for v in cnt2:
        dup -= math.comb(v, 2) * (n - v)
    
    for i in range(n):
        dup += (cnt1[xs[i]] - 1) * (cnt2[ys[i]] - 1)
    
    for v in cnt1: dup -= math.comb(v, 3)
    for v in cnt2: dup -= math.comb(v, 3)
    
    print(total - dup)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, M = 2e5;
	cin >> n;

	vector<int> cnt1(M + 1, 0), cnt2(M + 1, 0);
	vector<pair<int, int>> pts(n);

	for (auto &[x, y]: pts) {
		cin >> x >> y;
		cnt1[x] ++, cnt2[y] ++;
	}

	long long ans = 0;

	vector<long long> dp(4, 0);
	dp[0] = 1;

	for (auto &x: cnt1) {
		for (int i = 3; i > 0; i --) {
			dp[i] += dp[i - 1] * x;
		}
	}

	ans += dp[3];

	fill(dp.begin(), dp.end(), 0);
	dp[0] = 1;

	for (auto &x: cnt2) {
		for (int i = 3; i > 0; i --) {
			dp[i] += dp[i - 1] * x;
		}
	}

	ans += dp[3];

	long long dup = 1ll * n * (n - 1) * (n - 2) / 6;

	for (auto &v: cnt1) dup -= 1ll * v * (v - 1) / 2 * (n - v);
	for (auto &v: cnt2) dup -= 1ll * v * (v - 1) / 2 * (n - v);
	for (auto &[x, y]: pts)
		dup += 1ll * (cnt1[x] - 1) * (cnt2[y] - 1);

	for (auto &v: cnt1) dup -= 1ll * v * (v - 1) * (v - 2) / 6;
	for (auto &v: cnt2) dup -= 1ll * v * (v - 1) * (v - 2) / 6;

	cout << ans - dup;

	return 0;
}
```