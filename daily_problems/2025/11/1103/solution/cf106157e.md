**提示 1：** 如果边数确定，什么变量是确定的？如何最大化面积？

**提示 2：** 没法枚举怎么办？

如果边数确定为 $x$ ，那么我们打点的时间就是 $mx$ ，而总用时是 $t$ ，所以周长是 $t-mx$ 。

周长固定，边数固定，要最大化面积，就是正多边形了。

这个多边形面积如何呢？我们先算其边长，就是 $(t-mx)/x=t/x-m$ 。

接下来考虑正多边形中心和边长形成的三角形的面积。这个三角形是等腰三角形，顶角是 $\frac{2\pi}{x}$ ，底边是 $side=t/x-m$ 。

底边上的高是 $\frac{side}{2\tan{\frac{\pi}{x}}}$ （作一条底边上的垂线，过底边中点，所以就可以用垂线对应的直角三角形求出来高了），所以可以快速得到这个三角形的面积。而 $x$ 边形总共可以拆成 $x$ 个这样的三角形，因此最后面积乘 $x$ 即可。

也就是 $\frac{x\times(t/x-m)^2/4}{\tan{\frac{\pi}{x}}}$ 。

我们没法枚举所有的 $x$ ，但上面这个函数是单峰的，因此可以用二分 / 三分解决。（证明可以自行试试）

特判下构成不了多边形的情况即可。

时间复杂度为 $\mathcal{O}(\log\frac{t}{m})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        m, t = MII()
        
        if t <= 3 * m: outs.append(0)
        else:
            l, r = 3, t // m
            
            def f(x):
                side = (t / x - m) / 2
                return side * side / math.tan(math.pi / x) * x
            
            while l < r:
                mid = (l + r) // 2
                if f(mid) < f(mid + 1):
                    l = mid + 1
                else:
                    r = mid
            
            outs.append(f(l))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	cout << fixed << setprecision(10);
	double pi = acos(-1);

	while (t --) {
		int x, y;
		cin >> x >> y;

		if (y <= 3 * x) cout << 0 << '\n';
		else {
			auto area = [&] (int cnt) -> double {
				double side = (1.0 * y / cnt - x) / 2;
				return side * side / tan(pi / cnt) * cnt;
			};

			int l = 3, r = y / x;
			while (l < r) {
				int mid = (l + r) / 2;
				if (area(mid) < area(mid + 1)) l = mid + 1;
				else r = mid;
			}

			cout << area(l) << '\n';
		}
	}

	return 0;
}
```