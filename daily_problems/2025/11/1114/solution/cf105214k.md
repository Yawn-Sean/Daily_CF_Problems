**提示 1：** 不相邻条件很讨厌，怎么转化掉？

**提示 2：** 找到一种将大情况转化为小情况的方法。

先看提示 1。我们考虑每个 1x2 的方块向右向下拓展成 2x3 的方块，则因为这些方块原本就不相邻，因此扩展之后是不重叠的。同时扩展之后相当于在 $(n+1)\times (n+1)$ 的方格中填。

所以我们把问题转化为了 $(n+1)\times (n+1)$ 的方格中放入最多的 $2\times 3$ 的方格的问题。

于是上界不超过 $\lfloor\frac{(n+1)^2}{6}\rfloor$ ，接下来尝试构造。

我们可以尝试构造 $n$ 较小的情况，构造多少呢？我们先看大的情况怎么转化为小的情况。

如果要能进行转换，那么应该完全将 $(n+1)\times (n+1)$ 变成一个 $(n+1-k)\times (n+1-k)$ 且外侧是填满的才能保证一定转化后最优。

为了好凑，可以使得 $k=6$ ，这样外面刚好六行六列，无论是横着放 $2\times 3$ 还是竖着放 $3\times 2$ 都很合适。

具体如何构造呢？我们只需说明 $6\times k$ 在 $k\geq 2$ 的情况下可以用 $2\times 3$ 密铺，这样，外侧的一圈可以拆分为两个宽度是 $6$ 的矩形，分别填入即可。

我们可以将 $k$ 拆成一系列 $2,3$ 的和，这样整个矩形就拆成了 $6\times 2$ 或 $6\times 3$ 的形状，这两个都很容易用 $2\times 3$ 密铺。

于是，我们可以将所有 $n\geq 7$ 的情况变为 $1\sim 6$ 的情况，接下来只需构造出这些情况的解就行，构造发现可以凑出 $\lfloor\frac{(n+1)^2}{6}\rfloor$ ，所以这样的转化构造没问题。

注意这里不能将 $7\times 7$ 的密铺用上面的方法直接转化为 $1\times 1$ 的密铺，因为这样边缘的一圈就会有一个宽度为 $1$ 的长方形，这种长方形是无法被密铺的，所以需要单独构造。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    d = {}
    
    d[1] = ['.']
    
    d[2] = ['#.',
            '#.']
    
    d[3] = ['#.#',
            '#.#',
            '...']
    
    d[4] = ['#.##',
            '#...',
            '...#',
            '##.#']
    
    d[5] = ['##.##',
            '.....',
            '##.##',
            '.....',
            '##.##']
    
    d[6] = ['##.#.#',
            '...#.#',
            '##....',
            '....##',
            '#.#...',
            '#.#.##']
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        
        v = (n - 1) % 6 + 1
        
        ans = [['.'] * n for _ in range(n)]
        
        for i in range(n - v, n):
            for j in range(n - v, n):
                ans[i][j] = d[v][i - (n - v)][j - (n - v)]
        
        if n % 2:
            for i in range(0, n - v, 3):
                for j in range(0, n, 2):
                    ans[i][j] = '#'
                    ans[i + 1][j] = '#'
        
        else:
            for i in range(0, n - v, 2):
                ans[i][0] = '#'
                ans[i][1] = '#'
            
            for i in range(0, n - v, 3):
                for j in range(3, n, 2):
                    ans[i][j] = '#'
                    ans[i + 1][j] = '#'
        
        if v % 2:
            for i in range(n - v, n, 2):
                for j in range(0, n - v, 3):
                    ans[i][j] = '#'
                    ans[i][j + 1] = '#'
        else:
            for j in range(0, n - v, 2):
                ans[n - v][j] = '#'
                ans[n - v + 1][j] = '#'
            
            for i in range(n - v + 3, n, 2):
                for j in range(0, n - v, 3):
                    ans[i][j] = '#'
                    ans[i][j + 1] = '#'
        
        outs.append('\n'.join(''.join(x) for x in ans))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	unordered_map<int, vector<string>> d;

	d[1] = {
		".",
	};

	d[2] = {
		"#.",
		"#."
	};
	
	d[3] = {
		"#.#",
		"#.#",
		"..."
	};

	d[4] = {
		"#.##",
		"#...",
		"...#",
		"##.#"
	};

	d[5] = {
		"##.##",
		".....",
		"##.##",
		".....",
		"##.##"
	};

	d[6] = {
		"##.#.#",
		"...#.#",
		"##....",
		"....##",
		"#.#...",
		"#.#.##"
	};

	while (t --) {
		int n;
		cin >> n;

		int v = (n - 1) % 6 + 1;

		vector<string> ans(n, string(n, '.'));

		for (int i = n - v; i < n; i ++) {
			for (int j = n - v; j < n; j ++) {
				ans[i][j] = d[v][i - (n - v)][j - (n - v)];
			}
		}

		if (n & 1) {
			for (int i = 0; i < n - v; i += 3) {
				for (int j = 0; j < n; j += 2) {
					ans[i][j] = '#';
					ans[i + 1][j] = '#';
				}
			}
		}
		else {
			for (int i = 0; i < n - v; i += 2) {
				ans[i][0] = '#';
				ans[i][1] = '#';
			}

			for (int i = 0; i < n - v; i += 3) {
				for (int j = 3; j < n; j += 2) {
					ans[i][j] = '#';
					ans[i + 1][j] = '#';
				}
			}
		}

		if (v & 1) {
			for (int i = n - v; i < n; i += 2) {
				for (int j = 0; j < n - v; j += 3) {
					ans[i][j] = '#';
					ans[i][j + 1] = '#';
				}
			}
		}
		else {
			for (int j = 0; j < n - v; j += 2) {
				ans[n - v][j] = '#';
				ans[n - v + 1][j] = '#';
			}

			for (int i = n - v + 3; i < n; i += 2) {
				for (int j = 0; j < n - v; j += 3) {
					ans[i][j] = '#';
					ans[i][j + 1] = '#';
				}
			}
		}

		for (auto &x: ans) cout << x << '\n';
	}

	return 0;
}
```