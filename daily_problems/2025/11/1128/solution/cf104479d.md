**提示 1：** 考虑 $1\sim n$ 满足条件相当于 $1\sim n-1$ 满足条件再加上 $n$ 满足条件。

**提示 2：** 新增的 $n$ 有哪些要求？

因为 $1\sim n$ 满足要求时， $1\sim n-1$ 的子图也满足要求，所以先看提示 1，我们只需确定新加入 $n$ 时需要满足的条件即可。

因为图中无环，所以拓扑序唯一。考虑 $n$ 在拓扑序的第 $i$ 位，则拓扑序在前面的点跟 $n$ 连满足条件的概率都是 $p=\frac{a}{b}$ ，拓扑序在后面的点跟 $n$ 连满足条件的概率都是 $1-p$ 。

所以无论 $1\sim n-1$ 对应的拓扑序如何，只要 $n$ 在 $1\sim n$ 拓扑序的第 $i$ 位，则其对应的概率是 $p^{i-1}(1-p)^{n-i}$ 。

所以 $n$ 对应的答案是 $n-1$ 对应的答案乘 $\sum\limits_{i=1}^n p^{i-1}(1-p)^{n-i}$ 。

这个数咋求呢？当然你可以使用等比数列求和公式，需要注意下 $p=1/2$ 的情况会是公比为 $1$ 。但其实相邻两项之间存在递推关系。我们将 $1-p$ 写作 $q$ ，则：

$p^k+p^{k-1}q+\dots+q^k=p(p^{k-1}+p^{k-2}q+\dots+q^{k-1})+q^k$

所以利用这个线性递推，并在递推的过程中维护 $q^k$ ，就可以线性解决问题了。

时间复杂度为 $\mathcal{O}(n)$ 。 

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, p, q = MII()
    mod = 998244353
    
    prob = p * pow(q, -1, mod) % mod
    
    dp = 1
    val = prob
    cur = 1
    
    for i in range(2, n + 1):
        dp = dp * cur % mod
        val = val * prob % mod
        cur = (cur * (1 - prob) + val) % mod
    
    print(dp)
```

C++ 做法如下——

```cpp []
long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, a, b;
	cin >> n >> a >> b;

	int mod = 998244353;
	int prob = a * quickPow(b, mod - 2, mod) % mod;

	int dp = 1, val = prob, cur = 1;

	for (int i = 2; i <= n; i ++) {
		dp = 1ll * dp * cur % mod;
		val = 1ll * val * prob % mod;
		cur = (1ll * cur * (mod + 1 - prob) % mod + val) % mod;
	}

	cout << dp;

	return 0;
}
```