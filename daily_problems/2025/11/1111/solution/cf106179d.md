**提示 1：** 发现其实不容易证明 “两次操作不能完成任务”，所以可以猜想两次一定可以。

**提示 2：** 构造？

提示 1 的想法常见于很多类似的构造题。

首先，特判只需要一次操作的情况。

如果真要两次操作解决，应该一次操作干掉比较靠前的位置里面比较小的数，一次干掉比较大的数。靠后的位置也应该类似考虑。

于是考虑把数组前后分为两半，数也根据与 $n/2$ 的大小关系分为两半。

那么，前一半的数中较大的数和后一半的数中较小的数的数量是一样的（因为两者加上前一半的数中较小的数都是整个数组长度的一半），这两组放到一起就是一次操作的子序列。剩余的数就是第二次操作的子序列。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        v1 = []
        v2 = []
        
        for i in range(n):
            if (i < n // 2) ^ (nums[i] <= n // 2):
                v1.append(nums[i])
            else:
                v2.append(nums[i])
        
        if len(v1) and len(v2):
            outs.append('2')
            outs.append(f'{len(v1)} {" ".join(map(str, v1))}')
            outs.append(f'{len(v2)} {" ".join(map(str, v2))}')
        else:
            outs.append('1')
            outs.append(f'{n} {" ".join(map(str, nums))}')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> v1, v2;

		for (int i = 0; i < n; i ++) {
			int x; cin >> x;
			if ((i < n / 2) != (x <= n / 2)) v1.emplace_back(x);
			else v2.emplace_back(x);
		}

		if (!v1.empty() && !v2.empty()) {
			cout << 2 << '\n';
			cout << v1.size();
			for (auto &x: v1) cout << ' ' << x;
			cout << '\n';
			cout << v2.size();
			for (auto &x: v2) cout << ' ' << x;
			cout << '\n';
		}
		else {
			cout << 1 << '\n';
			cout << n;
			for (auto &x: v1) cout << ' ' << x;
			for (auto &x: v2) cout << ' ' << x;
			cout << '\n';
		}
	}

	return 0;
}
```