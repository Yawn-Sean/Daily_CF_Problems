**提示 1：** 可以想想 $f(x)$ 到底在做什么。

**提示 2：** 数组需要满足什么条件？怎么计数？

先弄清楚 $f(x)$ ，可以直接讨论下 $f(x)$ 的二进制情况，也可以打表看一下，发现 $f(x)$ 跟 $x$ 很接近，在奇数的情况下等于 $x+2$ ，偶数的情况下等于 $x-2$ 。

而 $f(b_1+b_2+\dots+b_m)=f(b_1)+f(b_2)+\dots+f(b_m)$ ，两侧都是类似于 $b_1+b_2+\dots+b_m$ 的量级。因此考虑相较于这个数的差异。

假设有 $x$ 个奇数 $y$ 个偶数，如果 $x$ 是奇数，则左侧等于 $b_1+b_2+\dots+b_m+2$ ，右侧等于 $b_1+b_2+\dots+b_m+2x-2y$ ，所以 $x=y+1$ 。

否则，如果 $x$ 是偶数，那么左侧等于 $b_1+b_2+\dots+b_m-2$ ，右侧等于 $b_1+b_2+\dots+b_m+2x-2y$ ，所以 $x=y-1$ 。

所以要么 $x=2k+1,y=2k$ ，要么 $x=2k,y=2k+1$ ，我们要统计这样的子数组的个数。

于是我们维护某一个前缀的 $x-y$ 以及当前 $x$ 的奇偶性作为二元组，即可快速根据当前的结果，找到我们需要的另一个前缀需要满足的结果（类似两数之和）。因为 $x-y$ 值域不大，所以可以使用数组维护。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        ans = 0
        
        cnt = [[0] * (2 * n + 5) for _ in range(2)]
        cur = n + 2
        msk = 0
        
        for x in nums:
            cnt[msk][cur] += 1
            
            if x % 2:
                msk ^= 1
                cur -= 1
            else:
                cur += 1
            
            ans += cnt[msk][cur - 1] + cnt[msk ^ 1][cur + 1]
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		long long ans = 0;

		vector<vector<int>> cnt(2, vector<int>(2 * n + 5, 0));
		int cur = n + 2, msk = 0;

		while (n --) {
			cnt[msk][cur] ++;

			int x;
			cin >> x;

			if (x & 1) msk ^= 1, cur --;
			else cur ++;

			ans += cnt[msk][cur - 1] + cnt[msk ^ 1][cur + 1];
		}

		cout << ans << '\n';
	}

	return 0;
}
```