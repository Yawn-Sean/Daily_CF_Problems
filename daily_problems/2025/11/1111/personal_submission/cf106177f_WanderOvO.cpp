/*
对于奇数，f(x) = x + 2
对于偶数，f(x) = x - 2
对于 [b1, bm]，假设有 c 个奇数，则有 m - c 个偶数
如果 c 是奇数，则 b1 + ... + bm 也是奇数，f(b1 + ... + bm) = b1 + ... + bm + 2
而 f(b1) + ... + f(bm) = b1 + ... + bm + 2 * c - 2 * (m - c) = b1 + ... + bm + 4 * c - 2 * m
4 * c - 2 * m = 2 => c = (m + 1) / 2, 整除

如果 c 是偶数，则 b1 + ... + bm 也是偶数，f(b1 + ... + bm) = b1 + ... + bm - 2
而 f(b1) + ... + f(bm) = b1 + ... + bm + 4 * c - 2 * m
4 * c - 2 * m = -2 => c = (m - 1) / 2, 整除

可以看到，m 首先必须是奇数，不然这个东西算出来不是整数，也就是说只有奇数长度的数组可能可以
另外，对于长度为 m 的数组，假如其有奇数个奇数，则必须是 (m + 1) / 2 个，且 (m + 1) / 2 得是奇数
这要求 m + 1 只包含一个素因子 2，于是 m = 2 * k - 1，其中 k 是奇数，相当于 m = 4 * t + 1，t >= 0
假如其有偶数个奇数，则必须是 (m - 1) / 2 个，且 (m - 1) / 2 得是偶数
(m - 1) / 2 是偶数，则 m - 1 应该是 4 的倍数，m 应该是 4 * k + 1 的形式，k >= 0
综上，m = 4 * k + 1, k >= 0 才行

目前来看，计数时要满足的规则依然有点复杂，我们现在还关心 c 的奇偶性
但是 m 的长度的形式有了，我们可以发现本质上就是在说奇数和偶数的个数应该正好差 1 才行
假如把奇数标为 1，偶数标为 -1，则区间和为 1 或者 -1 的区间就是好的
这样的话，我们其实需要把下标分成若干组，用若干个哈希去记前缀和
枚举到一个位置 i 作为右端点时，我们需要在对应的能保证区间长度为 4 * k + 1 的组里查
比如 i 应该查 i - 1, i - 5, i - 9...
查 sum[i] + 1 和 sum[i] - 1 的有多少个
那么，若干个哈希是多少个呢？其实应该是 4 个
我们注意到，i - 1, i - 5, i - 9 这些下标模 4 的余数应该是一样的，所以我们按照下标模 4 的余数组织 4 个哈希
所以本质上这个题就是个复杂的两数之和
*/

int n, a[N], sum[N];

void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (a[i] % 2 == 0) {
            a[i] = -1;
        } else {
            a[i] = 1;
        }
        sum[i] = sum[i - 1] + a[i];
    }
    
    map<int, LL> cnt[4];
    cnt[0][0] = 1;
    LL res = 0;
    for (int i = 1; i <= n; i++) {
        int id = (i - 1) % 4;
        if (cnt[id].count(sum[i] - 1)) {
            res += cnt[id][sum[i] - 1];
        }
        if (cnt[id].count(sum[i] + 1)) {
            res += cnt[id][sum[i] + 1];
        }
        cnt[i % 4][sum[i]]++;
    }
    cout << res << "\n";
}
