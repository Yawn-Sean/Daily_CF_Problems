**提示 1：** 一个序列能否找到构成三角形的数怎么判断？

**提示 2：** 实际需要记录的信息是什么？

首先想想怎么判断？

假设我们所有边已经排序，且当前子序列长度为 $k$ ，则需要前 $k-1$ 个元素是满足要求的，那么第 $k$ 条边需要满足什么条件呢？至少比前 $k-1$ 个数中最大的两个数的和要大，否则可以跟这两边形成三角形。而满足这一条件显然就够用了。

所以相当于排序后，相邻两个的和比下一个数大。

于是自然地，把原数组也排序。同时实际上最重要的也就最大的两个数。所以不妨设状态为最后两个数取第 $i,j$ 个数的方案数为 $dp[i][j]$ 。

接下来 $dp[i][j]$ 如何计算呢？

首先，包括 $[nums[i],nums[j]]$ 这个子序列，先对答案加一。

接下来，考虑从 $dp[i'][i]$ 转移，则 $nums[i']+nums[i]\leq nums[j]$ ， $nums[i']$ 只需不超过 $nums[j]-nums[i]$ ，而 $nums$ 又经过排序了，所以对应于一个前缀，这里可以直接用前缀和优化计算。

同时 $j$ 增大的过程中 $i'$ 也是单调递增的，因此可以用指针维护，一个 $i$ 对应的 $dp[i][j]$ 的维护是 $\mathcal{O}(n)$ 的，最后记得维护关于第一个维度的前缀和就行了。

最后记得加上长度为 $1$ 的子序列。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    nums.sort()
    
    mod = 998244353
    
    dp = [[0] * n for _ in range(n)]
    dp_acc = [[0] * n for _ in range(n)]
    
    for i in range(n):
        pos = 0
        for j in range(i + 1, n):
            while pos < i and nums[i] + nums[pos] <= nums[j]:
                pos += 1
            
            if pos: dp[i][j] = dp_acc[pos - 1][i]
            dp[i][j] += 1
            dp[i][j] %= mod
            
            if i: dp_acc[i][j] = dp_acc[i - 1][j]
            dp_acc[i][j] += dp[i][j]
            dp_acc[i][j] %= mod
    
    ans = 0
    for x in dp:
        for y in x:
            ans += y
    
    print((ans + n) % mod)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mod = 998244353;
	cin >> n;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	sort(nums.begin(), nums.end());
	vector<vector<int>> dp(n, vector<int>(n, 0)), dp_acc(n, vector<int>(n, 0));

	auto add = [&] (int &x, int y) -> void {
		x += y;
		if (x >= mod) x -= mod;
	};

	for (int i = 0; i < n; i ++) {
		int pos = 0;
		for (int j = i + 1; j < n; j ++) {
			while (pos < i && nums[pos] + nums[i] <= nums[j]) pos ++;
			if (pos) dp[i][j] = dp_acc[pos - 1][i];
			add(dp[i][j], 1);
			if (i) dp_acc[i][j] = dp_acc[i - 1][j];
			add(dp_acc[i][j], dp[i][j]);
		}
	}

	int ans = n;
	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < n; j ++) {
			add(ans, dp[i][j]);
		}
	}

	cout << ans;

	return 0;
}
```