**提示 1：** 想想如果某个位置的 $MEX$ 要大于 $x$ ，需要进行什么操作？

**提示 2：** 弄清楚需要维护什么 + 查询什么。

如果我们要使得某个位置的 $MEX$ 大于 $x$ ，则集合里面添加过 $1,2,\dots,x$ 。

为了使得位置 $i$ 的集合中出现过 $k$ ，则 $i-(k-1)$ 一定被作为左端点操作过，且操作时的右端点大于等于 $i$ 。（因为只有这个位置可以使得 $i$ 位置添加 $k$ 这个元素）

而如果要添加过 $x$ 就相当于要求 $i,i-1,i-2,\dots,i-(x-1)$ 进行过操作，且操作的最大右端点不小于 $i$ 。

所以我们维护每个点作为左端点操作到的最大右端点，我们需要这个区间最小值不小于 $i$ 。这件事显然可以使用线段树 + 线段树二分解决，只需二分找到往左走第一个严格小于 $i$ 的位置。

时间复杂度为 $\mathcal{O}(n+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    seg = SegTree(fmin, n, [-1] * n)
    
    outs = []
    for _ in range(q):
        query = LII()
        
        if query[0] == 1:
            l, r = query[1] - 1, query[2] - 1
            seg.set(l, fmax(seg.get(l), r))
        else:
            idx = query[1] - 1
            pos = seg.min_left(idx + 1, lambda x: x >= idx)
            outs.append(idx - pos + 2)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int op(int x, int y) {return min(x, y);}

int e() {return 1'000'000;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	atcoder::segtree<int, op, e> seg(vector<int>(n, -1));

	while (q --) {
		int t;
		cin >> t;

		if (t == 1) {
			int l, r;
			cin >> l >> r;
			l --, r --;
			seg.set(l, max(seg.get(l), r));
		}
		else {
			int idx;
			cin >> idx;
			idx --;
			int pos = seg.min_left(idx + 1, [&] (int val) {return val >= idx;});
			cout << idx - pos + 2 << '\n';
		}
	}

	return 0;
}
```