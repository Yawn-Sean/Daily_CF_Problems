**提示 1：** 考虑子数组需要满足的条件。

**提示 2：** 条件组合如何计数？

首先，显然左括号和右括号一样多，所以子数组的和一定得是 $0$ 。

同时，相邻两个至少有一个负数，同时最后一项只能是负数，所以一定能保证的是负数不比正数少。

这两个条件够吗？答案是肯定的。感性描述，考虑把所有绝对值大的正数往前排，所有绝对值大的负数往后排，同时保证间隔。这样一旦中间出现过负数，则之后遇到的正数会越来越小，负数会负的越来越多，最后一定无法到达 $0$ 。（可以尝试将上述思路转为更严谨的表达）

所以我们只需找满足上述两个条件的子数组的个数。

我们将前缀和相等的位置放到一起考虑，这些位置之间形成的子数组都满足和为 $0$ 。

接下来我们只需保证负数不比正数少。为此我们求前缀的负数个数减正数个数的数值，则可取的两个位置需要满足后面位置的前缀负数个数减正数个数数值更大，这种数对的个数显然可以使用树状数组（其实等价于求逆序对个数，所以也可以用归并排序之类的）。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    d = defaultdict(list)
    orig = random.getrandbits(30)
    
    cur = orig
    neg = 0
    
    d[cur].append(0)
    
    for i in range(n):
        cur += nums[i]
        if nums[i] < 0: neg += 1
        else: neg -= 1
        d[cur].append(neg)
    
    for x in d.values():
        x.sort()
    
    fens = {x: FenwickTree(len(d[x])) for x in d}
    
    ans = 0
    
    cur = orig
    neg = 0
    
    fens[cur].add(bisect.bisect_left(d[cur], neg), 1)
    
    for i in range(n):
        cur += nums[i]
        if nums[i] < 0: neg += 1
        else: neg -= 1
        
        p = bisect.bisect_left(d[cur], neg)
        ans += fens[cur].rsum(0, p)
        fens[cur].add(p, 1)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	long long cur = 0;
	int neg = 0;
	map<long long, vector<int>> mp;

	mp[cur].emplace_back(0);
	for (int i = 0; i < n; i ++) {
		cur += nums[i];
		if (nums[i] < 0) neg ++;
		else neg --;
		mp[cur].emplace_back(neg);
	}

	map<long long, atcoder::fenwick_tree<int>> fens;

	for (auto &[k, v]: mp) {
		fens[k] = atcoder::fenwick_tree<int>(v.size());
		sort(v.begin(), v.end());
	}

	cur = 0;
	neg = 0;

	long long ans = 0;

	fens[cur].add(lower_bound(mp[cur].begin(), mp[cur].end(), neg) - mp[cur].begin(), 1);
	for (int i = 0; i < n; i ++) {
		cur += nums[i];
		if (nums[i] < 0) neg ++;
		else neg --;
		int p = lower_bound(mp[cur].begin(), mp[cur].end(), neg) - mp[cur].begin();
		ans += fens[cur].sum(0, p + 1);
		fens[cur].add(p, 1);
	}

	cout << ans;

	return 0;
}
```