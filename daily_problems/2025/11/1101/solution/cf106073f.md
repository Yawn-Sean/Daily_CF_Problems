**提示 1：** 考虑期望可加性。

**提示 2：** 考虑每个 “到达位置” 操作对结果的贡献。

情况太多了，还是得用期望可加性做的。

考虑每个操作。如果其是 “到达位置 $i$ ”，这件事发生的概率是 $\frac{1}{2}$ ，同时之后这个位置可能会被上一定量的菜。

假设之后依次出现了 $x_1,x_2,\dots$ ，第一个数字有 $\frac{1}{2}$ 的概率被选到上菜，第二个位置有 $\frac{1}{4}$ 的概率被选到上菜（需要前两个位置都选到上菜才会产生贡献）……则之后对 $i$ 这个位置的贡献是 $\frac{1}{2}x_1+\frac{1}{2^2}x_2+\dots$ 。

唯一需要特判的情况是，因为一开始机器人就在位置 $1$ ，因此这件事发生的概率不再是 $\frac{1}{2}$ 而不是 $1$ 。

同时还需要注意 $\frac{1}{2}x_1+\frac{1}{2^2}x_2+\dots$ 的计算不能每次暴力进行，容易注意到的是相邻两个位置的这个数值是存在递推关系的，因为 $\frac{1}{2}x_1+\frac{1}{2^2}x_2+\frac{1}{2^3}x_3+\frac{1}{2^4}x_4+\dots=\frac{1}{2}x_1+\frac{1}{2}\times(\frac{1}{2}x_2+\frac{1}{2^2}x_3+\frac{1}{2^3}x_4+\dots)$ 。

时间复杂度为 $\mathcal{O}(n+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    nums = LII()
    mod = 10 ** 9 + 7
    rev2 = (mod + 1) // 2
    
    ans = [0] * (n + 1)
    
    cur = 0
    for v in reversed(nums):
        ans[v] = (ans[v] + cur * rev2) % mod
        cur = (cur + v) * rev2 % mod
    
    ans[1] = (ans[1] + cur) % mod
    
    print(*ans[1:], sep='\n')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	vector<int> nums(q);
	for (auto &v: nums) cin >> v;

	int mod = 1e9 + 7, rev2 = (mod + 1) / 2;
	vector<int> ans(n + 1, 0);

	int cur = 0;
	reverse(nums.begin(), nums.end());

	for (auto &v: nums) {
		ans[v] = (1ll * cur * rev2 + ans[v]) % mod;
		cur = 1ll * (cur + v) * rev2 % mod;
	}

	ans[1] = (ans[1] + cur) % mod;

	for (int i = 1; i <= n; i ++)
		cout << ans[i] << '\n';

	return 0;
}
```