**提示 1：** 只满足一个条件的是容易的。接下来算满足两个条件的就可以用容斥原理了。

**提示 2：** 后者也可以容斥来算。

只满足一个条件的很好算，相当于一个数组中选 $3$ 个元素使得两两不同。我们先统计每个元素出现频率，接下来相当于其中选三个元素相乘。我们 DP 维护选择到第 $i$ 个位置为止，选择 $j$ 个元素相乘的和的结果即可。

我们将两个条件的结果相加，就多算了那些两个条件都满足的三元组。我们要对这件事计数。

接下来考虑两个条件都满足。考虑使用容斥原理。

先找到基础，就是 $n$ 个元素选 $3$ 个。

不满足条件一定第一个性质和第二个性质中有一个性质的属性值选了俩。

我们枚举这个性质。第三个东西的属性值如果也相同，就相当于在同个属性中选 $3$ 个，是很容易计算的。

否则，前两个选取的属性值相同，第三个东西的属性值不同，需要将这些情况扣除。相当于在某个属性中选择了两个，再在剩余所有选项中选择了一个。假设前者的统计是 $v$ ，则方案数是 $C_v^2\times (n-v)$ 。

这样又多扣掉了哪些呢？那些两侧都有重复的。考虑分别重复的是性质 $a_i$ 和性质 $b_i$ 则 $a_i,b_i$ 是必选的。我们需要另选一个性质是 $a_i$ 和性质是 $b_i$ 且不为 $(a_i,b_i)$ 的，这个方案数可以快速通过 $a_i,b_i$ 的出现次数得到。

时间复杂度为 $\mathcal{O}(n+M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 2 * 10 ** 5
    n = II()
    
    cnt1 = [0] * M
    cnt2 = [0] * M
    
    xs = []
    ys = []
    
    for _ in range(n):
        x, y = GMI()
        cnt1[x] += 1
        cnt2[y] += 1
        xs.append(x)
        ys.append(y)
    
    total = 0
    
    dp0, dp1, dp2, dp3 = 1, 0, 0, 0
    for x in cnt1:
        dp3 += dp2 * x
        dp2 += dp1 * x
        dp1 += dp0 * x
    
    total += dp3
    
    dp0, dp1, dp2, dp3 = 1, 0, 0, 0
    for x in cnt2:
        dp3 += dp2 * x
        dp2 += dp1 * x
        dp1 += dp0 * x
    
    total += dp3
    
    dup = math.comb(n, 3)
    
    for v in cnt1:
        dup -= math.comb(v, 2) * (n - v)
    
    for v in cnt2:
        dup -= math.comb(v, 2) * (n - v)
    
    for i in range(n):
        dup += (cnt1[xs[i]] - 1) * (cnt2[ys[i]] - 1)
    
    for v in cnt1: dup -= math.comb(v, 3)
    for v in cnt2: dup -= math.comb(v, 3)
    
    print(total - dup)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, M = 2e5;
	cin >> n;

	vector<int> cnt1(M + 1, 0), cnt2(M + 1, 0);
	vector<pair<int, int>> pts(n);

	for (auto &[x, y]: pts) {
		cin >> x >> y;
		cnt1[x] ++, cnt2[y] ++;
	}

	long long ans = 0;

	vector<long long> dp(4, 0);
	dp[0] = 1;

	for (auto &x: cnt1) {
		for (int i = 3; i > 0; i --) {
			dp[i] += dp[i - 1] * x;
		}
	}

	ans += dp[3];

	fill(dp.begin(), dp.end(), 0);
	dp[0] = 1;

	for (auto &x: cnt2) {
		for (int i = 3; i > 0; i --) {
			dp[i] += dp[i - 1] * x;
		}
	}

	ans += dp[3];

	long long dup = 1ll * n * (n - 1) * (n - 2) / 6;

	for (auto &v: cnt1) dup -= 1ll * v * (v - 1) / 2 * (n - v);
	for (auto &v: cnt2) dup -= 1ll * v * (v - 1) / 2 * (n - v);
	for (auto &[x, y]: pts)
		dup += 1ll * (cnt1[x] - 1) * (cnt2[y] - 1);

	for (auto &v: cnt1) dup -= 1ll * v * (v - 1) * (v - 2) / 6;
	for (auto &v: cnt2) dup -= 1ll * v * (v - 1) * (v - 2) / 6;

	cout << ans - dup;

	return 0;
}
```