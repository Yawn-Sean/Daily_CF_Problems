**提示 1：** 考虑枚举右端点，左端点需要满足什么条件？备选的左端点有哪些？

**提示 2：** 需要维护什么东西？

右端点为 $r$ 时，左端点需要使得 $b_l,\dots,b_r$ 之间不出现 $a_r$ ，因此我们只需找到 $a_r$ 在 $b$ 数组中上一次出现的为止，保证左端点在这个位置的右边就行。这里得到了区间 $[l',r]$ 。

而左端点的条件呢？

考虑某个左端点 $l$ ，因为其在 $b_l,\dots,b_r$ 中出现，所以在第二个数组中出现的位置在 $[l,r]$ 之间。因此我们只需找到 $a_l$ 在 $l$ 后第一次出现的位置，则遍历到这个位置后，对于更大的 $r$ ，这个 $l$ 就永远是合法的了。

所以我们从小到大遍历 $r$ ，不断更新合法的 $l$ ，再统计区间 $[l',r]$ 中合法的 $l$ 个数即可。这里显然可以使用树状数组统计。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    rnd = random.getrandbits(30)
    
    for _ in range(t):
        n = II()
        v1 = [x ^ rnd for x in MII()]
        v2 = [x ^ rnd for x in MII()]
        
        ans = 0
        
        fen = FenwickTree(n)
        
        cur_status = defaultdict(list)
        last_pos = {}
        
        for i in range(n):
            last_pos[v2[i]] = i
            start = last_pos[v1[i]] + 1 if v1[i] in last_pos else 0
            
            cur_status[v1[i]].append(i)
            while cur_status[v2[i]]:
                fen.add(cur_status[v2[i]].pop(), 1)
            
            ans += fen.rsum(start, i)
    
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, rnd = rng();
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> v1(n), v2(n);
		for (auto &x: v1) cin >> x, x ^= rnd;
		for (auto &x: v2) cin >> x, x ^= rnd;

		long long ans = 0;
		atcoder::fenwick_tree<int> fen(n);

		unordered_map<int, vector<int>> cur_status;
		unordered_map<int, int> last_pos;

		for (int i = 0; i < n; i ++) {
			last_pos[v2[i]] = i;
			auto pt = last_pos.find(v1[i]);
			int start = (pt == last_pos.end() ? 0 : pt->second + 1);
			cur_status[v1[i]].emplace_back(i);

			auto pt2 = cur_status.find(v2[i]);
			if (pt2 != cur_status.end()) {
				auto v = pt2->second;
				for (auto &idx: v) fen.add(idx, 1);
				cur_status.erase(pt2);
			}

			ans += fen.sum(start, i + 1);
		}

		cout << ans << '\n';
	}

	return 0;
}
```