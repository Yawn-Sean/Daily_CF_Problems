**提示 1：** 相邻格子的操作容易联想到交换。能否通过一些变换使得原始操作等价于交换呢？

**提示 2：** 交换意味着可以移动。我们能否把一个黑色格子移动到别的位置里去呢？

相邻的操作可以考虑交换。而本题的操作等价于任选两个格子交换，交换后，两者取反。容易验证跟题设是一回事（黑白交换后不会改变）。

取反这一步是不好看的，怎么去掉呢？

可以强行先对所有行列和为奇数的位置进行取反（类似于棋盘染色）。

这样相邻位置交换，相当于已经通过这个整体的取反解决了相邻两块的取反问题（因为交换的两个位置上述操作的结果一定不同，两个格子移动到新的位置相当于自动取反了一次，这个取反和原有操作的取反刚好抵消了），也就相当于我们的操作变成了交换相邻位置的操作。

所以我们对操作前后的矩阵都进行这些位置的取反。

此时，在交换的语境下，如果黑色格子数不同一定无法操作。

否则，我们只需找到一个黑色格子的位置，移动到一个白色的位置，只要这件事能完成，那么 $\mathcal{O}(nm)$ 次这样的操作后一定满足了要求。

我们先找到一条路径连结这两个格子。接下来我们想让第一个格子变白，最后一个格子变黑。

如果前方位置是白色，那么直接交换。否则前面有一大块黑色，跟当前块连成了一长条。这个长条只需向前移动一格就行，那显然最前面的格子先交换，一直交换到最后面的格子就好。接下来要进行操作的是这个长条里最前面的这个黑色方块（相当于代替原来的黑色方块尝试和终点会合）。

所以操作次数是 $\mathcal{O}(n+m)$ 的，也就符合要求了。

时间复杂度为 $\mathcal{O}(nm(n+m))$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, m = MII()
        grid1 = [[1 if c == '#' else 0 for c in I()] for _ in range(n)]
        grid2 = [[1 if c == '#' else 0 for c in I()] for _ in range(n)]
        
        for i in range(n):
            for j in range(m):
                if (i + j) % 2:
                    grid1[i][j] ^= 1
                    grid2[i][j] ^= 1
        
        p1 = []
        p2 = []
        
        for i in range(n):
            for j in range(m):
                if grid1[i][j] != grid2[i][j]:
                    if grid1[i][j]: p1.append((i, j))
                    if grid2[i][j]: p2.append((i, j))
        
        if len(p1) != len(p2): outs.append('-1')
        else:
            ops = []
            
            def go(v1, v2):
                x1, y1 = v1
                x2, y2 = v2
                
                dx = 1 if x2 >= x1 else -1
                dy = 1 if y2 >= y1 else -1
                
                x, y = x1, y1
                cur = [(x1, y1)]
                
                while x != x2:
                    x += dx
                    if grid1[x][y] == 0:
                        cur.append((x, y))
                        for i in range(len(cur) - 1, 0, -1):
                            vx1, vy1 = cur[i]
                            vx2, vy2 = cur[i - 1]
                            grid1[vx1][vy1], grid1[vx2][vy2] = grid1[vx2][vy2], grid1[vx1][vy1]
                            ops.append(f'{vx1 + 1} {vy1 + 1} {vx2 + 1} {vy2 + 1}')
                        cur.clear()
                    cur.append((x, y))
                
                while y != y2:
                    y += dy
                    if grid1[x][y] == 0:
                        cur.append((x, y))
                        for i in range(len(cur) - 1, 0, -1):
                            vx1, vy1 = cur[i]
                            vx2, vy2 = cur[i - 1]
                            grid1[vx1][vy1], grid1[vx2][vy2] = grid1[vx2][vy2], grid1[vx1][vy1]
                            ops.append(f'{vx1 + 1} {vy1 + 1} {vx2 + 1} {vy2 + 1}')
                        cur.clear()
                    cur.append((x, y))
            
            for v1, v2 in zip(p1, p2):
                go(v1, v2)
            
            outs.append(str(len(ops)))
            if ops: outs.append('\n'.join(ops))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, m;
		cin >> n >> m;
		vector<string> grid1(n), grid2(n);
		for (auto &s: grid1) cin >> s;
		for (auto &s: grid2) cin >> s;

		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < m; j ++) {
				if ((i + j) & 1) {
					grid1[i][j] ^= '#' ^ '.';
					grid2[i][j] ^= '#' ^ '.';
				}
			}
		}

		vector<pair<int, int>> p1, p2;

		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < m; j ++) {
				if (grid1[i][j] != grid2[i][j]) {
					if (grid1[i][j] == '#') p1.emplace_back(i, j);
					else p2.emplace_back(i, j);
				}
			}
		}

		if (p1.size() != p2.size()) cout << -1 << '\n';
		else {
			vector<array<int, 4>> ops;

			auto go = [&] (pair<int, int> v1, pair<int, int> v2) -> void {
				auto [x1, y1] = v1;
				auto [x2, y2] = v2;

				int dx = (x2 >= x1 ? 1 : -1);
				int dy = (y2 >= y1 ? 1 : -1);

				int x = x1, y = y1;
				vector<pair<int, int>> cur;
				cur.emplace_back(x, y);

				while (x != x2) {
					x += dx;
					if (grid1[x][y] == '.') {
						cur.emplace_back(x, y);
						for (int i = cur.size() - 1; i > 0; i --) {
							auto [vx1, vy1] = cur[i];
							auto [vx2, vy2] = cur[i - 1];
							swap(grid1[vx1][vy1], grid1[vx2][vy2]);
							ops.push_back({vx1, vy1, vx2, vy2});
						}
						cur.clear();
					}
					cur.emplace_back(x, y);
				}

				while (y != y2) {
					y += dy;
					if (grid1[x][y] == '.') {
						cur.emplace_back(x, y);
						for (int i = cur.size() - 1; i > 0; i --) {
							auto [vx1, vy1] = cur[i];
							auto [vx2, vy2] = cur[i - 1];
							swap(grid1[vx1][vy1], grid1[vx2][vy2]);
							ops.push_back({vx1, vy1, vx2, vy2});
						}
						cur.clear();
					}
					cur.emplace_back(x, y);
				}
			};

			for (int i = 0; i < p1.size(); i ++) go(p1[i], p2[i]);

			cout << ops.size() << '\n';

			for (auto &[x1, y1, x2, y2]: ops)
				cout << x1 + 1 << ' ' << y1 + 1 << ' ' << x2 + 1 << ' ' << y2 + 1 << '\n';
		}
	}

	return 0;
}
```