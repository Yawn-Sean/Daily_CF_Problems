**提示 1：** 对称性。

考虑把算式种所有加法和减法都翻转，则后面的数都抵消了。所以我们求的是第一个数的期望。

如果是前 $k$ 位形成第一个数，则其间 $k-1$ 个位置不能添加符号，最后的位置需要添加符号，因此贡献是 $(\frac{1}{10})^{k-1}\frac{9}{10}$ 。

这个 $9/10$ 可以放到之后再处理，前面的乘以 $1/10$ 是很容易算的，只需要加个小数点。而每次算的两个小数之间只差了最后一位的 $0.00\dots 0x$ ，所以很容易用新增量来进行更新。

唯一的特殊情况就是完全没有加入任何一个计算符号，这件事的概率是 $1/10^{|s|-1}$ ，特判下就行。

时间复杂度为 $\mathcal{O}(n)$ 。疑似出要保留所有精度的话会更像题。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = [int(c) for c in I()]
    k = len(n)
    
    ans = 0
    val = 0
    cur = 1
    
    for i in range(k - 1):
        val += n[i] * cur
        ans += val
        cur = cur / 10
    
    val += n[-1] * cur
    print(ans * 0.9 + val)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	string n;
	cin >> n;

	int k = n.size();

	long double ans = 0, val = 0, cur = 1;

	for (int i = 0; i < k - 1; i ++) {
		val += (n[i] - '0') * cur;
		ans += val;
		cur /= 10;
	}

	val += (n.back() - '0') * cur;

	cout << fixed << setprecision(15) << ans * 0.9 + val;

	return 0;
}
```