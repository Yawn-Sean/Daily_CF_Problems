**提示 1：** 答案的上界是什么？什么情况下容易得到？

**提示 2：** 剩余情况怎么办？

首先，每次卡片减少一张，同时最后如果开头有卡片，最后也一定至少剩一张卡片，因此答案的上界是卡片数量总和减去 $1$ 。

如果开局就没有一堆能操作，那显然答案就只能是 $0$ 了，特判这种情况。

否则，我们开局直接尽可能把所有数量大于 $1$ 的卡片全部汇集到卡片数量最多的那种里面，这样最后就剩下一组比较多的卡片和一堆 $0/1$ 。这个情况相对就简单一些了。

此时，如果数组中有 $1$ ，我们可以对较多的那组进行操作，把这个 $1$ 变成 $2$ ，再用这个 $2$ 进行操作，以此类推，最后把所有 $1$ 吃掉后，就只剩下开局的那组最多的卡片了。

而这组卡片数量不小于 $2$ 。

在卡片数量不是 $3$ 的倍数的情况下，只需不断取 $4$ 个变成 $2$ 个另一种颜色再变回来，这样卡片数量就能不断减少 $3$ ，最后剩下 $1/2$ 张卡片，这个显然能再进行操作使得最后只有一种颜色，所以此时可以达到总和减 $1$ 的上界。

否则，如果卡片数量超过了 $3$ ，则可以将卡片数量变到 $6$ 。此时可以这么做：

`[0,6]->[1,4]`

而这就转化为了前面最多的一堆卡片不是 $3$ 的倍数的情况了，所以也解决了。

还剩下的情况是最多的一堆数量是 $3$ 。此时，如果开局的数组中有其他非 $0$ 数，则在最后一步变成一堆 $0$ 和 $3$ 之前是 $[2,2]$ + 可能的一堆 $0$ 。此时如果数组长度大于等于 $3$ ，我们可以这么做：

`[2,2,0,...]->[0,2,1,...]->[0,0,2,...]->[1,0,0,...]`

所以接下来剩下的情况就只有数组长度为 $2$ 和开局只有一个 $3$ ，其它都是 $0$ 的情况了。

对于前者，我们可以直接模拟，因为每次操作的结果是不可选的，而每轮操作卡片数量折半，所以模拟次数是 $\mathcal{O}(\log)$ 量级的，可以接受；对于后者，答案显然是 $1$ 。

针对上面的结论进行分类讨论即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        ma = max(nums)
        if ma < 2: outs.append(0)
        elif n == 2:
            x, y = nums
            ans = 0
            while x > 1 or y > 1:
                nx = x // 2
                ny = y // 2
                x %= 2
                y %= 2
                ans += nx + ny
                x += ny
                y += nx
            outs.append(ans)
        elif ma == 3 and sum(nums) == 3:
            outs.append(1)
        else: outs.append(sum(nums) - 1)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		int ma = *max_element(nums.begin(), nums.end());

		if (ma < 2) cout << 0 << '\n';
		else if (n == 2) {
			int x = nums[0], y = nums[1];
			int ans = 0;

			while (x > 1 || y > 1) {
				int nx = x / 2, ny = y / 2;
				x &= 1, y &= 1;
				ans += nx + ny;
				x += ny, y += nx;
			}

			cout << ans << '\n';
		}
		else {
			long long total = 0;
			for (auto &x: nums) total += x;
			cout << (total == 3 && ma == 3 ? 1 : total - 1) << '\n';
		}
	}

	return 0;
}
```