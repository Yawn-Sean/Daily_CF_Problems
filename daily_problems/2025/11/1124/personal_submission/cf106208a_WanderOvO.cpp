/*
我们考虑 [l, r] 中每个数的贡献次数
先考虑一下特殊的端点吧
len = r - l + 1
l 贡献的期望次数是  
某个 i in [l, r]，期望贡献次数是多少
我注意到一个事情
[l, r] 每个元素比上一个元素 + 1
从 [l, r] 中随机选一个数，给 score 的期望贡献应该是 (r - l + 1) / 2
即区间中点
这样随机选元素的问题就解决了
接下来需要解决随机选区间的问题
我们相当于考虑，每个数/数之间的缝隙作为区间中点出现了多少次
对于数 i，其作为区间中点出现，有 min(i - l + 1, r - i + 1) 种情况
对于 i 和 i + 1 之间的缝隙，即 (i + 1) / 2，其作为区间中点出现有 min(i - l + 1, r - i) 种情况
每种情况出现的概率是多少呢？可以简单的认为是 1 / (len * (len + 1) / 2 - 1) 吗?
能不能考虑从某个区间扩展，而不是缩小区间呢？
比如 [i, j]，考虑其有多少种方案能扩展到 [l, r]，则 [i, j] 就贡献了多少次
[i, j] 有 (i - l + 1) * (r - j + 1) - 1 个真父区间
但其真父区间也有若干个转移来源，所以不方便计算 [i, j] 真正被遍历到的次数
相当于，左端点还能移动 i - l 步，右端点还能移动 r - j 步
每次移动可以移动若干步，左右也可能一起走，需要对这个计数

我们现在卡在了某个区间 [i, j] 被选到的期望次数上
其实相当于卡在了某个中间值贡献的期望次数上
并且就算真算出来了每个区间被选到的期望次数，区间个数是平方级别的，也没法暴力枚举去算
可能还是需要大力推一些式子

事实上可以进一步利用对称性
考虑某个 [i, j]，以及和其对称的区间 [k, l]
根据对称性，缩小区间得到 [i, j] 和得到 [k, l] 的情况数应该是一样的
而又由于对称性，两个区间的贡献本来是 (i + j) / 2 和 (k + l) / 2，现在都可以看成是 (l + r) / 2 了
所以，关键的地方只在于 [l, r] 经过多少轮变成了单点区间，简单来说就是变换轮数

变换轮数其实就是关心长度啥时候变成 1
考虑从长度为 i 的区间变成长度为 1 的区间，期望需要多少轮，记作 dp[i]
长度为 i 的区间有 i * (i + 1) / 2 - 1 个真子区间
其中，长度为 i - 1 的有 2 个，长度为 i - 2 的有 3 个...
dp[i] = (2 * dp[i - 1] + 3 * dp[i - 2] + ... + i * dp[1]) / (i * (i + 1) / 2 - 1) + 1
这个东西要想加速转移，需要把这个加权后缀和搞定了
我们需要维护一个前缀和，以及维护前缀和的前缀和
dp[1], dp[1] + dp[2], dp[1] + dp[2] + dp[3]
dp[1], 2 * dp[1] + dp[2], 3 * dp[1] + 2 * dp[2] + dp[3]
最后求出 dp[r - l + 1] 之后，只需要乘以 (l + r) / 2 就是最终结果了
*/

LL dp[N], s[N], ss[N], inv2;
const int mod = 998244353;

LL qpow(LL a, LL b, LL mod) {
    LL res = 1, base = a % mod;
    while (b) {
        if (b & 1) {
            res = res * base % mod;
        }
        base = base * base % mod;
        b >>= 1;
    }
    return res % mod;
}

void solve() {   
    LL l, r;
    cin >> l >> r;
    cout << dp[r - l + 1] * (l + r) % mod * inv2 % mod << "\n";
}

void prepare() {
    inv2 = qpow(2, mod - 2, mod);
    dp[1] = 1;
    s[1] = dp[1];
    ss[1] = s[1];
    for (LL i = 2; i < N; i++) {
        LL mother = i * (i + 1) / 2 - 1;
        mother = qpow(mother, mod - 2, mod);
        dp[i] = (((s[i - 1] + ss[i - 1]) % mod) * mother + 1) % mod;
        s[i] = s[i - 1] + dp[i];
        s[i] %= mod;
        ss[i] = ss[i - 1] + s[i];
        ss[i] %= mod;
    }
}
