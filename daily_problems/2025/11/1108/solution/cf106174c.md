**提示 1：** 数字增大，位数显然不减。

**提示 2：** 如何统计一段数的数码数和？

首先，数字增大，数字位数不减，所以我们不断向右移动左端点，相当于删去左侧的数加上右侧的数，也就保证了整体位数是增多的。

于是满足单调性，可以使用二分。

接下来唯一的问题就是求一个区间 $[l, r]$ 内的数位和，而用经典套路，求 $[1,r]$ 的结果减去 $[1,l-1]$ 的结果即可。

而接下来我们只需分类讨论每个数位长度有多少个数落入区间中。有 $k$ 个数位的数的范围是 $[10^{k-1},10^k-1]$ ，我们只需求区间交长度即可，这是很容易的。

当然如果你想的话也可以不转化为两个前缀和相减，直接求区间交长度即可。

$[l_1,r_1],[l_2,r_2]$ 的交是 $[\max(l_1,l_2),\min(r_1,r_2)]$ ，如果左端点大于右端点则是空。

时间复杂度为 $\mathcal{O}(\log^2M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def f(x):
        start = 1
        d = 1
        ans = 0
        
        for _ in range(18):
            if start > x: break
            ans += fmin(start * 9, x - start + 1) * d
            start *= 10
            d += 1
        
        return ans
    
    n = II()
    k = II()
    
    l, r = 1, 10 ** 18
    
    while l <= r:
        mid = (l + r) // 2
        
        if f(mid + n - 1) - f(mid - 1) < k: l = mid + 1
        else: r = mid - 1
    
    print(l if f(l + n - 1) - f(l - 1) == k else -1)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	auto f = [&] (long long x) -> long long {
		long long start = 1;
		int d = 1;
		long long ans = 0;

		for (int i = 0; i < 18; i ++) {
			if (start > x) break;
			ans += min(start * 9, x - start + 1) * d;
			start *= 10;
			d ++;
		}

		return ans;
	};

	long long n, k, l, r;
	cin >> n >> k;

	l = 1, r = 1e17;

	while (l <= r) {
		long long mid = (l + r) / 2;
		if (f(mid + n - 1) - f(mid - 1) < k) l = mid + 1;
		else r = mid - 1;
	}

	if (f(l + n - 1) - f(l - 1) == k) cout << l;
	else cout << -1;

	return 0;
}
```