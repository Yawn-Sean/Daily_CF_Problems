**提示 1：** 找下下界。

**提示 2：** 可以构造吗？怎么构造？怎么找到路径？

首先，对于某个叶子结点而言，设其他结点和它的最远距离是 $v$ ，则答案不可能超过 $v$ ，因为我们考虑经过这个结点的满足条件的 $K$ 路径，路径终点到这个点的距离是 $K$ ，也就不超过最大值 $v$ 。

怎么求这个最大距离呢？找到直径，两个端点中一定有一个是可取的。

能构造吗？答案是肯定的。

上述路径来自于直径，所以考虑通过直径入手。

我们先对直径上的边进行 $0,1,2,\dots,K-1,0,1,2,\dots,K-1,\dots$ 染色。

接下来直径中点的左边部分，其更远的直径端点在右边，所以寻找路径应该往右找，所以从直径上的点除法，应该往小里编号。同样地，右边部分应该往大里编号。

我们已经完成了边的编号。接下来我们如何找到合法经过给定边的路径呢？

有很多种构造方案，这里给出个人认为还算能写的一种。

对于某条边的查询，我们找到这条边远离中点的一个叶子结点，接下来再找该叶子结点对应的直径上的点。

等下，这个点一定在直径上吗？答案是肯定的，因为任何一个点到直径的两个端点的距离和不小于直径长度，所以对于每个叶子节点而言，其中的较大值 $K$ 一定大于直径的一半。所以如果走 $K$ 步还没走到直径上，那么走的距离已经大于直径的一半，而进入直径的点到某个端点的距离也不小于直径的一半，这样我们就构造出了一条比直径还长的路径，也就产生了矛盾。

而这个直径上的点怎么找呢？我们用刚刚的标号结果，如果不对标号结果取模，那么距离叶子节点为 $K$ 的点其编号结果也刚好差 $K$ （可以想下为啥，其实标号相当于我们把整棵树分成了一层一层的），而直径上只存在这么一个点（也是因为 $K$ 超过了直径长度的一半），所以我们就找出了对应的路径。

时间复杂度为 $\mathcal{O}(n)$ 。

**拓展：** 想想这题怎么检查你的答案对不对？

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    us = []
    vs = []
    path = [[] for _ in range(n)]
    
    for _ in range(n - 1):
        u, v = MII()
        us.append(u)
        vs.append(v)
        path[u].append(v)
        path[v].append(u)
    
    def dis(start):
        ans = [-1] * n
        ans[start] = 0
        
        que = [start]
        for u in que:
            for v in path[u]:
                if ans[v] == -1:
                    ans[v] = ans[u] + 1
                    que.append(v)
        
        return ans
    
    d = dis(0)
    diameter_u = d.index(max(d))
    d1 = dis(diameter_u)
    diameter_v = d1.index(max(d1))
    d2 = dis(d1.index(max(d1)))
    
    ans = n
    chosen = -1
    
    for i in range(n):
        if len(path[i]) == 1:
            v = fmax(d1[i], d2[i])
            if v < ans:
                ans = v
                chosen = i
    
    outs = []
    outs.append(str(ans))
    
    cur = [diameter_v]
    while cur[-1] != diameter_u:
        for v in path[cur[-1]]:
            if d1[cur[-1]] - d1[v] == 1:
                cur.append(v)
                break
    
    k = len(cur)
    
    notes = [-1] * n
    idx = cur[k // 2]
    notes[idx] = k // 2
    
    parent = [-1] * n
    
    que = [idx]
    
    for u in que:
        for v in path[u]:
            if notes[v] == -1:
                if d1[v] >= d2[v]: notes[v] = notes[u] - 1
                else: notes[v] = notes[u] + 1
                parent[v] = u
                que.append(v)
    
    find_leaf = list(range(n))
    
    for u in reversed(que):
        if parent[u] != -1:
            find_leaf[parent[u]] = find_leaf[u]
    
    for i in range(n - 1):
        u, v = us[i], vs[i]
        if notes[u] > notes[v]:
            u, v = v, u
        
        leaf = find_leaf[u] if d1[u] >= d2[u] else find_leaf[v]
        end = cur[notes[leaf] - ans] if notes[leaf] >= ans else cur[notes[leaf] + ans]
        outs.append(f'{notes[u] % ans} {leaf} {end}')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<pair<int, int>> edges(n - 1);
	vector<vector<int>> path(n);

	for (auto &[u, v]: edges) {
		cin >> u >> v;
		path[u].emplace_back(v);
		path[v].emplace_back(u);
	}

	auto dis = [&] (int start) -> vector<int> {
		vector<int> ans(n, -1);
		ans[start] = 0;

		queue<int> q;
		q.push(start);

		while (!q.empty()) {
			auto u = q.front(); q.pop();
			for (auto &v: path[u]) {
				if (ans[v] == -1) {
					ans[v] = ans[u] + 1;
					q.push(v);
				}
			}
		}

		return ans;
	};

	auto d = dis(0);
	int diameter_u = max_element(d.begin(), d.end()) - d.begin();
	auto d1 = dis(diameter_u);
	int diameter_v = max_element(d1.begin(), d1.end()) - d1.begin();
	auto d2 = dis(diameter_v);

	int ans = n, chosen = -1;

	for (int i = 0; i < n; i ++) {
		if (path[i].size() == 1) {
			int v = max(d1[i], d2[i]);
			if (v < ans) {
				ans = v;
				chosen = i;
			}
		}
	}

	vector<int> cur = {diameter_v};

	while (cur.back() != diameter_u) {
		for (auto &v: path[cur.back()]) {
			if (d1[cur.back()] - d1[v] == 1) {
				cur.emplace_back(v);
				break;
			}
		}
	}

	int k = cur.size();
	vector<int> notes(n, -1), find_leaf(n);
	int idx = cur[k / 2];
	notes[idx] = k / 2;

	iota(find_leaf.begin(), find_leaf.end(), 0);

	auto dfs = [&] (auto &self, int u, int p) -> void {
		for (auto &v: path[u]) {
			if (v != p) {
				notes[v] = notes[u] + (d1[v] >= d2[v] ? -1 : 1);
				self(self, v, u);
				find_leaf[u] = find_leaf[v];
			}
		}
	};

	dfs(dfs, idx, -1);

	cout << ans << '\n';
	for (auto &[u, v]: edges) {
		if (notes[u] > notes[v]) swap(u, v);

		int leaf = (d1[u] >= d2[u] ? find_leaf[u] : find_leaf[v]);
		int other_end = (notes[leaf] >= ans ? cur[notes[leaf] - ans] : cur[notes[leaf] + ans]);
		cout << notes[u] % ans << ' ' << leaf << ' ' << other_end << '\n';
	}

	return 0;
}
```