**提示 1：** 数字增大，位数显然不减。

**提示 2：** 如何统计一段数的数码数和？

首先，数字增大，数字位数不减，所以我们不断向右移动左端点，相当于删去左侧的数加上右侧的数，也就保证了整体位数是增多的。

于是满足单调性，可以使用二分。

接下来唯一的问题就是求一个区间 $[l, r]$ 内的数位和，而用经典套路，求 $[1,r]$ 的结果减去 $[1,l-1]$ 的结果即可。

而接下来我们只需分类讨论每个数位长度有多少个数落入区间中。有 $k$ 个数位的数的范围是 $[10^{k-1},10^k-1]$ ，我们只需求区间交长度即可，这是很容易的。

当然如果你想的话也可以不转化为两个前缀和相减，直接求区间交长度即可。

$[l_1,r_1],[l_2,r_2]$ 的交是 $[\max(l_1,l_2),\min(r_1,r_2)]$ ，如果左端点大于右端点则是空。

时间复杂度为 $\mathcal{O}(\log^2M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    us = []
    vs = []
    path = [[] for _ in range(n)]
    
    for _ in range(n - 1):
        u, v = MII()
        us.append(u)
        vs.append(v)
        path[u].append(v)
        path[v].append(u)
    
    def dis(start):
        ans = [-1] * n
        ans[start] = 0
        
        que = [start]
        for u in que:
            for v in path[u]:
                if ans[v] == -1:
                    ans[v] = ans[u] + 1
                    que.append(v)
        
        return ans
    
    d = dis(0)
    diameter_u = d.index(max(d))
    d1 = dis(diameter_u)
    diameter_v = d1.index(max(d1))
    d2 = dis(d1.index(max(d1)))
    
    ans = n
    chosen = -1
    
    for i in range(n):
        if len(path[i]) == 1:
            v = fmax(d1[i], d2[i])
            if v < ans:
                ans = v
                chosen = i
    
    outs = []
    outs.append(str(ans))
    
    cur = [diameter_v]
    while cur[-1] != diameter_u:
        for v in path[cur[-1]]:
            if d1[cur[-1]] - d1[v] == 1:
                cur.append(v)
                break
    
    k = len(cur)
    
    notes = [-1] * n
    idx = cur[k // 2]
    notes[idx] = k // 2
    
    parent = [-1] * n
    
    que = [idx]
    
    for u in que:
        for v in path[u]:
            if notes[v] == -1:
                if d1[v] >= d2[v]: notes[v] = notes[u] - 1
                else: notes[v] = notes[u] + 1
                parent[v] = u
                que.append(v)
    
    find_leaf = list(range(n))
    
    for u in reversed(que):
        if parent[u] != -1:
            find_leaf[parent[u]] = find_leaf[u]
    
    for i in range(n - 1):
        u, v = us[i], vs[i]
        if notes[u] > notes[v]:
            u, v = v, u
        
        leaf = find_leaf[u] if d1[u] >= d2[u] else find_leaf[v]
        end = cur[notes[leaf] - ans] if notes[leaf] >= ans else cur[notes[leaf] + ans]
        outs.append(f'{notes[u] % ans} {leaf} {end}')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<pair<int, int>> edges(n - 1);
	vector<vector<int>> path(n);

	for (auto &[u, v]: edges) {
		cin >> u >> v;
		path[u].emplace_back(v);
		path[v].emplace_back(u);
	}

	auto dis = [&] (int start) -> vector<int> {
		vector<int> ans(n, -1);
		ans[start] = 0;

		queue<int> q;
		q.push(start);

		while (!q.empty()) {
			auto u = q.front(); q.pop();
			for (auto &v: path[u]) {
				if (ans[v] == -1) {
					ans[v] = ans[u] + 1;
					q.push(v);
				}
			}
		}

		return ans;
	};

	auto d = dis(0);
	int diameter_u = max_element(d.begin(), d.end()) - d.begin();
	auto d1 = dis(diameter_u);
	int diameter_v = max_element(d1.begin(), d1.end()) - d1.begin();
	auto d2 = dis(diameter_v);

	int ans = n, chosen = -1;

	for (int i = 0; i < n; i ++) {
		if (path[i].size() == 1) {
			int v = max(d1[i], d2[i]);
			if (v < ans) {
				ans = v;
				chosen = i;
			}
		}
	}

	vector<int> cur = {diameter_v};

	while (cur.back() != diameter_u) {
		for (auto &v: path[cur.back()]) {
			if (d1[cur.back()] - d1[v] == 1) {
				cur.emplace_back(v);
				break;
			}
		}
	}

	int k = cur.size();
	vector<int> notes(n, -1), find_leaf(n);
	int idx = cur[k / 2];
	notes[idx] = k / 2;

	iota(find_leaf.begin(), find_leaf.end(), 0);

	auto dfs = [&] (auto &self, int u, int p) -> void {
		for (auto &v: path[u]) {
			if (v != p) {
				notes[v] = notes[u] + (d1[v] >= d2[v] ? -1 : 1);
				self(self, v, u);
				find_leaf[u] = find_leaf[v];
			}
		}
	};

	dfs(dfs, idx, -1);

	cout << ans << '\n';
	for (auto &[u, v]: edges) {
		if (notes[u] > notes[v]) swap(u, v);

		int leaf = (d1[u] >= d2[u] ? find_leaf[u] : find_leaf[v]);
		int other_end = (notes[leaf] >= ans ? cur[notes[leaf] - ans] : cur[notes[leaf] + ans]);
		cout << notes[u] % ans << ' ' << leaf << ' ' << other_end << '\n';
	}

	return 0;
}
```