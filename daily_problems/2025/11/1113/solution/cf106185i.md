**提示 1：** 每个数字只有两个位置的情况下如何求答案？

**提示 2：** 其他情况可以转化为上述情况吗？

首先，考虑每个数字只有两个位置的情况。此时考虑用线把相等数字两两连起来。

我们最终状态需要所有线之间两两有交点。而每次交换相邻两个人的位置只能新增一个交点，所以答案是 $C_n^2-现有交点数$ 。

当然，这里的交点不考虑位置的重叠

圆上画线段，求线段交点数是个很典型的问题，可以用树状数组解决，因为这相当于求 $l_i\lt l_j\lt r_i\lt r_j$ 的 $(i,j)$ 对个数。我们按照左端点大小顺序遍历所有区间，每次查询的就是此前区间的 $r$ 在 $[l_j,r_j]$ 之间的个数，这就很容易维护了。

那么如果某个数字出现的次数多于 $2$ 次呢？我们之前说了，当前交点数越多越能降低最后总次数。什么时候交点数最多呢？假设有 $2k$ 个位置，则 $(1,k+1),(2,k+2),\dots,(k,2k)$ 配对就是最好的了。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    outs = []
    
    while True:
        n = II()
        if n == 0:
            break
        nums = LII()
        
        pos = [[] for _ in range(n + 1)]
        
        for i in range(2 * n):
            pos[nums[i]].append(i)
        
        to_pos = [-1] * (2 * n)
        
        for i in range(n + 1):
            k = len(pos[i]) // 2
            for j in range(k):
                to_pos[pos[i][j]] = pos[i][j + k]
        
        fen = FenwickTree(2 * n)
        
        ans = n * (n - 1) // 2
        
        for i in range(2 * n):
            if to_pos[i] >= 0:
                ans -= fen.rsum(i, to_pos[i])
                fen.add(to_pos[i], 1)
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	while (true) {
		int n;
		cin >> n;
		if (!n) break;

		vector<int> nums(2 * n);
		vector<vector<int>> pos(n + 1);

		for (int i = 0; i < 2 * n; i ++) {
			cin >> nums[i];
			pos[nums[i]].emplace_back(i);
		}

		vector<int> target(2 * n, -1);
		for (int i = 0; i <= n; i ++) {
			int k = pos[i].size() / 2;
			for (int j = 0; j < k; j ++) {
				target[pos[i][j]] = pos[i][j + k];
			}
		}

		atcoder::fenwick_tree<int> fen(2 * n);
		long long ans = 1ll * n * (n - 1) / 2;

		for (int i = 0; i < 2 * n; i ++) {
			if (target[i] != -1) {
				ans -= fen.sum(i, target[i]);
				fen.add(target[i], 1);
			}
		}

		cout << ans << '\n';
	}

	return 0;
}
```