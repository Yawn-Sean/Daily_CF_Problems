**提示 1：** 有些数我们一定不会选。

**提示 2：** 剩余可选的数要满足什么条件？

对于一个子数组内的数，我们应该选哪些呢？

首先，考虑 $k$ 的二进制位，一旦有一位 $k$ 是 $1$ 但选出来的数在那一位不是 $1$ ，这个数一定不能选。所以备选的数一定是和 $k$ 与和等于 $k$ 的那些数。

而区间内满足这个条件的数应该应选尽选，这样才能尽量清空其他的位。

所以我们相当于要求数组中和 $k$ 与和等于 $k$ 的那些数的与运算结果是否是 $k$ 。区间查询可以直接使用线段树，而那些永远不会被选到的可以用所有二进制位都为 $1$ 的数进行替代，用来表达这个数毫无作用。

时间复杂度为 $\mathcal{O}(n+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k, q = MII()
    nums = LII()
    
    tmp = [-1] * n
    
    for i in range(n):
        if nums[i] & k == k:
            tmp[i] = nums[i] - k
    
    seg = SegTree(iand, -1, tmp)
    
    outs = []
    for _ in range(q):
        l, r = GMI()
        outs.append('NO' if seg.prod(l, r + 1) else 'YES')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int op(int x, int y) {return x & y;}
int e() {return -1;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k, q;
	cin >> n >> k >> q;

	vector<int> nums(n);
	for (auto &x: nums) {
		cin >> x;
		if ((x & k) == k) x -= k;
		else x = -1;
	}

	atcoder::segtree<int, op, e> seg(nums);

	while (q --) {
		int l, r;
		cin >> l >> r;
		cout << (seg.prod(l - 1, r) ? "NO" : "YES") << '\n';
	}

	return 0;
}
```