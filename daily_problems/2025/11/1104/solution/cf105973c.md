**提示 1：** 可以交换异或的顺序。

**提示 2：** 有很多是重复出现的会抵消。

实际上求的东西是 $C_a^b$ 的异或和，其中 $a$ 不超过 $n$ ， $b$ 不小于 $1$ 。

所以，根据 $C_a^b=C_a^{a-b}$ ，对称的两个数相等，异或后就消去了。

于是，对于每个组合数的底数而言，底数 $n$ 是偶数的情况下 $C_n^k$ 留下了 $C_n^{n/2}$ 和 $C_n^n$ ， $n$ 是奇数的情况下 $C_n^k$ 留下了 $C_n^n$ 。

于是根据这个结果进行预处理即可。时间复杂度为 $\mathcal{O}(N)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    mod = 998244353
    
    M = 10 ** 6
    f = Factorial(M, mod)
    
    acc = [0] * (M + 1)
    for i in range(1, M + 1):
        acc[i] = acc[i - 1] ^ 1 ^ (0 if i % 2 else f.combi(i, i // 2))
    
    t = II()
    outs = []
    
    for _ in range(t):
        outs.append(acc[II()])
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e6, mod = 998244353;

	vector<int> f(M + 1, 1);
	for (int i = 1; i <= M; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;

	vector<int> g(M + 1);
	g[M] = quickPow(f[M], mod - 2, mod);

	for (int i = M; i >= 1; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	auto comb = [&] (int x, int y) -> int {
		return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
	};

	vector<int> ans(M + 1, 0);

	for (int i = 1; i <= M; i ++) {
		ans[i] = ans[i - 1] ^ 1;
		if (i % 2 == 0) ans[i] ^= comb(i, i / 2);
	}

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;
		cout << ans[n] << '\n';
	}

	return 0;
}
```