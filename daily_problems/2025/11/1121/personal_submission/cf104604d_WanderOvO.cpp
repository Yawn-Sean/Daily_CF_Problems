/*
我们不妨设 a <= b
为了让 a 的某两个因子加起来 = b，则 b <= 2a 是一个必要条件，否则不可能凑出来
而当 a = b 时，如果是偶数，则直接取 a / 2 即可
如果是奇数，则说明 a 不能被 2 整除，所以 a 第二小的因子一定 > 2
所以 a 第二大的因子一定 < a / 2
两个 < a / 2 的数加起来一定 < a，所以我们必须选至少一个 >= a / 2 的因子
但是 >= a / 2 的因子只有 a，所以 a 为奇数且 a = b 的时候无解

下面就是考虑 a < b <= 2 * a 的情况了
在这个限制下，我们先考虑用 a 的因数拼凑 b
a 如果是奇数，则 b 只能是偶数，同样的，b 如果是奇数则其两个因子相加也只能得到偶数，所以 a 也得是偶数
所以 a b 都是奇数时一定是无解的
我们重新审视 a < b <= 2 * a
a 的因数可能有 a, a / 2, a / 3 ... 1
在 a < b <= 2 * a 时，要想让 a 的因数拼出来 b
你至少应该选一个 a，然后检查 b - a 是否也是 a 的因数
否则，你选了两个 <= a / 2 的数，加起来不超过 a
对于 b 来说，b / 2 <= a 一定成立，那么 b / 4 <= a / 2
所以我们不能选两个 <= b / 4 的因数
所以必然会选 b / 4, b / 3, b / 2, 这几个中的一个
所以我们直接检查这几个是否可行即可
*/

LL a, b;

void solve() {   
    cin >> a >> b;
    if (a > b) {
        swap(a, b);
    }
    
    if (a == b) {
        if (a % 2 == 0) {
            cout << "SI\n";
        } else {
            cout << "NO\n";
        }
    } else {
        LL t = b - a;
        if (a % (b - a) != 0) {
            cout << "NO\n";
            return;
        }
        
        if (b % 2 == 0) {
            t = a - b / 2;
            if (t > 0 && b % t == 0) {
                cout << "SI\n";
                return;
            }
        }
        
        if (b % 3 == 0) {
            t = a - b / 3;
            if (t > 0 && b % t == 0) {
                cout << "SI\n";
                return;
            }
        }
        
        if (b % 4 == 0) {
            t = a - b / 4;
            if (t > 0 && b % t == 0) {
                cout << "SI\n";
                return;
            }
        }
        
        cout << "NO\n";
    }
}
