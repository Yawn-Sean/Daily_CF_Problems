'''
https://codeforces.com/gym/104604/submission/350044019
'''
# 基础数论

# 解（证明）：
# （一）当 a == b 时，当a和b为偶数时，答案为是，否则为否。
#   （这个证明比较简单，首先偶数时拆开一半一半就行了，奇数时，a必定拆成一个奇数和一个偶数，显然偶数不可能是奇数b的因子。证毕）
# 下面不妨设 a < b
# （二）因为b要能拆成两个a的因子，所以b最大只能是2*a即 b > 2 * a 时答案为否
# （三）b == 2 * a时，b可以拆成a + a，所以只需看a能否拆成两个b的因子
#   当 a 为偶数时，显然 a/2 是 b 的因子，所以答案为是
#   当 a 为奇数时且为3的倍数时，设 a = 3 * k，则 b = 6 * k，此时 a 可以拆成 2 * k + k，且 2 * k 和 k 都是 b 的因子，所以答案为是
#   否则答案为否（证明也比较简单，a为奇数时，最大因子为a/3，而a只能拆成u+2v,u和v至少有一个大于a/3），
# (四) 接下来考虑剩下的一般情况，即 a < b < 2 * a
# (1) 先看 b = x + y，且x, y为a的因子的情况，此时x, y必定至少一个为a
#   （这个证明也简单，因为比a更小的 a 的因子只能是a/2或者更小，这样一来 x + y <= a，与 b > a 矛盾）
# 所以设 b = a + r，只需验证 r 为 a 的因子，否则为否
# (2) 接下来求 a = u + v，且 u, v 为 b 的因子的情况
# 当 r 为 a 的因子时，设 a = m*r，则 b = (m+1)*r，我们先把r给约掉，问题变成拆解a = m，满足 b = m + 1 的问题
# (2.1) 当 b 为奇数时，设 b = 2 * k + 1，则 a = 2 * k，
# 此时 a 必定拆成 k + k，不然必定有一个拆出来大于等于 k + 1，不可能是 b 的因子
# 但是 b 是奇数，小于b的因子最大也只能是 b / 3, 所以有 k <= b / 3，
# 即 3 * k <= 2 * k + 1，解得 k <= 1，即只有 (2, 3) 一组解
# (2.2) 当 b 为偶数时，设 b = 2 * k, 则 a = 2 * k - 1
# a 只能 拆成 (k - 1) + k，不然的话，拆出来的两个数必定有一个大于等于 k + 1，不可能是 b = 2 * k 的因子
# 讨论拆成 (k - 1) 和 k 的情况，注意到这两个数必定互质，又都是 b 的因子, 所以有 (k - 1) * k 整除 2 * k
# 以上条件在k > 3时无解，所以只有(3, 4) 和 (5, 6) 这几组解; (1, 2)的情况已经在前面讨论中被覆盖
def solve(a: int, b: int) -> bool:
    if a == b:
        return a & 1 == 0
    if a > b:
        a, b = b, a
    if b == a << 1:
        return a % 2 == 0 or a % 3 == 0
    r = b - a
    if a % r != 0:
        return False
    a, b = a // r, b // r
    return b == 3 or b == 4 or b == 6
