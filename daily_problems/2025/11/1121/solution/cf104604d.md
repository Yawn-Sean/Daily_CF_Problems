**提示 1：** 实际上两个因子的和没办法很大，所以两个数差不多大。

**提示 2：** 用 $n/x$ 表示因子，较大的因子不能很小。

取一个数的两个因子，最大只能是两个它自己，所以大的数不能超过小的数的两倍。

我们不妨设给出的两个数 $a\leq b$ 。

怎么让 $a$ 选出来的两个因子和不小于 $b$ 呢？

一种方式是直接一个因子选择 $a$ ，这种情况下只需检查 $b-a$ 是否也是 $a$ 的因子。

另一种方式就是两个都取小于 $a$ 的因子，这种情况下，两个因子最大都不超过 $a/2$ ，所以和不超过 $a$ ，唯一的取等方式就是 $a$ 是偶数且取的两个因子都是 $a/2$ ，此时 $a=b$ 。如果 $a=b$ 的话也只有这种可能了，下面不进行讨论。

而怎么让 $b$ 选取的两个因子和至少为 $a$ 呢？

这里你需要记得， $a$ 至少是 $b/2$ ，这是第一段告诉我们的。

所以如果选取的 $b$ 的因子的最大值严格小于 $b/4$ ，则两个因子的和严格小于 $b/2$ ，就一定小于 $a$ 了，产生矛盾。

所以选取的那个较大的因子只可能是 $b/2,b/3,b/4$ 之一，枚举它，并看 $a$ 减去这个数是否也是 $b$ 的因子即可。

上述只有常数次检查，因此时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        a, b = MII()
        
        if a > b: a, b = b, a
        
        if b > 2 * a: outs.append('NO')
        elif a == b:
            if a % 2 == 0: outs.append('SI')
            else: outs.append('NO')
        else:
            if a % (b - a): outs.append('NO')
            else:
                flg = False
                for i in range(2, 5):
                    if b % i == 0:
                        x = a - b // i
                        if x > 0 and b % x == 0:
                            flg = True
                outs.append('SI' if flg else 'NO')
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		long long a, b;
		cin >> a >> b;

		if (a > b) swap(a, b);
		
		if (2 * a < b) cout << "NO\n";
		else if (a == b) {
			if (a & 1) cout << "NO\n";
			else cout << "SI\n";
		}
		else {
			if (a % (b - a)) cout << "NO\n";
			else {
				bool flg = false;

				for (int i = 2; i <= 4; i ++) {
					if (b % i == 0) {
						long long x = a - b / i;
						if (x > 0 && b % x == 0) {
							flg = true;
						}
					}
				}

				cout << (flg ? "SI" : "NO") << '\n';
			}
		}
	}

	return 0;
}
```