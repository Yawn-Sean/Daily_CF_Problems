**提示 1：** 当你有了前 $i$ 项时，第 $i+1$ 项有办法吗？

**提示 2：** $N$ 变大的话，对新项的限制会变大。

先回答提示 1 的问题，我们直接填入前 $i$ 项的均值一定成立。

还有其他合法的吗？因为到这一项位置的和需要是 $i+1$ 的倍数，所以一定只能是这个数加或者减若干倍的 $i+1$ 。

而如果 $i$ 已经超过 $K$ 了，则只有一种填法。所以，不妨将 $N$ 重新赋值为 $\min(N,K)$ ，结果是不变的（因为后面的数都只能是前面全体的均值）。

接下来考虑计数。到第 $i$ 个位置为止的状态是均值为 $1,2,\dots,k$ ，因为均值一定在最小值和最大值之间，所以设到第 $i$ 个位置均值是 $j$ 的方案数是 $dp[i][j]$ 。

考虑状态转移，从长度为 $i$ 均值为 $j$ 的状态转移到长度为 $i+1$ 均值为 $j'$ 的状态，则 $ij+V=(i+1)j'$ ，我们可以看 $ij+V$ 的取值范围，进而得到 $j'$ 的取值范围，一定是个区间，所以可以用差分更新。

当然，这里直接进行暴力转移不用差分更新的话，复杂度是 $\mathcal{O}(K^2\log K)$ ，来源于调和级数。

因此时间复杂度为 $\mathcal{O}(K^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k = MII()
    mod = 998244353
    
    n = fmin(n, k)
    
    dp = [0] * (k + 1)
    dp[0] = 1
    
    for i in range(1, n + 1):
        ndp = [0] * (k + 1)
        
        for j in range(k + 1):
            start = j * (i - 1) + 1
            end = j * (i - 1) + k
            
            left = (start + i - 1) // i
            right = end // i
            
            ndp[left] += dp[j]
            if right < k:
                ndp[right + 1] -= dp[j]
        
        for j in range(1, k + 1):
            ndp[j] += ndp[j - 1]
            ndp[j] %= mod
        
        dp = ndp
    
    print(sum(dp) % mod)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k, mod = 998244353;
	cin >> n >> k;

	n = min(n, k);

	auto add = [&] (int &x, int y) -> void {
		x += y;
		if (x >= mod) x -= mod;
	};

	auto minus = [&] (int &x, int y) -> void {
		x -= y;
		if (x < 0) x += mod;
	};

	vector<int> dp(k + 1, 0);
	dp[0] = 1;

	for (int i = 1; i <= n; i ++) {
		vector<int> ndp(k + 1, 0);

		for (int j = 0; j <= k; j ++) {
			int start = j * (i - 1) + 1;
			int ending = j * (i - 1) + k;

			int left = (start + i - 1) / i;
			int right = ending / i;

			add(ndp[left], dp[j]);
			if (right < k) minus(ndp[right + 1], dp[j]);
		}

		for (int j = 1; j <= k; j ++)
			add(ndp[j], ndp[j - 1]);
	
		dp.swap(ndp);
	}

	int ans = 0;
	for (auto &x: dp) add(ans, x);
	cout << ans;

	return 0;
}
```