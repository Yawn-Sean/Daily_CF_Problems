**提示 1：** 如何计算满足条件的子串的个数？

**提示 2：** 需要维护哪些信息？

先考虑一个简单的问题：如何快速计数满足条件的子串的个数？

发现我们可以使用前缀和，前缀和 $\bmod 3$ 同余的位置之间满足要求。

假设前缀和 $\bmod 3$ 结果是 $0,1,2$ 的位置各有 $v_1,v_2,v_3$ 个，则满足条件的子串的个数是 $\frac{v_1(v_1-1)+v_2(v_2-1)+v_3(v_3-1)}{2}$ 。发现我们并不在意 $v_1,v_2,v_3$ 的具体数值，只在乎它们 $\bmod 3$ 结果是多少。

所以把这三者作为状态，加上从开头到当前位为止的前缀和的 $\bmod 3$ 的结果，就构成了所需的状态。此时再枚举新的一位的 $\bmod 3$ 情况就可以进行状态转移了。

时间复杂度为 $\mathcal{O}(n)$ 。

**思考：** 前缀和 $\bmod 3$ 的状态是可以删去的，怎么做呢？

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    mod = 10 ** 9 + 7
    
    outs = []
    
    def f(i, j, k, cur_mod):
        return ((i * 3 + j) * 3 + k) * 3 + cur_mod
    
    method = [4, 3, 3]
    
    for _ in range(t):
        n = II()
        dp = [0] * 81
        
        for i in range(1, 10):
            x, y, z = 1, 0, 0
            
            if i % 3 == 0: x += 1
            elif i % 3 == 1: y += 1
            else: z += 1
            
            dp[f(x, y, z, i % 3)] += 1
    
        for _ in range(n - 1):
            ndp = [0] * 81
            
            for x in range(3):
                for y in range(3):
                    for z in range(3):
                        for cur_mod in range(3):
                            if dp[f(x, y, z, cur_mod)]:
                                nstatus = [x, y, z]
                                
                                for choice in range(3):
                                    ncur_mod = (cur_mod + choice) % 3
                                    
                                    nstatus[ncur_mod] += 1
                                    nstatus[ncur_mod] %= 3
                                    
                                    nx, ny, nz = nstatus
                                    ndp[f(nx, ny, nz, ncur_mod)] += dp[f(x, y, z, cur_mod)] * method[choice]
                                    ndp[f(nx, ny, nz, ncur_mod)] %= mod
                                    
                                    nstatus[ncur_mod] -= 1
                                    nstatus[ncur_mod] %= 3
            
            dp = ndp
        
        ans = 0
        
        for x in range(3):
            for y in range(3):
                for z in range(3):
                    if (x * (x - 1) // 2 + y * (y - 1) // 2 + z * (z - 1) // 2) % 3 == 0:
                        for cur_mod in range(3):
                            ans += dp[f(x, y, z, cur_mod)]
                            ans %= mod
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int dp[3][3][3][3], ndp[3][3][3][3], mod = 1e9 + 7;

void add(int &x, int y) {
	x += y;
	if (x >= mod) x -= mod;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	vector<int> method = {4, 3, 3};

	while (t --) {
		int n;
		cin >> n;

		for (int i = 1; i < 10; i ++) {
			vector<int> cur = {1, 0, 0};
			cur[i % 3] ++;
			dp[cur[0]][cur[1]][cur[2]][i % 3] ++;
		}

		for (int i = 1; i < n; i ++) {
			for (int x = 0; x < 3; x ++) {
				for (int y = 0; y < 3; y ++) {
					for (int z = 0; z < 3; z ++) {
						for (int cur_mod = 0; cur_mod < 3; cur_mod ++) {
							if (dp[x][y][z][cur_mod]) {
								vector<int> nstatus = {x, y, z};
								for (int choice = 0; choice < 3; choice ++) {
									int ncur_mod = (cur_mod + choice) % 3;
									nstatus[ncur_mod] = (nstatus[ncur_mod] + 1) % 3;
									add(ndp[nstatus[0]][nstatus[1]][nstatus[2]][ncur_mod], 1ll * dp[x][y][z][cur_mod] * method[choice] % mod);
									nstatus[ncur_mod] = (nstatus[ncur_mod] + 2) % 3;
								}
							}
						}
					}
				}
			}
			for (int x = 0; x < 3; x ++) {
				for (int y = 0; y < 3; y ++) {
					for (int z = 0; z < 3; z ++) {
						for (int v = 0; v < 3; v ++) {
							dp[x][y][z][v] = ndp[x][y][z][v];
							ndp[x][y][z][v] = 0;
						}
					}
				}
			}
		}

		int ans = 0;
		for (int x = 0; x < 3; x ++) {
			for (int y = 0; y < 3; y ++) {
				for (int z = 0; z < 3; z ++) {
					for (int v = 0; v < 3; v ++) {
						if ((x * (x - 1) / 2 + y * (y - 1) / 2 + z * (z - 1) / 2) % 3 == 0) add(ans, dp[x][y][z][v]);
						dp[x][y][z][v] = 0;
					}
				}
			}
		}

		cout << ans << '\n';
	}

	return 0;
}
```