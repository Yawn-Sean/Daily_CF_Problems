**提示 1：** 把两个数变成更小的数。

我们先看下一个大数关于 $mod$ 取模咋做。

假设考虑了前 $k$ 位的取模结果是 $x$ ，此时第 $k+1$ 位是 $y$ ，则新的数是 $10$ 倍的前 $k$ 位加上第 $k+1$ 位，因此新结果是 $(10x+y)\bmod mod$ 。

对于加法、减法、乘法而言，我们直接两个数都取模 $10^9+7$ 就好。

对于幂次，因为 $x^{mod-1}\bmod mod=1$ ，当 $x$ 不能被 $mod$ 整除且 $mod$ 是质数的情况下，所以我们可以对幂次关于 $mod-1$ 取模。 $x$ 是 $mod$ 的倍数的情况下，输出 $0$ 即可。

时间复杂度为 $\mathcal{O}(\sum|s|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    s1, op, s2 = LI()
    
    mod1 = 10 ** 9 + 7
    mod2 = 10 ** 9 + 6
    
    v1 = 0
    for c in s1:
        v1 = (10 * v1 + int(c)) % mod1
    
    v2 = 0
    for c in s2:
        v2 = (10 * v2 + int(c)) % (mod1 if op != '^' else mod2)
    
    if op == '+': print((v1 + v2) % mod1)
    elif op == '-': print((v1 - v2) % mod1)
    elif op == '*': print(v1 * v2 % mod1)
    else: print(pow(v1, v2, mod1))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	string s1, op, s2;
	cin >> s1 >> op >> s2;

	int mod1 = 1e9 + 7, mod2 = mod1 - 1;

	int v1 = 0, v2 = 0;

	for (auto &c: s1)
		v1 = (10ll * v1 + c - '0') % mod1;

	for (auto &c: s2)
		v2 = (10ll * v2 + c - '0') % (op[0] == '^' ? mod2 : mod1);

	if (op == "+") cout << (v1 + v2) % mod1;
	else if (op == "-") cout << (v1 - v2 + mod1) % mod1;
	else if (op == "*") cout << 1ll * v1 * v2 % mod1;
	else cout << quickPow(v1, v2, mod1);

	return 0;
}
```