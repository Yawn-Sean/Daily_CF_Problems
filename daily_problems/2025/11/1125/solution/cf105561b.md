**提示 1：** 如果次数足够大，我们就只在乎底数了。

**提示 2：** 一般的数组很容易满足次数足够大。

最后产生的数一定是开局某个数的若干次方。

因为我们查询的数字是不超过 $10^6$ ，所以质因子的次数不会超过 $19$ ，因为 $2^20\gt 10^6$ ，所以固定底数的话只要使得次数不小于 $19$ ，次数就不重要了，我们只在乎底数的质因子能否包含查询的数字的质因子。

次数啥时候大不起来呢？数组比较短 / 有很多 $1$ 的时候，因为 $1$ 不断操作会毫无作用。

数组长度为 $2$ 时，数组最终只有两种情况，我们对于每次查询，看一下对应幂次是否是 $x$ 的倍数即可，可以使用快速幂检查，对于 $a^b$也可以暴力算 $a^\min(20,b)$ 。

数组长度为 $3$ 时，相对难处理一些。我们也模拟所有的操作方式看是否有满足要求的。每一轮操作我们都枚举所有排列。

比方说我们第一轮重排后的序列是 $[a,b,c]$ ，操作后会先变成 $[a^b,b^c]$ 。

此时我们要算 $(a^b)^(b^c)$ 或是 $(b^c)^(a^b)$ 。

底数和幂次都可能很大，怎么办呢？这里的底数只需考虑关于 $x$ 取模的结果，于是可以快速幂（同时幂次可以跟 $19$ 取最小值，因为更大幂次没有意义，Python 通过需要这步优化）。而幂次也只需跟 $19$ 取最小值，所以幂次一旦乘到不小于 $19$ 的数直接返回即可（当然也可能为 $1$ ，很容易判断到）。

将转换后的底数和幂次拿来进行最终结果的计算，最后结果再用一次快速幂就做完了。

数组中除了一个元素均为 $1$ 时，最终答案只可能是 $1$ 或者这个数，我们只需用这个数判是否被 $x$ 整除即可（这个数也是 $1$ 的情况是一致的）。

最后剩下的情况是，数组长度至少为 $4$ ，且至少有两个数不小于 $2$ ，我们要尝试说明对于非 $1$ 的数，我们能凑出这个数的 $19$ 以上的次方，这样，我们就不需要考虑上面的幂次了。

具体的，我们可以用 $(x,y,1,1)$ （其他的数如果不只是 $1$ ，或者数组更长，幂次的结果只会更大）来表示，则我们可以这么操作：

$(x,y,1,1)\to (x^y,y,1)\to (y,x^y,1)\to (y^{x^y},x^y)\to (x^y, y^{x^y})\to (x^{y\times y^{x^y}})$

在 $x,y$ 不小于 $2$ 时， $y\times y^{x^y}$ 已经超过 $19$ 了，因此可以构造出任何一个数组中的非 $1$ 的 $x$ 的足够高的幂次。

所以对于一个查询 $x$ ，我们只需看数组中是否存在一个数 $val$ ，满足 $val$ 的足够高次数能整除 $x$ 。

$val$ 需要满足的充要条件是 $val$ 的质因子集合严格包含 $x$ 的质因子集合。我们对于 $val$ ，可以把它所有不同的质因子提取出来乘起来，这个数一定得是原序列的某个数 $val$ 的因子。

这件事就好办了，我们只需要把原序列的所有数的因子集合找到就好。为此，我们先记录数组中有的数字，接下来枚举每个在 $1\sim 10^6$ 之间的数，枚举其不超过 $10^6$ 的倍数，如果某个倍数被记录过，则这个数就一定是某个数的因子。

这样预处理时间复杂度就是调和级数推导得到的 $\mathcal{O}(M\log M)$ 。检查的时候就看不同质因子的乘积是否在这个集合里。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    us = []
    vs = []
    ws = []
    
    for _ in range(m):
        u, v, w = MII()
        u -= 1
        v -= 1
        us.append(u)
        vs.append(v)
        ws.append(w)
    
    uf = UnionFind(n)
    st_range = sorted(range(m), key=lambda x: ws[x])
    
    path = [[] for _ in range(n)]
    chosen = [0] * m
    
    for i in st_range:
        if uf.merge(us[i], vs[i]):
            chosen[i] = 1
            path[us[i]].append(ws[i] * n + vs[i])
            path[vs[i]].append(ws[i] * n + us[i])
    
    depth = [0] * n
    to_root = [0] * n
    parent = [-1] * n
    
    que = [0]
    
    for u in que:
        for msk in path[u]:
            w, v = divmod(msk, n)
            if parent[u] != v:
                parent[v] = u
                depth[v] = depth[u] + 1
                to_root[v] = to_root[u] + w
                que.append(v)
    
    nth_parent = [[-1] * n for _ in range(20)]
    nth_parent[0] = parent
    
    for i in range(19):
        for j in range(n):
            if nth_parent[i][j] >= 0:
                nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
    def lca(u, v):
        if depth[u] > depth[v]:
            u, v = v, u
        
        d = depth[v] - depth[u]
        
        while d:
            x = d & -d
            v = nth_parent[x.bit_length() - 1][v]
            d -= x
        
        if u == v: return u
        
        for i in range(19, -1, -1):
            if nth_parent[i][u] != nth_parent[i][v]:
                u = nth_parent[i][u]
                v = nth_parent[i][v]
        
        return parent[u]
    
    for i in range(m):
        if not chosen[i]:
            u = us[i]
            v = vs[i]
            l = lca(u, v)
            
            if to_root[u] + to_root[v] - 2 * to_root[l] > ws[i]:
                exit(print('NO'))
    
    print('YES')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	if (n == 2) {

		while (q --) {
			int x;
			cin >> x;
			cout << (quickPow(nums[0], nums[1], x) == 0 || quickPow(nums[1], nums[0], x) == 0 ? "Yes" : "No") << '\n';
		}
	}
	else if (n == 3) {

		while (q --) {
			int x;
			cin >> x;

			bool flg = false;
			sort(nums.begin(), nums.end());
	
			while (true) {
				int a = nums[0];
				int b = nums[1];
				int c = nums[2];

				int va = quickPow(a, min(20, b), x);
				int vb = quickPow(b, min(20, c), x);

				int pa = 1;
				for (int i = 0; i < min(b, 5); i ++)
					pa = min(pa * a, 20);
				
				int pb = 1;
				for (int i = 0; i < min(c, 5); i ++)
					pb = min(pb * b, 20);
				
				if (quickPow(va, pb, x) == 0 || quickPow(vb, pa, x) == 0)
					flg = true;

				if (!next_permutation(nums.begin(), nums.end())) break;
			}

			cout << (flg ? "Yes" : "No") << '\n';
		}
	}
	else {
		int cnt1 = 0;
		for (auto &v: nums)
			cnt1 += v == 1;
		
		if (cnt1 >= n - 1) {
			int val = *max_element(nums.begin(), nums.end());

			while (q --) {
				int x;
				cin >> x;
				cout << (val % x == 0 ? "Yes" : "No") << '\n';
			}
		}
		else {
			int M = 1e6;
			vector<int> prime_factor(M + 1);
			iota(prime_factor.begin(), prime_factor.end(), 0);

			for (int i = 2; i <= M; i ++) {
				if (prime_factor[i] == i) {
					for (int j = i; j <= M; j += i) {
						prime_factor[j] = i;
					}
				}
			}

			vector<int> notes(M + 1, 0);

			for (auto &x: nums) notes[x] = 1;

			for (int i = 1; i <= M; i ++) {
				for (int j = i; j <= M; j += i) {
					notes[i] |= notes[j];
				}
			}

			for (int i = 1; i <= M; i ++) {
				int cur = i, val = 1;
				while (cur > 1) {
					int p = prime_factor[cur];
					val *= p;
					while (cur % p == 0) cur /= p;
				}

				if (notes[val]) notes[i] = 1;
			}

			while (q --) {
				int x;
				cin >> x;
				cout << (notes[x] ? "Yes" : "No") << '\n';
			}
		}
	}

	return 0;
}
```