**提示 1：** 我们选择哪棵树？为什么？

**提示 2：** 怎么检查这棵树是否符合要求？

我们要找一棵树，感觉上需要使得这棵树上边的权值比较小。所以可以想到最小生成树这件事。

那么，为什么应该选择最小生成树呢？

如果我们选择的不是最小生成树，则我们可以替代至少一条边，假设从 $(u,v,w)$ 变成 $(u',v',w')$ ，使得总边权严格变小，即 $w\gt w'$ 。

则 $(u',v')$ 在删去 $(u,v,w)$ 边时不连通（否则删去 $(u,v,w)$ 后，新增的 $(u',v',w')$ 是不会将两个不连通的分量相连的，也就不会产生生成树）。所以在原图中 $u',v'$ 距离严格不小于 $w$ ，因此严格大于 $w'$ 。

而在原图中， $u',v'$ 之间的距离不超过 $w'$ ，所以非最小生成树的生成树在 $(u',v')$ 的距离上一定不满足要求。

所以最多只有最小生成树可能是我们最终所求的那棵树。

那我们需要检查什么条件呢？

考虑一下不在最小生成树上的边 $(u,v,w)$ ，则 $u,v$ 之间的最短路长度不超过 $w$ ，而如果最小生成树符合要求，则在树上的距离等于最短路长度，因此也一定不能超过 $w$ 。

那么检查这些条件够吗？答案是肯定的。因为在这些条件满足的情况下，我们最短路一定可以不经过哪些不在最小生成树上的边，因为可以将其替代为树上的路径而长度不增加。

所以我们只需在最小生成树上，求剩余边 $(u,v,w)$ 对应的 $u,v$ 间距离，检查其是否不超过 $w$ 。如果都不超过，则这棵最小生成树符合要求；否则永远无法满足要求。

时间复杂度为 $\mathcal{O}(m(\log n+\log m))$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    us = []
    vs = []
    ws = []
    
    for _ in range(m):
        u, v, w = MII()
        u -= 1
        v -= 1
        us.append(u)
        vs.append(v)
        ws.append(w)
    
    uf = UnionFind(n)
    st_range = sorted(range(m), key=lambda x: ws[x])
    
    path = [[] for _ in range(n)]
    chosen = [0] * m
    
    for i in st_range:
        if uf.merge(us[i], vs[i]):
            chosen[i] = 1
            path[us[i]].append(ws[i] * n + vs[i])
            path[vs[i]].append(ws[i] * n + us[i])
    
    depth = [0] * n
    to_root = [0] * n
    parent = [-1] * n
    
    que = [0]
    
    for u in que:
        for msk in path[u]:
            w, v = divmod(msk, n)
            if parent[u] != v:
                parent[v] = u
                depth[v] = depth[u] + 1
                to_root[v] = to_root[u] + w
                que.append(v)
    
    nth_parent = [[-1] * n for _ in range(20)]
    nth_parent[0] = parent
    
    for i in range(19):
        for j in range(n):
            if nth_parent[i][j] >= 0:
                nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
    def lca(u, v):
        if depth[u] > depth[v]:
            u, v = v, u
        
        d = depth[v] - depth[u]
        
        while d:
            x = d & -d
            v = nth_parent[x.bit_length() - 1][v]
            d -= x
        
        if u == v: return u
        
        for i in range(19, -1, -1):
            if nth_parent[i][u] != nth_parent[i][v]:
                u = nth_parent[i][u]
                v = nth_parent[i][v]
        
        return parent[u]
    
    for i in range(m):
        if not chosen[i]:
            u = us[i]
            v = vs[i]
            l = lca(u, v)
            
            if to_root[u] + to_root[v] - 2 * to_root[l] > ws[i]:
                exit(print('NO'))
    
    print('YES')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<array<int, 3>> edges(m);

	for (auto &[u, v, w]: edges) {
		cin >> u >> v >> w;
		u --, v --;
	}

	sort(edges.begin(), edges.end(), [&](array<int, 3> &x, array<int, 3> &y) {return x[2] < y[2];});

	atcoder::dsu uf(n);
	vector<array<int, 3>> to_check;
	vector<vector<pair<int, int>>> path(n);

	for (auto &[u, v, w]: edges) {
		if (uf.merge(u, v)) {
			path[u].emplace_back(v, w);
			path[v].emplace_back(u, w);
		}
		else to_check.push_back({u, v, w});
	}

	vector<int> depth(n, 0);
	vector<long long> to_root(n, 0);
	vector<vector<int>> nth_parent(20, vector<int>(n, -1));

	auto dfs = [&] (auto &self, int u, int p) -> void {
		for (auto &[v, w]: path[u]) {
			if (v != p) {
				depth[v] = depth[u] + 1;
				to_root[v] = to_root[u] + w;
				nth_parent[0][v] = u;
				self(self, v, u);
			}
		}
	};

	dfs(dfs, 0, -1);

	for (int i = 0; i < 19; i ++) {
		for (int j = 0; j < n; j ++) {
			if (nth_parent[i][j] >= 0) {
				nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
			}
		}
	}

	auto lca = [&] (int u, int v) -> int {
		if (depth[u] > depth[v]) swap(u, v);

		int d = depth[v] - depth[u];
		while (d) {
			int x = d & -d;
			v = nth_parent[__builtin_ctz(x)][v];
			d -= x;
		}

		if (u == v) return u;

		for (int i = 19; i >= 0; i --) {
			if (nth_parent[i][u] != nth_parent[i][v]) {
				u = nth_parent[i][u];
				v = nth_parent[i][v];
			}
		}

		return nth_parent[0][u];
	};

	for (auto &[u, v, w]: to_check) {
		int l = lca(u, v);
		if (to_root[u] + to_root[v] - 2 * to_root[l] > w)
			return cout << "NO", 0;
	}

	cout << "YES";

	return 0;
}
```