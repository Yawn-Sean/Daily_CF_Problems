**提示 1：** 只需考虑剩余元素的能否形成合法的被完全删除的序列。

**提示 2：** 如果将配对的元素染成相同的颜色，则整个逻辑类似于括号序列。

我们相当于要选取一个最长的子序列，使得其可以通过删去相邻的呈倍数关系的元素清空。

怎么做呢？考虑将子序列中配对的元素染色，则染色后的结果是一个括号序列。而括号序列在子序列问题中可以使用区间 DP 解决。

具体而言， $[l,r]$ 取子序列的结果有以下来源：

- $l, r$ 匹配，则从 $[l+1,r]$ 转移而来。

- 被拆分为左右两个部分 $[l,sep],[sep+1,r]$ ，两侧分别取了子序列。

这个区间 DP 的复杂度是三次的。最后因为要构造方案，可以记录转移方式，也可以直接根据 DP 的结果来推可以从哪里转移过来。

时间复杂度为 $\mathcal{O}(n^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    dp = [[0] * n for _ in range(n)]
    
    for diff in range(1, n):
        for l in range(n - diff):
            r = l + diff
            
            dp[l][r] = dp[l + 1][r - 1]
            if nums[l] % nums[r] == 0 or nums[r] % nums[l] == 0:
                dp[l][r] += 2
            
            for sep in range(l, r):
                dp[l][r] = fmax(dp[l][r], dp[l][sep] + dp[sep + 1][r])
    
    used = [0] * n
    
    def check(l, r):
        if l >= r: return
        
        for sep in range(l, r):
            if dp[l][r] == dp[l][sep] + dp[sep + 1][r]:
                check(l, sep)
                check(sep + 1, r)
                return 
    
        if nums[l] % nums[r] == 0 or nums[r] % nums[l] == 0:
            used[l] = 1
            used[r] = 1
        check(l + 1, r - 1)
    
    check(0, n - 1)
    
    print(n - dp[0][n - 1])
    print(*(i + 1 for i in range(n) if not used[i]))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<vector<int>> dp(n, vector<int>(n, 0));

	for (int diff = 1; diff < n; diff ++) {
		for (int l = 0; l + diff < n; l ++) {
			int r = l + diff;

			dp[l][r] = dp[l + 1][r - 1];
			if (nums[l] % nums[r] == 0 || nums[r] % nums[l] == 0)
				dp[l][r] += 2;
			
			for (int sep = l; sep < r; sep ++)
				dp[l][r] = max(dp[l][r], dp[l][sep] + dp[sep + 1][r]);
		}
	}

	vector<int> used(n, 0);

	auto check = [&] (auto &self, int l, int r) -> void {
		if (l >= r) return ;
		
		for (int sep = l; sep < r; sep ++) {
			if (dp[l][r] == dp[l][sep] + dp[sep + 1][r]) {
				self(self, l, sep);
				self(self, sep + 1, r);
				return ;
			}
		}

		if (nums[l] % nums[r] == 0 || nums[r] % nums[l] == 0) {
			used[l] = 1;
			used[r] = 1;
		}
		self(self, l + 1, r - 1);
	};

	check(check, 0, n - 1);

	cout << n - dp[0][n - 1] << '\n';
	for (int i = 0; i < n; i ++)
		if (!used[i]) cout << i + 1 << ' ';

	return 0;
}
```