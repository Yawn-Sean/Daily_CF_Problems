**提示 1：** 假设我们可以往 $(x,y)$ 的方向走，可以怎么简化这个操作？

**提示 2：** 如何综合一系列的操作？

我们先分析题目条件。

根据题意 $x^2+y^2=n=2^{2k+1}v$ ，其中 $v$ 是奇数。

$x,y$ 必然奇偶性相同，不然平方和不可能是偶数。

如果 $x,y$ 都是奇数，则平方和不是 $4$ 的倍数，所以右侧只能是 $k=0$ 。

否则，如果 $k\geq 1$ ，则 $x,y$ 只能都是偶数。如果 $x,y$ 都是偶数，则平方和是 $4$ 的倍数，所以 $k\geq 1$ ，则可以两侧都除以 $4$ ，有 $(x/2)^2+(y/2)^2=2^{2(k-1)+1}v$ ，这样同时除以 $k$ 轮 $2$ ，右侧不再是 $4$ 的倍数，变成了前面的情况， $x,y$ 会同时变成奇数。

所以不妨 $x=2^kx_0,y=2^ky_0$ ，其中 $x_0,y_0$ 都是奇数。

所有到达的点的横纵坐标都是 $2^k$ 的倍数，所以不妨直接除掉这个元素，剩余 $x_0,y_0$ 。

我们设 $g=\mathrm{gcd}(x_0,y_0)$ ，则如果我们证明 $(g,g)$ 是可到达的，这就说明可以用 $(x_0,y_0)$ 走到 $(g,g)$ ，另一方面，显然也可以用 $(g,g)$ 走到 $(x_0,y_0)$ ，所以这两种操作是等价的。

下面证明：

首先， $(2g,2g)$ 是可达的，因为 $(x_0+y_0,x_0+y_0),(x_0-y_0,x_0-y_0)$ 是可达的，所以根据裴蜀定理，可以凑出来 $k_1(x_0+y_0)+k_2(x_0-y_0)=\mathrm{gcd}(x_0+y_0,x_0-y_0)$ ，所以 $(\mathrm{gcd}(x_0+y_0,x_0-y_0),\mathrm{gcd}(x_0+y_0,x_0-y_0))$ 是可达的。而这个新位置恰好是 $(2g,2g)$ 。

而这样，我们可以用两次 $(2g,2g)$ ，做到走 $(±4g,0),(0,±4g)$ ，因此我们可以将 $(x_0,y_0)$ 走到 $(x_0\bmod 4g,y_0\bmod 4g)$ 。而因为 $x_0,y_0$ 都是奇数，同时又都是 $g$ 的倍数，所以只可能是 $(g,g),(g,3g),(3g,g),(3g,3g)$ ，而他们跟 $(2g,2g)$ 之间都恰好差别是 $(-g,-g),(-g,g),(g,-g),(g,g)$ 之一，也就是说这四个操作至少有一个是可以做到的。

而因为所有操作都可以关于 $x$ 轴或 $y$ 轴对称，因此走 $(g,g)$ 总是可以做到的。

所以我们找到了替代 $(x_0,y_0)$ 的等价操作 $(g,g)$ 。将其同时乘以 $2^k$ 不影响结论正确性。

而一系列的 $(x_i,y_i)$ 都等价成为了 $(g_i,g_i)$ ，根据裴蜀定理，这些操作又重新转化为了 $(\mathrm{gcd}(g_i),\mathrm{gcd}(g_i))$ ，所以这就是我们所有操作的基本元。不妨设这个操作是 $(G,G)$ 。

如何得到所有操作呢？两个方向的大小都不超过 $\sqrt{M}$ ，枚举一个方向即可求另一个方向。

得到操作后咋计算答案呢？我们考虑可以所有能到达的点分为两组：分别从 $(0,0),(G,G)$ 出发，横着走 $2G$ 或竖着走 $2G$ 能到达的点。

这样问题就转化为了区域内按照横平竖直排布的点的数量，只需算出两个维度分别有多少点，相乘即可。

当然有特殊情况， $G=0$ 的时候你动不了，只能待在 $0$ ，此时要特判原点在不在区域内。

时间复杂度为 $\mathcal{O}(\sqrt{M})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, xl, yl, w, h = MII()
    xr, yr = xl + w, yl + h
    xl, yl = xl - 1, yl - 1
    
    g = 0
    
    for i in range(1, 10 ** 6 + 1):
        v = n - i * i
        if v < 0: break
        w = math.isqrt(v)
        if i > w: break
        if w * w == v:
            g = math.gcd(g, i)
            g = math.gcd(g, w)
    
    ans = 0
    if g:
        ans += (xr // (2 * g) - xl // (2 * g)) * (yr // (2 * g) - yl // (2 * g))
        ans += ((xr - g) // (2 * g) - (xl - g) // (2 * g)) * ((yr - g) // (2 * g) - (yl - g) // (2 * g))
    elif xl < 0 <= xr and yl < 0 <= yr:
        ans += 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	long long n, xl, yl, xr, yr, w, h;
	cin >> n >> xl >> yl >> w >> h;

	xr = xl + w, yr = yl + h;
	xl --, yl --;

	long long g = 0;

	for (int i = 1; i <= 1'000'000; i ++) {
		long long v = n - 1ll * i * i;
		if (v < 0) break;
		long long l = 0, r = 1e9;
		while (l <= r) {
			long long mid = (l + r) / 2;
			if (mid * mid >= v) r = mid - 1;
			else l = mid + 1;
		}
		long long w = l;
		if (w * w == v) {
			g = gcd(g, i);
			g = gcd(g, w);
		}
	}

	long long ans = 0;

	if (g) {
		auto div = [&] (long long x, long long y) -> long long {
			long long res = x / y;
			if (res * y > x) res --;
			return res;
		};

		ans += (div(xr, 2 * g) - div(xl, 2 * g)) * (div(yr, 2 * g) - div(yl, 2 * g));
		ans += (div(xr - g, 2 * g) - div(xl - g, 2 * g)) * (div(yr - g, 2 * g) - div(yl - g, 2 * g));
	}
	else if (xl < 0 && xr >= 0 && yl < 0 && yr >= 0) ans ++;

	cout << ans;

	return 0;
}
```