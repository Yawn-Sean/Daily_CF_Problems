**提示 1：** 相当于一个经过变换后的匹配。可以考虑字符串算法。

**提示 2：** 怎么处理之后就是完全一致的匹配了？

考虑对数组进行差分，因为操作不改变差分数组，同时第二个数组在第一个数组的匹配位置的差分数组的数值一定跟第二个的差分数组一致。

（注意这里差分的结果需要关于 $10^4$ 取模）

所以用 KMP 或其他算法，找到匹配的位置。而是否匹配只取决于第一个元素是否相同，因此对于所有差分数组匹配的位置，可以直接比对第一个元素，看对应位置需要操作几次才能匹配上，对这个操作数进行统计。

最后对统计结果，取最大者，并得到下标即可。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def prep(p):
        pi = [0] * len(p)
        j = 0
        for i in range(1, len(p)):
            while j != 0 and p[j] != p[i]:
                j = pi[j - 1]
            if p[j] == p[i]:
                j += 1
            pi[i] = j
        return pi
    
    M = 10 ** 4
    
    n, m = MII()
    nums1 = LII()
    nums2 = LII()
    
    vals = []
    
    for i in range(1, m):
        vals.append((nums2[i] - nums2[i - 1]) % M)
    
    vals.append(-1)
    
    for i in range(1, n):
        vals.append((nums1[i] - nums1[i - 1]) % M)
    
    kmp = prep(vals)
    
    cnt = [0] * M
    
    for i in range(m, n + m - 1):
        if kmp[i] == m - 1:
            cnt[(nums2[0] - nums1[i - 2 * (m - 1)]) % M] += 1
    
    ma = max(cnt)
    print(cnt.index(ma), ma)
```

C++ 做法如下——

```cpp []
vector<int> prep(vector<int>& nums) {
	int n = nums.size();
	vector<int> pi(n, 0);
	int j = 0;

	for (int i = 1; i < n; i ++) {
		while (j && nums[i] != nums[j])
			j = pi[j - 1];
		if (nums[i] == nums[j]) j ++;
		pi[i] = j;
	}

	return pi;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e4, n, m;
	cin >> n >> m;

	vector<int> nums1(n), nums2(m);
	for (auto &x: nums1) cin >> x;
	for (auto &x: nums2) cin >> x;

	vector<int> vals;

	for (int i = 1; i < m; i ++)
		vals.emplace_back((nums2[i] - nums2[i - 1] + M) % M);
	
	vals.emplace_back(-1);

	for (int i = 1; i < n; i ++)
		vals.emplace_back((nums1[i] - nums1[i - 1] + M) % M);
	
	auto kmp = prep(vals);

	vector<int> cnt(M, 0);
	
	for (int i = m; i < n + m - 1; i ++) {
		if (kmp[i] == m - 1) {
			cnt[(nums2[0] - nums1[i - 2 * (m - 1)] + M) % M] ++;
		}
	}

	auto ma_ele = max_element(cnt.begin(), cnt.end());

	cout << ma_ele - cnt.begin() << ' ' << *ma_ele;

	return 0;
}
```