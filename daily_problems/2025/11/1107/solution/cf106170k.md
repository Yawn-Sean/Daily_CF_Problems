**提示 1：** 显然 $k$ 越大越容易满足要求。

**提示 2：** 我们需要检查的条件是什么？

显然 $k$ 越大越容易满足要求，因此考虑二分。接下来只需检查对于某个 $k$ 是否存在解即可。

我们的条件相当于是每个位置的数值有其范围，子数组和也有范围。

后者包含的变量太多了，如何减少变量呢？

考虑使用前缀和，则上述的两类不等式都变成了差分约束，这就是很容易解决的问题了，跑 Bellman-Ford 的东西就好了，最后只需检查一遍解是否符合要求。

时间复杂度为 $\mathcal{O}(n(n+m)\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    nums = LII()
    
    ls = []
    rs = []
    xs = []
    ys = []
    
    for _ in range(m):
        l, r, x, y = MII()
        ls.append(l - 1)
        rs.append(r)
        xs.append(x)
        ys.append(y)
    
    bound = 10 ** 13
    l, r = 0, bound
    sol = [0] * (n + 1)
    
    while l <= r:
        mid = (l + r) // 2
        
        for _ in range(n):
            for i in range(m):
                sol[rs[i]] = fmax(sol[rs[i]], sol[ls[i]] + xs[i])
                sol[ls[i]] = fmax(sol[ls[i]], sol[rs[i]] - ys[i])
            
            for i in range(n):
                sol[i + 1] = fmax(sol[i + 1], sol[i] + fmax(1, nums[i] - mid))
                sol[i] = fmax(sol[i], sol[i + 1] - nums[i] - mid)
    
        flg = True
    
        for i in range(n):
            if not fmax(1, nums[i] - mid) <= sol[i + 1] - sol[i] <= nums[i] + mid:
                flg = False
        
        for i in range(m):
            if not xs[i] <= sol[rs[i]] - sol[ls[i]] <= ys[i]:
                flg = False
        
        if flg: r = mid - 1
        else: l = mid + 1
        
        for i in range(n + 1):
            sol[i] = 0
    
    print(l if l < bound else -1)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<long long> nums(n);
	for (auto &x: nums) cin >> x;

	vector<long long> ls(m), rs(m), xs(m), ys(m);

	for (int i = 0; i < m; i ++) {
		cin >> ls[i] >> rs[i] >> xs[i] >> ys[i];
		ls[i] --;
	}

	long long bound = 1e13;
	long long l = 0, r = bound;

	vector<long long> sol(n + 1, 0);

	while (l <= r) {
		long long mid = (l + r) / 2;

		for (int _ = 0; _ < n; _ ++) {
			for (int i = 0; i < m; i ++) {
				sol[rs[i]] = max(sol[rs[i]], sol[ls[i]] + xs[i]);
				sol[ls[i]] = max(sol[ls[i]], sol[rs[i]] - ys[i]);
			}
			for (int i = 0; i < n; i ++) {
				sol[i + 1] = max(sol[i + 1], sol[i] + max(1ll, nums[i] - mid));
				sol[i] = max(sol[i], sol[i + 1] - nums[i] - mid);
			}
		}

		bool flg = true;

		for (int i = 0; i < n; i ++) {
			if (!(max(1ll, nums[i] - mid) <= sol[i + 1] - sol[i]) || !(sol[i + 1] - sol[i] <= nums[i] + mid)) {
				flg = false;
			}
		}

		for (int i = 0; i < m; i ++) {
			if (!(xs[i] <= sol[rs[i]] - sol[ls[i]]) || !(sol[rs[i]] - sol[ls[i]] <= ys[i])) {
				flg = false;
			}
		}

		if (flg) r = mid - 1;
		else l = mid + 1;

		for (int i = 0; i <= n; i ++) sol[i] = 0;
	}

	cout << (l < bound ? l : -1);

	return 0;
}
```