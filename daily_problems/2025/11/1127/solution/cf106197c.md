**提示 1：** 如何找到 $1$ 所在的位置？

**提示 2：** 尝试在剩下的元素中找到一个质数。

首先，我们不断取当前数组中的两个元素，输入的元素中不是计算得到的结果的一定不是 $1$ ，因此，每次查询可以至少排除一个不是 $1$ 的元素。这样我们每次查询排除一格位置，可以用 $n-1$ 次查询找到 $1$ 所在位置。

接下来，我们尝试找到一个质数。

我们假设第一个元素是质数，接下来遍历备选的数字。如果遍历的数字和当前数字的最大公约数等于 $1$ ，则被遍历的元素我们之后还得考虑（即包含的质因子不同），放入下一轮的备选集；否则，只有两者的最大公约数可能是质数。

这样做最后一定剩下一个质数，因为如果这个数不是质数，那么考虑这个数的一个质因子 $p$ ，如果在这个数之前出现，那么在遍历到这个数前，维护的质因子会是 $p$ ，之后变不回来；如果在这个数之后出现，则遍历到 $p$ 时又会把这个数替代掉。

而此时删去了多少个备选的数呢？其实所有这个质数的倍数都被删掉了，无论是在这个质数前面出现还是后面。

而一个质数的倍数至少占一半数量，所以备选的元素至少减半。所以总查询次数不超过 $n-1+n+n/2+n/4+\dots\lt 3n$ ，满足要求。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def query(x, y):
        print('?', x, y, flush=True)
        return II()
    
    def answer(idxs):
        print('!', len(idxs), *(idx for idx in idxs))
    
    n = II()
    pos1 = 1
    
    for i in range(2, n + 1):
        if query(pos1, i) != pos1:
            pos1 = i
    
    cur = [i for i in range(1, n + 1) if i != pos1]
    ans = []
    
    while cur:
        ncur = []
        prime_val = cur[0]
    
        for i in range(1, len(cur)):
            v = query(prime_val, cur[i])
            
            if v == pos1: ncur.append(cur[i])
            else: prime_val = v
        
        cur = ncur
        ans.append(prime_val)
    
    answer(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	auto query = [&] (int x, int y) -> int {
		cout << "? " << x << ' ' << y << endl;
		int val;
		cin >> val;
		return val;
	};

	int pos1 = 1;

	for (int i = 2; i <= n; i ++) {
		if (query(pos1, i) != pos1) {
			pos1 = i;
		}
	}

	vector<int> cur, ans;

	for (int i = 1; i <= n; i ++) {
		if (i != pos1) {
			cur.emplace_back(i);
		}
	}

	while (!cur.empty()) {
		vector<int> ncur;
		int prime_val = cur[0];

		for (int i = 1; i < cur.size(); i ++) {
			int val = query(prime_val, cur[i]);

			if (val == pos1) ncur.emplace_back(cur[i]);
            else prime_val = val;
		}

		cur.swap(ncur);
		ans.emplace_back(prime_val);
	}

	cout << "! " << ans.size();

	for (auto &x: ans) cout << ' ' << x;

	return 0;
}
```