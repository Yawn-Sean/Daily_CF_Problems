**提示 1：** 可以取出来大量元素排序。

**提示 2：** 什么情况一定不行？

**提示 3：** 将相对麻烦的情况转化为简单情况。

我们记录每个元素的位置，对原数组取位置排序等价于对某些数值的下标进行排序。

转化问题后，我们相当于要取子序列，使得子序列对应下标的异或和是 $0$ ，对这些子序列排序。我们下面讨论这个问题。

为了方便，我们强行在前面加一个 $0$ ，认为其位置是 $0$ 。

容易注意到 $2k$ 和 $2k+1$ 异或结果是 $1$ ，所以我们只要取出偶数组 $(2k,2k+1)$ ，我们就能将这些下标一起排序。

所以，当数组本身就是偶数组 $(2k,2k+1)$ 时，可以整体一起排序，此时 $n$ 模 $4$ 余 $3$ 。

而 $n$ 模 $4$ 余 $1$ 时，是奇数组 $(2k,2k+1)$ ，怎么办呢？我们可以删去任意的一组进行排序，其实结果也很棒了——毕竟相当于数组的大部分都被排序了。考虑如何用这个操作让整个数组排序。

事实上，此时只需对 $0\sim n-2$ 排序，这样 $n-1, n$ 就一定不在前两个位置了，也就一定在 $2\sim n$ 之间，此时对 $2\sim n$ 排序， $n-1,n$ 就一定在结尾了，于是此时再对 $0\sim n-2$ 排序即可。

剩余情况，其实只需把 $n$ 移动到结尾就可以转化为 $n-1$ 的情况了，考虑这件事咋办到。

如果 $n$ 本身就在结尾了，显然就已经完成了。

如果 $n$ 是一个 $2$ 的幂次，那么没有办法让最后一个位置被操作，因此此时一定无解。

接下来考虑 $n$ 不是 $2$ 的幂次的情况。

考虑 $n$ 的位置 $pos$ ，如果 $n$ 和 $pos$ 的异或结果 $x$ 本身不超过 $n$ ，那么直接对 $n,x,pos$ 操作即可。

不然的话， $pos$ 一定满足最高位和 $n$ 不相同（不然异或结果就一定比 $n$ 小了）。设 $n$ 的最高位是 $2^k$ ，我们可以找到一个等于 $pos,2^k,n$ 的异或和的数，这个数一定严格小于 $2^k$ ，因为 $2^k$ 的这个二进制位只有 $2^k,n$ 是 $1$ ，同时，这个数也一定不等于 $pos$ ，否则 $n=2^k$ ，跟之前说到的矛盾。

因此对这几个位置进行排序后， $n$ 就来到末尾了，自然的转换为 $n-1$ 的情况。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = [0] + LII()
    
        pos = [0] * (n + 1)
        
        for i in range(n + 1):
            pos[nums[i]] = i
        
        ops = []
        
        def operate(vals):
            vis_idx = [0] * (n + 1)
            vis_val = [0] * (n + 1)
            
            for x in vals:
                vis_val[x] = 1
                vis_idx[pos[x]] = 1
            
            idxs = [i for i in range(n + 1) if vis_idx[i]]
            vals = [i for i in range(n + 1) if vis_val[i]]
            
            for idx, val in zip(idxs, vals):
                nums[idx] = val
                pos[val] = idx
            
            ops.append(f"{len(idxs)} {' '.join(map(str, idxs))}")
        
        val = 1 << n.bit_length() - 1
        def move():
            if nums[n] == n: return
            
            vals = [nums[n], n]
            cur = nums[n] ^ n
            
            while cur:
                vals.append(cur & -cur)
                cur -= cur & -cur
            
            operate(vals)
        
        if n & -n == n:
            if nums[n] != n:
                outs.append('-1')
                continue
            elif n % 4 == 0:
                operate(list(range(1, n)))
        
        elif n % 4 == 3:
            operate(list(range(1, n + 1)))
        
        elif n % 4 == 1:
            operate(list(range(1, n - 1)))
            operate(list(range(2, n + 1)))
            operate(list(range(1, n - 1)))
        
        elif n % 4 == 0:
            operate(list(range(1, val)))
            move()
            operate(list(range(1, n)))
        
        else:
            operate(list(range(1, val)))
            move()
            operate(list(range(1, n - 2)))
            operate(list(range(2, n)))
            operate(list(range(1, n - 2)))
        
        outs.append(str(len(ops)))
        outs.append('\n'.join(ops))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n + 1, 0), pos(n + 1, 0);

		for (int i = 1; i <= n; i ++) {
			cin >> nums[i];
			pos[nums[i]] = i;
		}

		vector<vector<int>> ops;

		auto operate = [&] (vector<int> vals) -> void {
			vector<int> vis_idx(n + 1, 0), vis_val(n + 1, 0);

			for (auto &x: vals) {
				vis_idx[pos[x]] = 1;
				vis_val[x] = 1;
			}

			vector<int> nidxs, nvals;

			for (int i = 0; i <= n; i ++) {
				if (vis_idx[i]) nidxs.emplace_back(i);
				if (vis_val[i]) nvals.emplace_back(i);
			}

			for (int i = 0; i < nidxs.size(); i ++) {
				nums[nidxs[i]] = nvals[i];
				pos[nvals[i]] = nidxs[i];
			}

			ops.emplace_back(nidxs);
		};

		auto move_pos = [&] () -> void {
			if (nums[n] == n) return ;
			vector<int> vals = {nums[n], n};
			int cur = nums[n] ^ n;

			while (cur) {
				int x = cur & -cur;
				vals.emplace_back(x);
				cur -= x;
			}

			operate(vals);
		};

		int val = 1 << 31 - __builtin_clz(n);

		if ((n & -n) == n) {
			if (nums[n] != n) {
				cout << -1 << '\n';
				continue;
			}
			else if (n % 4 == 0) {
				vector<int> idxs(n - 1);
				iota(idxs.begin(), idxs.end(), 1);
				operate(idxs);
			}
		}
		else if (n % 4 == 3) {
			vector<int> idxs(n);
			iota(idxs.begin(), idxs.end(), 1);
			operate(idxs);
		}
		else if (n % 4 == 1) {
			vector<int> idxs1(n - 2), idxs2(n - 1);
			iota(idxs1.begin(), idxs1.end(), 1);
			iota(idxs2.begin(), idxs2.end(), 2);
			operate(idxs1);
			operate(idxs2);
			operate(idxs1);
		}
		else if (n % 4 == 0) {
			vector<int> idxs1(val - 1), idxs2(n - 1);
			iota(idxs1.begin(), idxs1.end(), 1);
			iota(idxs2.begin(), idxs2.end(), 1);
			operate(idxs1);
			move_pos();
			operate(idxs2);
		}
		else {
			vector<int> idxs1(val - 1), idxs2(n - 3), idxs3(n - 2);
			iota(idxs1.begin(), idxs1.end(), 1);
			iota(idxs2.begin(), idxs2.end(), 1);
			iota(idxs3.begin(), idxs3.end(), 2);
			operate(idxs1);
			move_pos();
			operate(idxs2);
			operate(idxs3);
			operate(idxs2);
		}

		cout << ops.size() << '\n';
		for (auto &op: ops) {
			cout << op.size();
			for (auto &x: op) cout << ' ' << x;
			cout << '\n';
		}
	}

	return 0;
}
```