**提示 1：** 字典序 —— 从前往后贪心。最终的排列最大如何？

**提示 2：** 如何计算最终方案数 —— 元素的大小关系是相邻的比较得到的。

我们先考虑最大化最后的排列数组。

首先，第一个元素咋取呢？显然越大越好。因为无论后面取什么，这个元素越大，最后的排列都是越大的。

第二个元素怎么办呢？如果它能不超过第一个元素，它就应该这样，否则的话第一位在排列数组的结果就会变小了。而在这个条件的情况下，第二个元素越大越好。

接下来，假设前 $k$ 位都确定了，第 $k+1$ 位取什么呢？我们考虑前面 $k$ 位中哪些位可能比第 $k+1$ 位大，这只需取 $k+1$ 位的最小值即可确定。在满足对应的数量的情况下，我们只需最大化第 $k+1$ 位的数值即可。

根据上述贪心策略我们可以得到最终的排列数组。

有了排列数组后，我们如何计数呢？

排列数组意味着一系列大小的关系。而因为比较关系具有传递性，这个数组中最重要的比较就是数字为 $(1,2),(2,3),\dots,(n-1,n)$ 的这些位置的对的取数情况。

我们用 $DP[i][j]$ 表示取到排列中第 $i$ 小的数且当前数组选择数字为 $j$ 的方案数。则转移过程中， $DP[i+1][j']$ 只需考虑 $DP[i]$ 一层中不超过 $j'$ 的 $j$ 进行转移即可，这是一个前缀，使用一个指针维护选取的前缀以及对应的前缀和即可。

这里需要注意一个细节，如果排列中，更大的数字在更前面，则数字需要满足的关系是严格大于，否则只需要是大于等于，要仔细。

然后，获取排列的过程中如果你对下标进行直接排序需要使用稳定排序，否则会因为前一段的原因导致一些前后位置取数相等的情况的误判。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    rnd = random.getrandbits(30)
    
    n = II()
    lsts = []
    vals = []
    
    for _ in range(n):
        l = II()
        nums = [x + rnd for x in MII()]
        nums.sort()    
        lsts.append(nums)
        vals.extend(nums)
    
    vals = sorted(set(vals))
    k = len(vals)
    d = {v: i for i, v in enumerate(vals)}
    
    fen = FenwickTree(k)
    ans = []
    
    for i in range(n):
        l = len(lsts[i])
        
        val = fen.rsum(d[lsts[i][0]] + 1, k - 1)
        chosen = lsts[i][0]
        
        for j in range(1, l):
            if fen.rsum(d[lsts[i][j]] + 1, k - 1) != val: break
            chosen = lsts[i][j]
    
        fen.add(d[chosen], 1)
        ans.append(chosen)
    
    st_range = sorted(range(n), key=lambda x: ans[x])
    
    last_i = n
    cur = [0]
    dp = [1]
    
    mod = 998244353
    
    for i in st_range:
        ncur = []
        ndp = []
        
        pt = 0
        res = 0
        
        l = len(lsts[i])
        for j in range(l):
            if lsts[i][j] > ans[i]: break
            
            while pt < len(cur) and (cur[pt] < lsts[i][j] or (cur[pt] == lsts[i][j] and last_i < i)):
                res += dp[pt]
                res %= mod
                pt += 1
            
            ncur.append(lsts[i][j])
            ndp.append(res)
        
        cur = ncur
        dp = ndp
        last_i = i
    
    print(sum(dp) % mod)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<vector<int>> lsts(n);

	for (int i = 0; i < n; i ++) {
		int k;
		cin >> k;

		lsts[i].resize(k);
		for (auto &x: lsts[i]) cin >> x;

		sort(lsts[i].begin(), lsts[i].end());
	}

	multiset<int> vis;
	vector<int> ans;

	for (int i = 0; i < n; i ++) {
		int l = lsts[i].size();
		auto pt = vis.lower_bound(lsts[i][0]);
		int chosen = lsts[i][0];

		for (int j = 1; j < l; j ++) {
			auto pt1 = vis.lower_bound(lsts[i][j]);
			if (pt != pt1) break;
			chosen = lsts[i][j];
		}

		vis.insert(chosen);
		ans.emplace_back(chosen);
	}

	int last_i = n, mod = 998244353;
	vector<int> cur = {0}, dp = {1};

	vector<int> st_range(n);
	iota(st_range.begin(), st_range.end(), 0);
	stable_sort(st_range.begin(), st_range.end(), [&] (int i, int j) {return ans[i] < ans[j];});

	for (auto &i: st_range) {
		vector<int> ncur, ndp;
		int pt = 0, res = 0;
		int l = lsts[i].size();

		for (int j = 0; j < l; j ++) {
			if (lsts[i][j] > ans[i]) break;

			while (pt < cur.size() && (cur[pt] < lsts[i][j] || (cur[pt] == lsts[i][j] && last_i < i))) {
				res += dp[pt];
				res %= mod;
				pt ++;
			}

			ncur.emplace_back(lsts[i][j]);
			ndp.emplace_back(res);
		}

		cur.swap(ncur);
		dp.swap(ndp);
		last_i = i;
	}

	int res = 0;
	for (auto &x: dp) res = (res + x) % mod;

	cout << res;

	return 0;
}
```