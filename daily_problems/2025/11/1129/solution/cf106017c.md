**提示 1：** 我们不需要真的维护浮点数，我们只需确定答案是 $0\sim 10^8$ 中的哪一个整数。

**提示 2：** 没有精度误差的是整数操作，有没有办法维护一个能确定的东西呢？

注意，这里答案只可能是 $0\sim 10^8$ 的一个整数，所以你只需要给出一个能区分这些情况的东西进行维护就可以了。

为了没有精度丢失，考虑使用整数。而用整数表示一个有理数，显然考虑取模。

关于一个大于 $10^8$ 的数取模后，我们就直接区分了 $0\sim 10^8$ 的任何情况（当然保证分母有逆元的情况下，所以最好取整数）。所以我们维护每个位置关于 $p$ 取模的结果。

而接下来经历的各个操作无非是加法和乘法，这件事很容易用懒更新线段树一类的数据结构维护。

时间复杂度为 $\mathcal{O}(q(\log q+\log M))$ 。 

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    q = II()
    mod = 998244353
    
    def op(x, y): return 0
    
    def mapping(x, y):
        xa, xb = divmod(x, mod)
        return (xa * y + xb) % mod
    
    def composition(x, y):
        xa, xb = divmod(x, mod)
        ya, yb = divmod(y, mod)
        
        a = xa * ya % mod
        b = (xa * yb + xb) % mod
        
        return a * mod + b
    
    seg = LazySegTree(op, 0, mapping, composition, mod, q)
    pt = 0
    
    idxs = [-1] * q
    outs = []
    
    for qidx in range(q):
        query = LII()
        
        if query[0] == 1:
            x = query[1]
            seg.apply(pt, pt + 1, mod + x)
            idxs[qidx] = pt
            pt += 1
        
        elif query[0] == 2:
            x = query[1] % mod
            seg.apply(0, pt, mod + x)
        
        elif query[0] == 3:
            p = query[1]
            q = query[2]
            
            x = p * pow(q, -1, mod) % mod
            seg.apply(0, pt, x * mod)
        
        else:
            idx = query[1] - 1
            outs.append(seg.get(idxs[idx]))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
const int mod = 998244353;

int op(int x, int y) {return 0;}

int mapping(pair<int, int> x, int y) {
	return (1ll * x.first * y + x.second) % mod;
}

pair<int, int> composition(pair<int, int> x, pair<int, int> y) {
	pair<int, int> ans;
	ans.first = 1ll * x.first * y.first % mod;
	ans.second = (1ll * x.first * y.second + x.second) % mod;
	return ans;
}

int e() {return 0;}

pair<int, int> id() {return {1, 0};}

long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int q;
	cin >> q;

	atcoder::lazy_segtree<int, op, e, pair<int, int>, mapping, composition, id> seg(q);
	int pt = 0;

	vector<int> idxs(q);

	for (int i = 0; i < q; i ++) {
		int t;
		cin >> t;

		if (t == 1) {
			int x;
			cin >> x;
			seg.apply(pt, pt + 1, {1, x});
			idxs[i] = pt ++;
		}
		else if (t == 2) {
			int x;
			cin >> x;
			x = (mod + x) % mod;
			seg.apply(0, pt, {1, x});
		}
		else if (t == 3) {
			int p, q;
			cin >> p >> q;

			int x = p * quickPow(q, mod - 2, mod) % mod;
			if (x < 0) x += mod;

			seg.apply(0, pt, {x, 0});
		}
		else {
			int idx;
			cin >> idx;
			idx --;
			cout << seg.get(idxs[idx]) << '\n';
		}
	}

	return 0;
}
```