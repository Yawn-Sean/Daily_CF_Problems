**提示 1：** 构造方案很多，可以尝试让异或运算的情况相对简单。同时让最小公倍数的运算相对简单。

如果异或运算简单起见，可以考虑直接让两个数位不重合；如果要让最小公倍数运算简单，直接使得一者是另一者的倍数。

于是考虑将原数乘 $2^x$ 使得当前数和原数没有二进制位同为 $1$ ，则设原数是 $v$ ，则异或结果是 $(2^x+1)v$ ，最小公倍数是 $2^xv$ 。

此时发现另一个数选 $(2^x+1)v$ ，就可以使得异或结果和最小公倍数结果互换，于是 $2^xv$ 和 $(2^x+1)v$ 就是一组合法的解。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        c = II()
        x = c << 30
        outs.append(f'{x} {x ^ c}')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		long long c;
		cin >> c;
		long long v = c << 30;
		cout << v << ' ' << (v ^ c) << '\n';
	}

	return 0;
}
```