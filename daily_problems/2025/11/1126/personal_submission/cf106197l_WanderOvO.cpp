/*
羊的提示：考虑让行的和以及列的和的奇偶性不一样
如果是奇数行的话，奇数个奇数相加并不是偶数，所以没法这样做，但可以通过微调搞定
我们先把偶数行的情况玩明白
先搞一个全 1 矩阵
1111
1111
1111
1111
我们不妨让行是偶数，则为了让行的值不一样，我们需要把一些 1 改成 3
可以考虑下面的构造
1333
1133
1113
1111
至此，行就都是偶数，且不相等了
接下来考虑列，我们希望列是奇数
现在矩阵中每个数都是奇数，但有偶数行，所以我们每个列需要搞出来奇数个偶数
在这个的基础上，还得保证每行是奇数
这就需要每行同时将偶数个位置的奇数改成偶数，才能保证行的奇偶性不变

羊的做法是，我们每列只改一个地方，并且是把数增大，即把 1 变成 2 或者把 3 变成 4
由于把数字改大会让所在行的值变大，羊的考虑是避免数值重复，所以不妨就直接改行的和最大的行上的元素
在这里，就是把第一行改成 2 或者 4
2444
1133
1113
1111
偶数的情况到这里就解决了，接下来考虑奇数的情况
奇数的情况是下面这样的
13333
11333
11133
11113
11111
如果把第一行所有的 3 都改成 4，会导致第一行的奇偶性条件不再满足
所以我们先考虑把第一行的前 n - 1 大列搞一下
14444
11333
11133
11113
11111
目前，n 行内部无重复且奇偶性相同
后 n - 1 列奇偶性相同，且数值不重复
第一列和其他列奇偶性不同，并且显然第一列和最后一行目前是值相同冲突的
如果把右下角换成 2，会怎么样
14444
11333
11133
11113
11112
现在，最后一行是偶数了
行内部依然没事
列的话，收到改变的是最后一列，但它不和其他列冲突
第一列现在是唯一的最小列了
其实并不全对，n = 3 的时候第一行和最后一列的差距没拉开，所以不对
144
113
112
但 n 更大且为奇数的情况，差距就拉开了
所以只要手动构造一个 3 * 3 的情况特判掉就好了
144 9
113 5
121 4
378
*/

int n;

void solve() {    
    cin >> n;
    vector<vector<int>> grid(n + 1, vector<int>(n + 1, 1));
    if (n % 2 == 0) {
        for (int i = 1; i <= n; i++) {
            for (int j = i + 1; j <= n; j++) {
                grid[i][j] = 3;
            }
        }
        
        for (int i = 1; i <= n; i++) {
            grid[1][i]++;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                cout << grid[i][j];
            }
            cout << "\n";
        }
    } else {
        if (n == 3) {
            cout << "144\n";
            cout << "113\n";
            cout << "121\n";
        } else {
            for (int i = 1; i <= n; i++) {
                for (int j = i + 1; j <= n; j++) {
                    grid[i][j] = 3;
                }
            }
            
            for (int i = 2; i <= n; i++) {
                grid[1][i]++;
            }
            grid[n][n] = 2;
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    cout << grid[i][j];
                }
                cout << "\n";
            }
        }
    }
    
    // set<int> sum;
    // for (int i = 1; i <= n; i++) {
        // int s = 0;
        // for (int j = 1; j <= n; j++) {
            // s += grid[i][j];
        // }
        // if (sum.count(s)) {
            // cout << "FUCK\n";
            // cout << n << "\n";
            // return;
        // }
        // sum.insert(s);
    // }
    // for (int j = 1; j <= n; j++) {
        // int s = 0;
        // for (int i = 1; i <= n; i++) {
            // s += grid[i][j];
        // }
        // if (sum.count(s)) {
            // cout << "FUCK\n";
            // cout << n << "\n";
            // return;
        // }
        // sum.insert(s);
    // }
}
