**提示 1：** 想办法给行和列分配两种数，这样两者就不会撞到了。

**提示 2：** 行内和列内的区分用另一套规则。

行列同时考虑相对麻烦，于是考虑用一种方式区分行列，再在这个基础上进一步区分每一行和每一列（即行列内部的不重复）。

行和列的总和是相等的，所以第一步的区分逻辑不应该带来数值上的大量差异。所以我们可以用奇数和偶数（当然 $n$ 是奇数时不可能 $n$ 个奇数的和等于 $n$ 个偶数的和，这种只差一小点的边界情况我们可以最后再调整）。而行与行之间，列与列之间需要满足数值大小有一定差异。

我们先满足后面这件事，为了之后让行列奇偶性不同的处理更干净，我们构造这一步的时候强行让每行 / 每列总和的奇偶性保持一致。

此时只需要构造一个全是 $1$ 的矩阵，再在上三角 / 下三角的部分填入一堆 $3$ 就行。

接下来，我们凑奇偶性。我们让行的奇偶性不变，列的奇偶性改变。操作方式是对某个元素进行 $+1$ ，所以，我们可以对前 $\lfloor n/2\rfloor\times 2$ 列每列进行 $+1$ 操作，而这些需要分配给行，并保证每行的操作次数都是偶数。

因此不妨操作到目前和最大的一行，这样不会和别的行 / 列撞数值。

此时最后最多只有 $n$ 是奇数的情况下会有某行和某列不满足要求，稍微对某个位置进行微调就能满足要求了。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        
        ans = [[1] * n for _ in range(n)]
        
        for i in range(n):
            for j in range(i):
                ans[i][j] += 2
        
        for i in range(n % 2, n):
            ans[n - 1][i] += 1
        
        for x in ans:
            outs.append(''.join(map(str, x)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<string> ans(n, string(n, '1'));

		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < i; j ++) {
				ans[i][j] = '3';
			}
		}

		for (int i = n % 2; i < n; i ++) {
            ans[n - 1][i] ++;
		}

		for (auto &s: ans) cout << s << '\n';
	}

	return 0;
}
```