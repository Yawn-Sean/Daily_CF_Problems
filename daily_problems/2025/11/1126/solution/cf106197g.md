**提示 1：** 要想数字最小，相当于是长度一定的时候字典序最小。

**提示 2：** 我们一个数一个数确定，如何判断当前选的数是否是最优的？

因为除了 $0$ 的数字都没有前导 $0$ ，所以先特判下答案是 $0$ 的情况。

接下来考虑一位一位确定答案。当然需要注意下第一位选的数不能是 $0$ 。

假设我们现在选了若干位，下一位需要从 $pos$ 位置开始选数，这个数需要满足什么条件呢？

如果我们选择了 $i$ ，则我们需要找到 $pos$ 之后第一次出现 $i$ 的位置 $p$ 。这件事我们需要在开头进行位置。

而我们找到 $p$ 后，需要计算 $p$ 后面能覆盖的 $00\dots 0\sim 99\dots 9$ 子序列的最大长度，这个长度越小，我们最终的答案才能越小。

综上，我们选取数的逻辑是，首先位数最小——即 $p$ 后面能覆盖的 $00\dots 0\sim 99\dots 9$ 子序列的最大长度最小，在这个基础上，当前位应当尽可能小，即取对应的 $i$ 最小的一个。

为此我们需要维护两件事，一件就是某个位置开始之后某个数码第一次出现的位置，另一件就是后缀覆盖的 $00\dots 0\sim 99\dots 9$ 子序列的最大长度。

前面这件事只需对于每个数码分别维护即可。

后面这件事考虑从后往前遍历，只有完整的走过一次 $0\sim 9$ ，才能产生新的一位。我们用这个方式给后缀分组。

对于每个后缀，我们取当前组别没有的数码 + 每一组的开头元素作为子序列，则这个子序列一定不会在这个后缀中出现，所以此时最长完全覆盖后缀的长度是此时后缀的分组数量。所以维护这件事（即总共经历了完整的几组）就行。

时间复杂度为 $\mathcal{O}(10|s|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        s = [int(c) for c in I()]
        
        if 0 not in s: outs.append('0')
        else:
            n = len(s)
    
            next_pos = [[n] * (n + 1) for _ in range(10)]
            
            for i in range(n - 1, -1, -1):
                for j in range(10):
                    next_pos[j][i] = next_pos[j][i + 1]
                next_pos[s[i]][i] = i
    
            later_longest_full = [0] * (n + 1)
            later_longest_full[n] = -1
            
            cnt = [0] * 10
            cur = 0
            res = 0
            
            for i in range(n - 1, -1, -1):
                later_longest_full[i] = res
    
                if cnt[s[i]] == 0:
                    cnt[s[i]] = 1
                    cur += 1
                
                if cur == 10:
                    cur = 0
                    res += 1
                    for j in range(10):
                        cnt[j] = 0
    
            ans = []
            pos = 0
            
            while pos <= n:
                mi = n + 5
                choice = -1
    
                for i in range(0 if ans else 1, 10):
                    if later_longest_full[next_pos[i][pos]] < mi:
                        mi = later_longest_full[next_pos[i][pos]]
                        choice = i
                
                ans.append(choice)
                pos = next_pos[choice][pos] + 1
            
            outs.append(''.join(map(str, ans)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		string s;
		cin >> s;

		bool flg = false;
		for (auto &c: s) {
			if (c == '0') {
				flg = true;
			}
		}

		if (!flg) cout << 0 << '\n';
		else {
			int n = s.size();

			vector<vector<int>> next_pos(10, vector<int>(n + 1, n));

			for (int i = n - 1; i >= 0; i --) {
				for (int j = 0; j < 10; j ++) {
					next_pos[j][i] = next_pos[j][i + 1];
				}
				next_pos[s[i] - '0'][i] = i;
			}

			vector<int> later_longest_full(n + 1, 0);
			later_longest_full[n] = -1;

			vector<int> cnt(10, 0);
			int cur = 0, res = 0;

			for (int i = n - 1; i >= 0; i --) {
				later_longest_full[i] = res;

				if (!cnt[s[i] - '0']) {
					cnt[s[i] - '0'] = 1;
					cur ++;
				}

				if (cur == 10) {
					cur = 0;
					res ++;
					for (int j = 0; j < 10; j ++) {
						cnt[j] = 0;
					}
				}
			}

			int pos = 0;

			while (pos <= n) {
				int mi = n + 5, choice = -1;

				for (int i = (pos ? 0 : 1); i < 10; i ++) {
					if (later_longest_full[next_pos[i][pos]] < mi) {
						mi = later_longest_full[next_pos[i][pos]];
						choice = i;
					}
				}

				cout << choice;
				pos = next_pos[choice][pos] + 1;
			}
			cout << '\n';
		}
	}

	return 0;
}
```