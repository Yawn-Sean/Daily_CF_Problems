**提示 1：** 恰好 $k$ 个不好求。但如果是大于等于的话，就只要满足所有的异或和都不小于 $k$ 就行了。

**提示 2：** 如何将原问题转为上述问题？

**提示 3：** 添加元素数组会更不满足要求，删去元素会更满足要求，所以……

首先这里恰好为 $k$ 直接处理会比较难，考虑转为至少为 $k$ 的结果减去至少为 $k+1$ 的结果。

接下来处理分数不小于 $val$ 的子数组个数。

由于新增元素分数不会变大，同时删去元素分数不会变小，所以可以使用双指针，维护区间里有的数，这样新增一个数时，我们要查询这个数和当前子数组的最小异或和，这件事可以使用 01-Trie ，也可以用 multiset 找最接近当前这个数的元素。移动左侧指针时，在 01-Trie 中删除元素即可。

时间复杂度为 $\mathcal{O}(n\log M)$ ，如果使用最小的异或和对一定来自于相邻的元素，则可以通过维护所有相邻元素的异或和的 multiset 来求解最小异或和对，这样复杂度是 $\mathcal{O}(n\log n)$ 的。这里 multiset 需要维护的两个东西也不算很干净，可以试试。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k = MII()
    nums = LII()
    
    def solve(val):
        ans = 0
        
        trie = Trie01(n, (1 << 30) - 1)
        l = r = 0
        while l < n:
            while r < n:
                if l == r:
                    trie.insert(nums[l])
                else:
                    if trie.findMinXor(nums[r]) >= val:
                        trie.insert(nums[r])
                    else: break
                r += 1
            
            ans += r - l
            
            trie.delete(nums[l])
            l += 1
        
        return ans
    
    print(solve(k) - solve(k + 1))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k;
	cin >> n >> k;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	auto solve = [&] (int val) -> long long {
		Trie<int> trie((1 << 30) - 1, n);
		int l = 0, r = 0;
		long long ans = 0;

		while (l < n) {
			while (r < n) {
				if (l == r) trie.insert(nums[l]);
				else {
					if (trie.findMinXor(nums[r]) >= val) trie.insert(nums[r]);
					else break;
				}
				r ++;
			}

			ans += r - l;
			trie.remove(nums[l]);
			l ++;
		}

		return ans;
	};

	cout << solve(k) - solve(k + 1);

	return 0;
}
```