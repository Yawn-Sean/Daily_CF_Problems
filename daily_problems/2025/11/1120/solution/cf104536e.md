**提示 1：** 我们相当于挑选一些元素形成递增序列，只需保证同个位置只选一次。

**提示 2：** 如何隐含这件事？

先看提示 1 。

我们按照元素的下标递增顺序拼接所有元素，求这个序列的 LIS 。即拼成 $[a_1,b_1,a_2,b_2,\dots,a_n,b_n]$ 。

但这样可能会同个位置取两次，怎么办呢？

我们可以交换元素顺序，使得同个位置的元素大的放在前面，小的放在后面，这样就隐含了一个位置只取一个数组的数。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums1 = LII()
    nums2 = LII()
    
    vals = []
    
    for i in range(n):
        if nums1[i] > nums2[i]:
            vals.append(nums1[i])
            vals.append(nums2[i])
        else:
            vals.append(nums2[i])
            vals.append(nums1[i])
    
    print(lengthOfLIS(vals))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums1(n), nums2(n);
	for (auto &v: nums1) cin >> v;
	for (auto &v: nums2) cin >> v;

	vector<int> vals;

	for (int i = 0; i < n; i ++) {
		if (nums1[i] > nums2[i]) {
			vals.emplace_back(nums1[i]);
			vals.emplace_back(nums2[i]);
		}
		else {
			vals.emplace_back(nums2[i]);
			vals.emplace_back(nums1[i]);
		}
	}

	vector<int> cur;

	for (auto &x: vals) {
		int pt = lower_bound(cur.begin(), cur.end(), x) - cur.begin();
		if (pt == cur.size()) cur.emplace_back(x);
		else cur[pt] = x;
	}

	cout << cur.size();

	return 0;
}
```