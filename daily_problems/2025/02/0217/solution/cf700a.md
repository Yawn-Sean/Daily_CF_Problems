**提示 1：** 想想开车的过程。

**提示 2：** 最后一批学生会坐车坐到底。

最数学的一集。

首先把学生分为尽可能少的组数，设为 $g$ 。

接下来就是一组一组送学生。为了达到在某个总时长 $T$ 下到达终点，有一个最小的坐车时间 $t$ ，使得每一组学生都至少得坐车 $t$ 时间。

接下来我们描述整体坐车的过程：

第一批学生直接上车，坐了 $t$ 时间；车折返去接第二批学生，接到后再坐 $t$ 时间；以此类推。

这里有个关键的事情——第一批学生和第二批学生坐车的时间差等于第二批学生和第三批学生坐车的时间差。

为什么呢？考虑第二批学生坐上车的时候，第三批学生也在相同的位置。因此两个时间差都是 $\frac{2v_2t}{v_1+v_2}$ 。（因为车开出去的距离是 $v_2t$ ，因此车和人走的总距离是 $2\times v_2t$ ，于是用时为 $\frac{2v_2t}{v_1+v_2}$ ）

于是走路的总用时为 $(g-1)\frac{2v_2t}{v_1+v_2}$ （考虑最后一批学生的上车时间，前面的时间全在走路）。

又考虑到开车时间为 $t$ ，于是有方程：

$v_1(g-1)\frac{2v_2t}{v_1+v_2}+v_2t=l$

即：

$\frac{2v_1(g-1)+(v_1+v_2)}{v_1+v_2}v_2t=l$

最后我们要求的是：

$(g-1)\frac{2v_2t}{v_1+v_2}+t=\frac{2v_2(g-1)+(v_1+v_2)}{v_1+v_2}t=\frac{2v_2(g-1)+(v_1+v_2)}{2v_1(g-1)+(v_1+v_2)}l$

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l, v1, v2, k = MII()
    group = (n + k - 1) // k
    print(l / v2 * (2 * v2 * (group - 1) + v1 + v2) / (2 * v1 * (group - 1) + (v1 + v2)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, l, v1, v2, k;
    cin >> n >> l >> v1 >> v2 >> k;

    int group = (n + k - 1) / k;
    cout << fixed << setprecision(10) << (long double)1.0 * l / v2 * (2ll * v2 * (group - 1) + v1 + v2) / (2ll * v1 * (group - 1) + v1 + v2);

    return 0;
}
```