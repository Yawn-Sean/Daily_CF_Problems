/*
如果 max(n, m) > k，则一定到不了
如果 max(n, m) = k，则答案是 min(n, m)
如果 max(n, m) < k，怎样走能让对角线最多？
我们先研究一下怎么样才能走到
假如 k - max(n, m) 为偶数，则肯定可以走到，斜线走过去之后直线走，然后来回搞就行
假如 k - max(n, m) 为奇数
- 如果 n 和 m 都不为 0，则可以把一个斜线拆成两个直走的，这样就剩下偶数个了，也可以到了
- 如果 n 和 m 中至少有一个为 0，则多奇数步必然走不到的，这是唯一的无解情况

对于有解的情况，看如何走更多的对角线
假如我们已经到了 (n, m) 有没有办法一直走斜线然后绕回来呢？
- 如果是多偶数步，则可以纯走对角线最后回来
- 如果是多奇数步，把一个对角拆成两个直线就可以回来了

似乎可以考虑先向上再向下的走法
先一直走斜线，直到走到 (x, x)，其中 x = min(n, m)
假如直线距离差偶数步，则可以先上后下走斜线走到，然后考虑还剩奇数还是偶数步，用上面的分类讨论的结果看看需不需要拆之前的
假如直线距离差奇数步，则斜线走到邻点之后来回跳，最后走直线过去
因此答案要么是 -1，要么是 k, k - 1, k - 2
*/

LL q, n, m, k;

void meibao() {
    cin >> q;
    while (q--) {
        cin >> n >> m >> k;
        if (max(n, m) > k) {
            cout << "-1\n";
            continue;
        }

        if ((k - max(n, m) % 2) == 1 && min(n, m) == 0) {
            cout << "-1\n";
            continue;
        }

        LL x = min(n, m);
        LL left_cnt = k - x;
        LL dist = max(n, m) - x;
        if (dist % 2 == 0) {
            if (left_cnt % 2 == 0) {
                cout << k << "\n";
            } else {
                cout << k - 2 << "\n";
            }
        } else {
            if (left_cnt % 2 == 0) {
                cout << k - 1 << "\n";
            } else {
                cout << k - 1 << "\n";
            }
        }
    }
}
