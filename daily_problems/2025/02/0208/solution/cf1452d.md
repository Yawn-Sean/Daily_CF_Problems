**提示 1：** 如果有一系列塔，最左边的应当如何设置 $p$ ？第二个呢？以此类推。

**提示 2：** 根据上述关系，确认 DP 方程。

假设我们有这么一个塔的配置 `X001000010X` 。

则对于第一个 $1$ （表示有塔），其为了覆盖最左侧的 `0` 且不覆盖左侧的 `X` ，其 $p$ 只有一种选择，于是覆盖了一个长度为 $5$ 的线段。

接下来考虑第二个 $1$ ，其必须覆盖第一个 $1$ 未能覆盖的 `0` ，同时保证这个 `0` 左侧的 `0` 不被覆盖。因此，这个 $1$ 的覆盖区域也是完全确定的。

类似地，我们可以推出每一个 $1$ 对应的分割。

这题虽然要我们求概率，但实际上，总方案数显然是 $2^n$ ，我们只需求出合法方案数即可。

如何计算合法方案呢？我们不妨枚举第一个 $1$ 的位置，则剩下的部分仍然是合法方案且更短，即转化为规模更小的问题，符合 DP 的一般规律。

由于第一个 $1$ 对应的段长度是一个奇数，因此：

$f[n]=\sum\limits_{i\geq 1且 i为奇数}f[n-i]$ 

而后面这部分可以通过预处理前缀和直接得到。

当然，通过简单的推理也可以进一步证明，这个序列就是斐波那契数列。

得到合法方案数量再除以总方案数量即可，时间复杂度 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    mod = 998244353

    a, b = 0, 1
    for _ in range(n):
        a, b = b, (a + b) % mod

    print(a * pow(2, -n, mod) % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, mod = 998244353;
    cin >> n;

    int a = 0, b = 1;
    for (int i = 0; i < n; i ++) {
        a += b;
        if (a >= mod) a -= mod;
        swap(a, b);
    }

    int rev2 = (mod + 1) / 2;
    for (int i = 0; i < n; i ++)
        a = 1ll * a * rev2 % mod;
    cout << a;

    return 0;
}
```
