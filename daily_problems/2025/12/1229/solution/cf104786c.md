**提示 1：** 双方策略如何？

**提示 2：** 状态如何转移？

Olaf 为了抓到 John ，应该不停往 $N$ 走，把它逼到绝路。

所以不妨设 John, Olaf 到 $N$ 的距离分别是 $a,b$ ，此时的期望时间是 $f(a,b)$ 。

于是，一旦 $a\geq b$ ，就意味着已经抓到（因为大小关系改变了）， $f(a,b)=0$ 。

否则，从 $(a,b)$ 出发， Olaf 往 $N$ 走，因此 $b\to b-1$ 。而 $a$ 有一半的概率变成 $a-1$ ，一半概率变成 $a+1$ （除非 $a=0$ ），因此用这个逻辑转移，即：

$f(a,b)=\frac{1}{2}(f(|a-1|,b-1)+f(a+1,b-1))+1$

用这个逻辑进行 DP 即可，只要我们从 $b$ 小的推到 $b$ 大的情况就没有后效性的担忧了。

时间复杂度为 $\mathcal{O}(n^2)$ 。

另外，如果这题不要求 $x\lt y$ ，应该怎么处理另外的那种情况呢？

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    mod = 10 ** 9 + 7
    n, x, y = MII()
    
    x = n - x
    y = n - y
    
    dp = [[0] * (x + 1) for _ in range(x + 1)]
    
    rev2 = (mod + 1) // 2
    
    for i in range(1, x + 1):
        for j in range(i):
            v = dp[i - 1][abs(j - 1)]
            if j + 1 <= i - 1: v += dp[i - 1][j + 1]
            dp[i][j] = (v * rev2 + 1) % mod
    
    print(dp[x][y])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, x, y, mod = 1e9 + 7;
	cin >> n >> x >> y;

	x = n - x, y = n - y;
	vector<vector<int>> dp(x + 1, vector<int>(x + 1, 0));

	int rev2 = (mod + 1) / 2;

	for (int i = 0; i <= x; i ++) {
		for (int j = 0; j < i; j ++) {
			int v = dp[i - 1][abs(j - 1)];
			if (j + 1 <= i - 1) v += dp[i - 1][j + 1];
			dp[i][j] = (1ll * v * rev2 + 1) % mod;
		}
	}

	cout << dp[x][y];

	return 0;
}
```
