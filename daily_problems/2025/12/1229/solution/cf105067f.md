**提示 1：** 数组至于比较小，高的位不受影响。

**提示 2：** 更低的位有什么不同的情况？

首先，数组的值域严格小于 $2^{17}$ ，所以对于 $x$ 的不小于 $2^{17}$ 的位，实际上都完全不进行异或的操作。我们这一部分认为是 $2^{17}\times n\times val$ 。

而对于更小的位，我们只需预处理 $0\sim 2^{17}-1$ 对应的不同的异或结果，就能得到更低的位的可能数值。

如何快速求 $x$ 对应的答案呢？直接预处理，统计每个位有多少个数是 $0$ ，多少个数是 $1$ 。接下来考虑每一位有多少个数跟 $x$ 产生 $1$ 的异或数值，各个位的结果加总即可。

这样我们就得到了 $0\sim 2^{17}-1$ 对应的不同的异或结果，将其去重。而所有的可能取值就是这些数加上若干倍的 $2^{17}\times n$ ，我们只需算这些数有多少个在 $[l,r]$ 之间。

通过枚举基准数进行计算，这是简单的。

时间复杂度为 $\mathcal{O}((n+M)\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, l, r = MII()
    nums = LII()
    
    cnt = [[0] * 17 for _ in range(2)]
    
    for x in nums:
        for i in range(17):
            cnt[x >> i & 1][i] += 1
    
    M = 1 << 17
    
    vals = [0] * M
    
    for i in range(M):
        for j in range(17):
            vals[i] += cnt[(i >> j & 1) ^ 1][j] << j
    
    vals.sort()
    
    ans = 0
    for i in range(M):
        if i == 0 or vals[i] != vals[i - 1]:
            ans += (r - vals[i]) // (M * n) - (l - 1 - vals[i]) // (M * n)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	long long l, r;
	cin >> n >> l >> r;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<vector<int>> cnt(2, vector<int>(17, 0));

	for (auto &x: nums) {
		for (int i = 0; i < 17; i ++) {
			cnt[x >> i & 1][i] ++;
		}
	}

	long long M = 1 << 17;
	vector<long long> saved(M, 0);

	for (int i = 0; i < M; i ++) {
		for (int j = 0; j < 17; j ++) {
			saved[i] += (1ll << j) * cnt[(i >> j & 1) ^ 1][j];
		}
	}

	sort(saved.begin(), saved.end());

	auto floor_div = [&] (long long x, long long y) -> long long {
		long long res = x / y;
		if (res * y > x) res --;
		return res;
	};

	long long ans = 0;
	for (int i = 0; i < M; i ++) {
		if (i == 0 || saved[i] != saved[i - 1]) {
			ans += floor_div(r - saved[i], M * n) - floor_div(l - 1 - saved[i], M * n);
		}
	}

	cout << ans;

	return 0;
}
```
