**提示 1：** 

时间复杂度为 $\mathcal{O}((n+M)\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, l, r = MII()
    nums = LII()
    
    cnt = [[0] * 17 for _ in range(2)]
    
    for x in nums:
        for i in range(17):
            cnt[x >> i & 1][i] += 1
    
    M = 1 << 17
    
    vals = [0] * M
    
    for i in range(M):
        for j in range(17):
            vals[i] += cnt[(i >> j & 1) ^ 1][j] << j
    
    vals.sort()
    
    ans = 0
    for i in range(M):
        if i == 0 or vals[i] != vals[i - 1]:
            ans += (r - vals[i]) // (M * n) - (l - 1 - vals[i]) // (M * n)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	long long l, r;
	cin >> n >> l >> r;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<vector<int>> cnt(2, vector<int>(17, 0));

	for (auto &x: nums) {
		for (int i = 0; i < 17; i ++) {
			cnt[x >> i & 1][i] ++;
		}
	}

	long long M = 1 << 17;
	vector<long long> saved(M, 0);

	for (int i = 0; i < M; i ++) {
		for (int j = 0; j < 17; j ++) {
			saved[i] += (1ll << j) * cnt[(i >> j & 1) ^ 1][j];
		}
	}

	sort(saved.begin(), saved.end());

	auto floor_div = [&] (long long x, long long y) -> long long {
		long long res = x / y;
		if (res * y > x) res --;
		return res;
	};

	long long ans = 0;
	for (int i = 0; i < M; i ++) {
		if (i == 0 || saved[i] != saved[i - 1]) {
			ans += floor_div(r - saved[i], M * n) - floor_div(l - 1 - saved[i], M * n);
		}
	}

	cout << ans;

	return 0;
}
```
