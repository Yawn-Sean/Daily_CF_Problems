**提示 1：** 考虑先把段落变成同一个数 $x$ 的成本是 $f(x)$ ，这个函数有何特点？

**提示 2：** 如何在状态转移中维护这个函数？

考虑把某一段全部变成 $x$ 的成本为 $f(x)$ ，则对于长度为 $1$ 的段而言，这个函数相当于 $|x-nums[i]|$ 。

我们用几个长度为 $4^i$ 的段的计算结果来得到长度为 $4^{i+1}$ 的段的计算结果。现在有四个这样的函数相加，则得到的一定是类似绝对值函数的和的样子，因此一定存在一个 / 一段最低点，周围往上递增上去。

而除了这个平台外，剩余的部分的斜率可以进一步最小化到 $1$ ，因为我们可以先变成这个平台上的数，再整一段一起变化数值。于是几个函数的合并结果是一段平台，加上前面和后面的斜率绝对值为 $1$ 的向上的射线。

容易用类似上面的推理得到，每一次得到的函数都是类似的形式。这样不断合并，直到得到全长度的数组，求 $0$ 对应的函数值即可。

合并具体咋做呢？事实上，合并后的端点一定是初始端点的子集，因此直接枚举所有端点，看哪些位置取最小值即可。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    inf = 10 ** 18
    def f(x, l, r, c):
        if l <= x <= r: return c
        if x < l: return l - x + c
        return x - r + c
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        ls = nums[:]
        rs = nums[:]
        cost = [0] * n
        
        while len(ls) > 1:
            nls, nrs, ncost = [], [], []
            
            for i in range(0, len(ls), 4):
                l, r, cur = 0, 0, inf
                
                for j in range(i, i + 4):
                    v = 0
                    for k in range(i, i + 4):
                        v += f(ls[j], ls[k], rs[k], cost[k])
                    
                    if v < cur:
                        cur = v
                        l = ls[j]
                        r = ls[j]
                    elif v == cur:
                        l = fmin(l, ls[j])
                        r = fmax(r, ls[j])
                    
                    v = 0
                    for k in range(i, i + 4):
                        v += f(rs[j], ls[k], rs[k], cost[k])
                    
                    if v < cur:
                        cur = v
                        l = rs[j]
                        r = rs[j]
                    elif v == cur:
                        l = fmin(l, rs[j])
                        r = fmax(r, rs[j])
                
                nls.append(l)
                nrs.append(r)
                ncost.append(cur)
            
            ls = nls
            rs = nrs
            cost = ncost
        
        outs.append(f(0, ls[0], rs[0], cost[0]))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int t;
    cin >> t;

    long long inf = 1e18;

    auto f = [&] (long long x, long long l, long long r, long long c) -> long long {
        if (x < l) return l - x + c;
        if (x > r) return x - r + c;
        return c;
    };

    while (t --) {
        int n;
        cin >> n;

        vector<long long> nums(n);
        for (auto &v: nums) cin >> v;

        vector<long long> ls = nums, rs = nums, cost(n, 0);

        while (n > 1) {
            vector<long long> nls, nrs, ncost;

            for (int i = 0; i < n; i += 4) {
                long long l = 0, r = 0, cur = inf;

                for (int j = i; j < i + 4; j ++) {
                    long long v;

                    v = 0;
                    for (int k = i; k < i + 4; k ++)
                        v += f(ls[j], ls[k], rs[k], cost[k]);
                    
                    if (v < cur) {
                        cur = v;
                        l = ls[j];
                        r = ls[j];
                    }
                    else if (v == cur) {
                        l = min(l, ls[j]);
                        r = max(r, ls[j]);
                    }

                    v = 0;
                    for (int k = i; k < i + 4; k ++)
                        v += f(rs[j], ls[k], rs[k], cost[k]);
                    
                    if (v < cur) {
                        cur = v;
                        l = rs[j];
                        r = rs[j];
                    }
                    else if (v == cur) {
                        l = min(l, rs[j]);
                        r = max(r, rs[j]);
                    }
                }
                nls.emplace_back(l);
                nrs.emplace_back(r);
                ncost.emplace_back(cur);
            }

            n /= 4;
            ls.swap(nls);
            rs.swap(nrs);
            cost.swap(ncost);
        }

        cout << f(0, ls[0], rs[0], cost[0]) << '\n';
    }

	return 0;
}
```
