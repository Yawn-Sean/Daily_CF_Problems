**提示 1：** $p$ 没必要那么大。

**提示 2：** DP，状态是什么，怎么转移？

首先，如果中毒次数充足，我们可以用类似二分的方法，直接找到对应的参观，这样总次数是 $\mathcal{O}(\log n)$ 量级的，所以 $p$ 没必要超过对应的量级。

我们考虑有 $i$ 次中毒机会，进行 $j$ 次尝试最多能从 $dp[i][j]$ 个餐馆里找出目标餐馆。

我们最多可以选取 $dp[i-1][j-1]$ 个餐馆进行当次尝试（因为有可能中毒，所以只能是 $i-1$ 了），最多剩下 $dp[i][j-1]$ 个餐馆，于是 $dp[i][j]=dp[i-1][j-1]$ 。

总尝试次数肯定不超过 $n$ ，所以上述 DP 总状态数是 $\mathcal{O}(n\log n)$ 量级的，且转移是常数复杂度，总复杂度是 $\mathcal{O}(n\log n)$ 。注意数据过大时进行截断。

当然这里的递推是不断求前缀和，所以不断增大 $i$ 的结果相当于是次数不断递增的多项式，所以可以达到更优复杂度，这里不进行进一步说明和优化了。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, p = MII()
    
    p = fmin(p, 20)
    dp = [[0] * (n + 1) for _ in range(p + 1)]
    
    for i in range(n + 1):
        dp[0][i] = 1
    
    inf = 10 ** 9
    for i in range(1, p + 1):
        dp[i][0] = 1
        
        for j in range(1, n + 1):
            dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]
            dp[i][j] = fmin(dp[i][j], inf)
    
    for i in range(n + 1):
        if dp[p][i] >= n:
            print(i)
            break
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int n, p, inf = 1e9;
    cin >> n >> p;

    p = min(p, 20);
    vector<vector<int>> dp(p + 1, vector<int>(n + 1, 1));

    for (int i = 1; i <= p; i ++) {
        for (int j = 1; j <= n; j ++) {
            dp[i][j] = min(dp[i - 1][j - 1] + dp[i][j - 1], inf);
        }
    }

    for (int i = 0; i <= n; i ++) {
        if (dp[p][i] >= n) {
            cout << i;
            break;
        }
    }

	return 0;
}
```
