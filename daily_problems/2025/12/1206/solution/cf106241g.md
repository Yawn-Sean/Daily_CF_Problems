**提示 1：** 实际上没有出现过的点是两两等价的。因此 DP 状态如何？

**提示 2：** 转移如何实现？

没出现过的点从转移的角度来看是等价的。

所以拎出来出现过的边中的点，以及剩下的点，总共有 $\mathcal{O}(m)$ 种状态。

这里的状态转移如何进行呢？转移几乎是满的，所以我们不妨假设任意两种状态之间都能发生相互转移（即满的转移情况），再去掉那些不能转移的情况，就是最终的转移情况。

不能转移的情况包括自己走到自己，以及题目中出现的边。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    vis = [0] * n
    path = [[] for _ in range(n)]
    
    for i in range(m):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
        
        vis[u] = 1
        vis[v] = 1
    
    pt = 0
    to_check = []
    
    for i in range(n):
        if vis[i]:
            pt += 1
            vis[i] = pt
            to_check.append(i)
    
    dp = [0] * (pt + 1)
    dp[vis[0]] = 1
    
    mod = 998244353
    
    res = []
    for i in range(n):
        total = sum(dp) % mod
        if i: res.append(total)
        
        ndp = [0] * (pt + 1)
        for i in range(1, pt + 1):
            ndp[i] = total
        ndp[0] = (n - pt) * total % mod
        
        for u in to_check:
            for v in path[u]:
                ndp[vis[v]] -= dp[vis[u]]
                ndp[vis[v]] %= mod
        
        for i in range(pt + 1):
            ndp[i] -= dp[i]
            ndp[i] %= mod
        
        dp = ndp
    
    print(' '.join(map(str, res)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<int> vis(n, 0);
	vector<vector<int>> path(n);

	while (m --) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		path[u].emplace_back(v);
		path[v].emplace_back(u);

		vis[u] = 1;
		vis[v] = 1;
	}

	int pt = 0;
	vector<int> to_check;

	for (int i = 0; i < n; i ++) {
		if (vis[i]) {
			vis[i] = ++pt;
			to_check.emplace_back(i);
		}
	}

	vector<int> dp(pt + 1, 0);
	dp[vis[0]] = 1;

	int mod = 998244353;

	for (int i = 0; i < n; i ++) {
		int total = 0;
		for (auto &x: dp) total = (total + x) % mod;

		if (i) cout << total << ' ';

		vector<int> ndp(pt + 1, 0);

		for (int i = 1; i <= pt; i ++) ndp[i] = total;
		ndp[0] = 1ll * (n - pt) * total % mod;

		for (auto &u: to_check) {
			for (auto &v: path[u]) {
				ndp[vis[v]] += mod - dp[vis[u]];
				ndp[vis[v]] %= mod;
			}
		}

		for (int i = 0; i <= pt; i ++) {
			ndp[i] += mod - dp[i];
			ndp[i] %= mod;
		}

		dp.swap(ndp);
	}

	return 0;
}
```