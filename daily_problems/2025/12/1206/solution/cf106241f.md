**提示 1：** 先回顾经典问题， $\mathrm{gcd},\mathrm{lcm}$ 的数值为 $i$ 的个数怎么求？

**提示 2：** 接下来让两者相等。但注意选取的数组下标不能有重复——要么记得排除重复算的东西，要么补上漏的东西。

我们先求 $\mathrm{gcd}$ 是 $x$ 的元素对的个数。

我们先看 $x$ 的倍数有多少个，为此我们只需统计 $x,2x,\dots$ 分别出现了几次加起来就行，对于所有的 $x$ 而言，时间复杂度是调和级数推导出来的 $\mathcal{O}(n\log n)$ 的（注意这里值域和 $n$ 的范围是一致的）。

而 $\mathrm{gcd}$ 是 $x$ 的倍数的元素对的个数，直接用 $cnt(cnt-1)$ 即可计算。

而对于 $\mathrm{gcd}$ 是 $x$ 的元素，会不小心在 $x$ 的因子的地方也算上，这些部分应该去掉。所以当前在 $x$ 处的计算结果应该去掉 $2x,3x,\dots$ 的部分。

$\mathrm{lcm}$ 部分的推理也是类似的。只是倍数和因数的替换。

而我们要让两者匹配就对相同的位置进行相乘再加总。

但这里你选取的对可能包含相同的元素。设此时最小公倍数和最大公约数都是 $x$ ，容易发现因为最小公倍数选取的数不超过 $x$ ，而最大公约数选取的数不小于 $x$ ，所以两者只能都等于 $x$ 。

可以考虑先都算上含 $x$ 的对，再去掉一个元素重复的和两个元素都重复的情况。也可以都不算上，最后加上包含至少一个 $x$ 的情况（因为这个写起来比较麻烦，所以下面代码给的这种方便对着看漏了啥）。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    mod = 10 ** 9 + 7
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        ans = 0
        
        cnt = [0] * (n + 1)
        for x in nums:
            cnt[x] += 1
        
        factor_cnt = [0] * (n + 1)
        times_cnt = [0] * (n + 1)
        
        for i in range(1, n + 1):
            for j in range(i, n + 1, i):
                factor_cnt[i] += cnt[j]
                times_cnt[j] += cnt[i]
        
        gcd_cnt = factor_cnt[:]
        lcm_cnt = times_cnt[:]
    
        for i in range(n + 1):
            gcd_cnt[i] = gcd_cnt[i] * (gcd_cnt[i] - 1)
            lcm_cnt[i] = lcm_cnt[i] * (lcm_cnt[i] - 1)
        
        for i in range(n, 0, -1):
            for j in range(i * 2, n + 1, i):
                gcd_cnt[i] -= gcd_cnt[j]
        
        for i in range(1, n + 1):
            for j in range(i * 2, n + 1, i):
                lcm_cnt[j] -= lcm_cnt[i]
        
        for i in range(1, n + 1):
            factor_cnt[i] -= cnt[i]
            times_cnt[i] -= cnt[i]
        
        for i in range(n + 1):
            gcd_cnt[i] -= cnt[i] * factor_cnt[i] % mod * 2 % mod + cnt[i] * (cnt[i] - 1) % mod
            gcd_cnt[i] %= mod
            lcm_cnt[i] -= cnt[i] * times_cnt[i] % mod * 2 % mod + cnt[i] * (cnt[i] - 1) % mod
            lcm_cnt[i] %= mod
        
        for i in range(n + 1):
            ans += lcm_cnt[i] * gcd_cnt[i]
            ans %= mod
        
        for i in range(n + 1):
            ans += cnt[i] * gcd_cnt[i] % mod * times_cnt[i] % mod * 2 % mod
            ans %= mod
            ans += cnt[i] * lcm_cnt[i] % mod * factor_cnt[i] % mod * 2 % mod
            ans %= mod
            ans += cnt[i] * (cnt[i] - 1) % mod * gcd_cnt[i] % mod
            ans %= mod
            ans += cnt[i] * (cnt[i] - 1) % mod * lcm_cnt[i] % mod
            ans %= mod
            ans += cnt[i] * (cnt[i] - 1) % mod * factor_cnt[i] % mod * times_cnt[i] % mod * 4 % mod
            ans %= mod
            ans += cnt[i] * (cnt[i] - 1) % mod * (cnt[i] - 2) % mod * (factor_cnt[i] + times_cnt[i]) % mod * 2 % mod
            ans %= mod
            ans += cnt[i] * (cnt[i] - 1) % mod * (cnt[i] - 2) % mod * (cnt[i] - 3) % mod
            ans %= mod
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 1e9 + 7;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &x: nums) cin >> x;

		vector<int> cnt(n + 1, 0);
		for (auto &x: nums) cnt[x] ++;

		vector<long long> factor_cnt(n + 1, 0), times_cnt(n + 1, 0);
		for (int i = 1; i <= n; i ++) {
			for (int j = i; j <= n; j += i) {
				factor_cnt[i] += cnt[j];
				times_cnt[j] += cnt[i];
			}
		}

		vector<long long> gcd_cnt = factor_cnt, lcm_cnt = times_cnt;

		for (int i = 0; i <= n; i ++) {
			gcd_cnt[i] = gcd_cnt[i] * (gcd_cnt[i] - 1);
			lcm_cnt[i] = lcm_cnt[i] * (lcm_cnt[i] - 1);
		}

		for (int i = n; i > 0; i --) {
			for (int j = i * 2; j <= n; j += i) {
				gcd_cnt[i] -= gcd_cnt[j];
			} 
		}

		for (int i = 1; i <= n; i ++) {
			for (int j = i * 2; j <= n; j += i) {
				lcm_cnt[j] -= lcm_cnt[i];
			}
		}

		for (int i = 1; i <= n; i ++) {
			factor_cnt[i] -= cnt[i];
			times_cnt[i] -= cnt[i];

			gcd_cnt[i] -= cnt[i] * factor_cnt[i] % mod * 2 % mod + cnt[i] * (cnt[i] - 1) % mod;
			gcd_cnt[i] = (gcd_cnt[i] % mod + mod) % mod;
			lcm_cnt[i] -= cnt[i] * times_cnt[i] % mod * 2 % mod + cnt[i] * (cnt[i] - 1) % mod;
			lcm_cnt[i] = (lcm_cnt[i] % mod + mod) % mod;
		}

		int ans = 0;

		for (int i = 1; i <= n; i ++) {
			ans += gcd_cnt[i] * lcm_cnt[i] % mod;
			ans %= mod;
			ans += cnt[i] * gcd_cnt[i] % mod * times_cnt[i] % mod * 2 % mod;
			ans %= mod;
			ans += cnt[i] * lcm_cnt[i] % mod * factor_cnt[i] % mod * 2 % mod;
			ans %= mod;
			ans += cnt[i] * (cnt[i] - 1) % mod * gcd_cnt[i] % mod;
			ans %= mod;
			ans += cnt[i] * (cnt[i] - 1) % mod * lcm_cnt[i] % mod;
			ans %= mod;
			ans += cnt[i] * (cnt[i] - 1) % mod * factor_cnt[i] % mod * times_cnt[i] % mod * 4 % mod;
			ans %= mod;
			ans += cnt[i] * (cnt[i] - 1) % mod * (cnt[i] - 2) % mod * (factor_cnt[i] + times_cnt[i]) % mod * 2 % mod;
			ans %= mod;
			ans += cnt[i] * (cnt[i] - 1) % mod * (cnt[i] - 2) % mod * (cnt[i] - 3) % mod;
			ans %= mod;
		}

		cout << ans << '\n';
	}

	return 0;
}
```