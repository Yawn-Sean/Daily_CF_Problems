**提示 1：** 我们相当于要看一个区间内出现过哪些不同的质因数。

**提示 2：** 对于某个固定的左端点而言，我们只在意某个质因子在这个位置后第一次出现的位置。

我们相当于要求一个区间内出现过的质因子的乘积。

对于一个固定的左端点而言，我们只在意每个质因子此后第一次出现的位置，在对应的位置标记。这样我们可以用区间查询区间内标记的所有质数的乘积来解决问题。

我们将查询离线，这样就只需解决上面的东西的维护就行。

考虑从右往左移动左端点，假设从 $i+1$ 移动到 $i$ ，则需要更新的质数就是 $nums[i]$ 的质因子。我们找到这些质因子之前的最早出现位置，将其撤销，也就是除以 $p$ 。最后将这些质数的乘积更新到 $i$ 位置即可。这样每个质因子都标记在了最早出现的位置。而我们的查询就相当于算区间乘积，这是很容易用线段树维护的。

也就是我们从后往前遍历左端点，并且遍历到某个左端点时，解决所有左端点在该位置的查询。

整体而言需要更新 $\mathcal{O}(\log M)$ 个位置，每次更新复杂度是 $\mathcal{O}(\log n)$ 的，查询时只需求区间乘积，所以时间复杂度为 $\mathcal{O}(n\log n\log M+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 2 * 10 ** 5
    pr = list(range(M + 1))
    
    for i in range(2, M + 1):
        if pr[i] == i:
            for j in range(i, M + 1, i):
                pr[j] = i
    
    mod = 10 ** 9 + 7
    
    n, q = MII()
    nums = LII()
    
    queries = [[] for _ in range(n)]
    
    for i in range(q):
        l, r = GMI()
        queries[l].append((i, r))
    
    last_pos = [n] * (M + 1)
    
    def op(x, y): return x * y % mod
    
    seg = SegTree(op, 1, n)
    ans = [0] * q
    
    for i in range(n - 1, -1, -1):
        prs = []
        x = nums[i]
        
        while x > 1:
            p = pr[x]
            prs.append(p)
            
            while x % p == 0:
                x //= p
        
        val = 1
        for p in prs:
            if last_pos[p] < n:
                seg.set(last_pos[p], seg.get(last_pos[p]) // p)
            val *= p
            last_pos[p] = i
        
        seg.set(i, val)
        
        for idx, r in queries[i]:
            ans[idx] = seg.prod(0, r + 1)
    
    print('\n'.join(map(str, ans)))
```

C++ 做法如下——

```cpp []
const int mod = 1e9 + 7;

int op(int x, int y) {return 1ll * x * y % mod;}

int e() {return 1;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 2e5;
	vector<int> pr(M + 1, 0);

	for (int i = 2; i <= M; i ++) {
		if (!pr[i]) {
			for (int j = i; j <= M; j += i) {
				pr[j] = i;
			}
		}
	}

	int n, q;
	cin >> n >> q;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	vector<vector<pair<int, int>>> queries(n);

	for (int i = 0; i < q; i ++) {
		int l, r;
		cin >> l >> r;

		l --, r --;
		queries[l].emplace_back(i, r);
	}

	vector<int> last_pos(M + 1, n);

	atcoder::segtree<int, op, e> seg(n);
	vector<int> ans(q);

	for (int i = n - 1; i >= 0; i --) {
		vector<int> prs;
		int x = nums[i];

		while (x > 1) {
			int p = pr[x];
			prs.emplace_back(p);
			while (x % p == 0) x /= p;
		}

		int val = 1;
		for (auto &p: prs) {
			if (last_pos[p] < n)
				seg.set(last_pos[p], seg.get(last_pos[p]) / p);
			val *= p;
			last_pos[p] = i;
		}

		seg.set(i, val);
		for (auto &[idx, r]: queries[i])
			ans[idx] = seg.prod(0, r + 1);
	}

	for (auto &x: ans) cout << x << '\n';

	return 0;
}
```
