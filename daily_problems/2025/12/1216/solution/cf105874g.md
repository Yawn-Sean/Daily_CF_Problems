**提示 1：** 显然有一个 $\mathcal{O}(n)$ 解决问题的方法。有无别的想法？

**提示 2：** 相当于用了几组 $1$ 隔开了一堆 $0$ 。

首先，考虑单次查询。对于某个固定的 $k$ ，假设长度为 $i$ 的串有 $dp[i]$ 种。考虑其最后一项是 $0$ 还是 $1$ ，如果是 $0$ ，则前面一段的方案数是 $dp[i-1]$ ；如果是 $1$ ，则有一段长度是 $k$ 的 $1$ ，再往前面的方案数是 $dp[i-k]$ ，所以 $dp[i]=dp[i-1]+dp[i-k]$ 。

而如果求 DP 数组的前缀和就可以快速解决对于某个固定的 $k$ 的 $(l,r)$ 查询问题。

有啥别的想法吗？我们将序列视作用一堆长度为 $k$ 的 $1$ 切割一个由 $0$ 构成的序列。

枚举 $1$ 段的个数 $cnt$ ，则剩余的 $0$ 的个数是一个区间 $[l,r]$ ，我们需要用 $cnt+1$ 组 $0$ （每一组数量是非负数），来凑出总共 $[l,r]$ 的个数。

我们先解决 $[1,V]$ 的问题，就可以用 $[1,r]$ 的结果减去 $[1,l-1]$ 的结果来得到答案了。

我们设前 $i$ 组的 $0$ 的个数是 $x_i$ ，则：

$0\leq x_1\leq x_2\leq\dots\leq x_{cnt+1}\leq V$

则：

$1\leq x_1+1\lt x_2+2\lt\dots\lt x_{cnt+1}+(cnt+1)\leq V+cnt+1$ 

我们相当于从 $[1,V+cnt+1]$ 中选取递增的 $cnt+1$ 个数依次赋值给中间的项，就可以一一对应出一种可行的方案。所以总方案数是 $C_{V+cnt+1}^{cnt+1}$ 。

所以此时答案是 $C_{r+cnt+1}^{cnt+1}-C_{l+cnt}^{cnt+1}$ 。组合数在预处理后可以 $\mathcal{O}(1)$ 计算。

此时因为需要枚举 $cnt$ ，而 $cnt$ 是 $\mathcal{O}(\frac{n}{k})$ 量级的，所以复杂度也如此。所以 $k$ 比较大的时候比较适合这种做法。

而 $k$ 较小时可以直接预处理前缀和，所以在 $k\leq\sqrt{n}$ 时，我们用 DP 预处理前缀和， $k\gt\sqrt{n}$ 时，用后面的组合数办法求，复杂度分别是 $\mathcal{O}(n\sqrt{n})$ 和 $\mathcal{O}(q\sqrt{n})$ ，总复杂度符合要求。

总时间复杂度为 $\mathcal{O}((n+q)\sqrt{n})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 2 * 10 ** 5
    mod = 998244353
    
    f = Factorial(M * 2, mod)
    
    saved_dp = [[0] * (M + 1) for _ in range(451)]
    
    for i in range(1, 451):
        saved_dp[i][0] = 1
        
        for j in range(1, M + 1):
            saved_dp[i][j] = saved_dp[i][j - 1]
            if j >= i:
                saved_dp[i][j] += saved_dp[i][j - i]
            saved_dp[i][j] %= mod
        
        for j in range(1, M + 1):
            saved_dp[i][j] += saved_dp[i][j - 1]
            saved_dp[i][j] %= mod
    
    n, q = MII()
    outs = []
    
    for _ in range(q):
        l, r, k = MII()
        if k <= 450:
            outs.append((saved_dp[k][r] - saved_dp[k][l - 1]) % mod)
        else:
            ans = 0
            
            for cnt_k in range(r // k + 1):
                lbound = fmax(l - cnt_k * k, 0) - 1
                rbound = r - cnt_k * k
                
                ans += f.combi(rbound + cnt_k + 1, cnt_k + 1) - f.combi(lbound + cnt_k + 1, cnt_k + 1)
                ans %= mod
            
            outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
const int mod = 998244353;

long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 2e5;
	vector<int> f(M * 2 + 1), g(M * 2 + 1);

	f[0] = 1;
	for (int i = 1; i <= M * 2; i ++) f[i] = 1ll * f[i - 1] * i % mod;
	g[M * 2] = quickPow(f[M * 2], mod - 2, mod);
	for (int i = M * 2; i >= 1; i --) g[i - 1] = 1ll * g[i] * i % mod;

	auto comb = [&] (int x, int y) -> int {
		if (y < 0 || y > x) return 0;
		return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
	};

	auto add = [&] (int &x, int y) -> void {
		x += y;
		if (x >= mod) x -= mod;
	};

	vector<vector<int>> saved_dp(451, vector<int>(M + 1, 0));

	for (int i = 1; i <= 450; i ++) {
		saved_dp[i][0] = 1;

		for (int j = 1; j <= M; j ++) {
			saved_dp[i][j] = saved_dp[i][j - 1];
			if (j >= i) add(saved_dp[i][j], saved_dp[i][j - i]);
		}

		for (int j = 1; j <= M; j ++)
			add(saved_dp[i][j], saved_dp[i][j - 1]);
	}

	int n, q;
	cin >> n >> q;

	while (q --) {
		int l, r, k;
		cin >> l >> r >> k;

		if (k <= 450)
			cout << (saved_dp[k][r] - saved_dp[k][l - 1] + mod) % mod << '\n';
		else {
			int ans = 0;
			for (int cnt_k = 0; cnt_k <= r / k; cnt_k ++) {
				int lbound = max(l - cnt_k * k, 0) - 1;
				int rbound = r - cnt_k * k;

				add(ans, comb(rbound + cnt_k + 1, cnt_k + 1));
				add(ans, mod - comb(lbound + cnt_k + 1, cnt_k + 1));
			}
			cout << ans << '\n';
		}
	}

	return 0;
}
```
