**提示 1：** 操作前后什么是不变的？

**提示 2：** 最后情况如何？

操作前后，相邻两个位置的大小关系不变——因为一旦改变中间一定有过相等的时刻。

因此我们可以根据原有的大小关系，找到一个数组和最小的最终形态。

最终一定是这个情况吗？答案是肯定的，我们选取最小的跟最终形态不相等的元素，这个元素一定可以进行操作。

因此我们只需计算从开始状态到最终状态经历的步数就行，步数等于总和之差，也就只需要考虑前后元素的奇偶性了。

时间复杂度为 $\mathcal{O}(nm\log nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    for _ in range(t):
        n, m = MII()
        grid = [LII() for _ in range(n)]
        
        tmp = []
        res = 0
        
        for i in range(n):
            for j in range(m):
                res ^= grid[i][j] & 1
                tmp.append((grid[i][j] * n + i) * m + j)
        
        tmp.sort()
        
        to_fill = [[-1] * m for _ in range(n)]
        
        for x in tmp:
            msk = x % (n * m)
            i, j = divmod(msk, m)
            
            val = -1
            for di, dj in dirs:
                if 0 <= i + di < n and 0 <= j + dj < m:
                    val = fmax(val, to_fill[i + di][j + dj])
            
            to_fill[i][j] = val + 1
            
            res ^= (val + 1) & 1
        
        outs.append('Yes' if res else 'No')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	vector<pair<int, int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

	while (t --) {
		int n, m;
		cin >> n >> m;

		vector<vector<int>> grid(n, vector<int>(m));
		int res = 0;

		vector<array<int, 3>> tmp;

		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < m; j ++) {
				cin >> grid[i][j];
				res ^= (grid[i][j] & 1);
				tmp.push_back({grid[i][j], i, j});
			}
		}

		sort(tmp.begin(), tmp.end());

		vector<vector<int>> to_fill(n, vector<int>(m, -1));

		for (auto &[v, i, j]: tmp) {
			int val = -1;
			for (auto &[di, dj]: dirs) {
				if (i + di >= 0 && i + di < n && j + dj >= 0 && j + dj < m) {
					val = max(val, to_fill[i + di][j + dj]);
				}
			}

			to_fill[i][j] = val + 1;
			res ^= (val + 1) & 1;
		}

		cout << (res ? "Yes" : "No") << '\n';
	}

	return 0;
}
```