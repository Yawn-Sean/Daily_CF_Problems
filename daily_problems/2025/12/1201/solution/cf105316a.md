**提示 1：** 我们只需要有一个总和足够大的子数组。

**提示 2：** 如何保证不重不漏。

能构成多边形的条件需要每个边都不到总边权的一半。

所以我们预处理总边权，则假设到第 $i$ 位的方案数是 $dp[i]$ ，则转移到 $dp[i]$ 位置的是一段连续区间。我们要将区间和转移到 $dp[i]$ 上，因此多维护下前缀和就行。这个方法没啥写错的空间。

这题也可以使用双指针计算器你不能构成多边形的方案数，维护中间最长的一段的可能情况，然后前后是可以任意切割的。注意这种情况下可能有两段都等于整体权值的一半，即 $[1,1,1,1]$ 的情况，需要特判（蛮容易错）。

时间复杂度为 $\mathcal{O}(n)$ 。下面代码给的是麻烦的做法。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    mod = 10 ** 9 + 7
    
    n = II()
    nums = LII()
    
    pw2 = [1] * n
    for i in range(1, n):
        pw2[i] = pw2[i - 1] * 2 % mod
    
    total = sum(nums)
    
    ans = pw2[n - 1] - 1
    
    cur = 0
    for i in range(n - 1):
        cur += nums[i]
        if cur * 2 >= total:
            ans -= pw2[n - 2 - i]
            ans %= mod
        
        if cur * 2 == total:
            ans += 1
            ans %= mod
    
    cur = 0
    for i in range(n - 1, 0, -1):
        cur += nums[i]
        if cur * 2 >= total:
            ans -= pw2[i - 1]
            ans %= mod
    
    l, r = 0, 0
    cur = 0
    
    while l < n:
        while r < n and cur * 2 < total:
            cur += nums[r]
            r += 1
        
        if l > 0 and r < n:
            ans -= pw2[l - 1] * (pw2[n - r] - 1) % mod
            ans %= mod
        
        cur -= nums[l]
        l += 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mod = 1e9 + 7;
	cin >> n;

	vector<int> nums(n);
	long long total = 0;

	for (auto &x: nums) cin >> x, total += x;

	vector<int> pw2(n);
	pw2[0] = 1;

	for (int i = 1; i < n; i ++)
		pw2[i] = 1ll * pw2[i - 1] * 2 % mod;

	int ans = pw2[n - 1] - 1;

	{
		long long cur = 0;
		for (int i = 0; i < n - 1; i ++) {
			cur += nums[i];
			if (cur * 2 >= total) {
				ans -= pw2[n - 2 - i];
				if (ans < 0) ans += mod;
			}

			if (cur * 2 == total) {
				ans ++;
				if (ans >= mod) ans -= mod;
			}
		}
	}

	{
		long long cur = 0;
		for (int i = n - 1; i > 0; i --) {
			cur += nums[i];
			if (cur * 2 >= total) {
				ans -= pw2[i - 1];
				if (ans < 0) ans += mod;
			}
		}
	}

	{
		int l = 0, r = 0;
		long long cur = 0;

		while (l < n) {
			while (r < n && cur * 2 < total) {
				cur += nums[r];
				r ++;
			}

			if (l && r < n) {
				ans -= 1ll * pw2[l - 1] * (pw2[n - r] - 1) % mod;
				if (ans < 0) ans += mod;
			}

			cur -= nums[l];
			l ++;
		}
	}

	cout << ans;

	return 0;
}
```