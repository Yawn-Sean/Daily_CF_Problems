**提示 1：** 如果一个 $k$ 被修改过了，之后的修改是简单的。

不加修改的是个经典的 DP 。

而加了修改之后，如果一个位置之前改过了，之后从 $x$ 改为 $y$ ，那么最后答案就一定增加 $y-x$ ，因为这个对角线上一定必然经过且只经过一个点。

所以只需在第一次更新某条斜线的时候，更新整个矩阵并计算 DP 结果，后面差量更新就好。需要注意的是更新整个矩阵的时候，需要把之前更新的斜线的信息也更新上去。

时间复杂度为 $\mathcal{O}(n^3+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, q = MII()
        grid = [LII() for _ in range(n)]
        
        saved = [0] * (2 * n - 1)
        dp = [[0] * n for _ in range(n)]
        
        for _ in range(q):
            k, v = MII()
            k -= 2
            
            if saved[k]:
                dp[n - 1][n - 1] += v - saved[k]
                saved[k] = v
            else:
                saved[k] = v
                for i in range(n):
                    for j in range(n):
                        if saved[i + j] > 0:
                            grid[i][j] = saved[i + j]
                        dp[i][j] = grid[i][j]
                
                for i in range(n):
                    for j in range(n):
                        w = 0
                        if i: w = fmax(w, dp[i - 1][j])
                        if j: w = fmax(w, dp[i][j - 1])
                        dp[i][j] += w
            
            outs.append(dp[n - 1][n - 1])
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, q;
		cin >> n >> q;

		vector<vector<int>> grid(n, vector<int>(n));
		for (auto &x: grid) for (auto &y: x) cin >> y;

		vector<int> saved(2 * n - 1, 0);
		vector<vector<long long>> dp(n, vector<long long>(n));

		while (q --) {
			int k, v;
			cin >> k >> v;
			k -= 2;

			if (saved[k]) {
				dp[n - 1][n - 1] += v - saved[k];
				saved[k] = v;
			}
			else {
				saved[k] = v;
				for (int i = 0; i < n; i ++) {
					for (int j = 0; j < n; j ++) {
						if (saved[i + j])
							grid[i][j] = saved[i + j];
						dp[i][j] = grid[i][j];
					}
				}
				for (int i = 0; i < n; i ++) {
					for (int j = 0; j < n; j ++) {
						long long w = 0;
						if (i) w = max(w, dp[i - 1][j]);
						if (j) w = max(w, dp[i][j - 1]);
						dp[i][j] += w;
					}
				}
			}

			cout << dp[n - 1][n - 1] << '\n';
		}
	}

	return 0;
}
```
