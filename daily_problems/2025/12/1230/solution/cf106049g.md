**提示 1：** 假设已经分配好各个组的数值，应该按照什么顺序分配？

**提示 2：** 怎么能做到答案最小化？

首先，假设各个子数组长度从小到大排序后是 $[v_1,v_2,\dots,v_k]$ ，考虑长度为 $v_1$ 的子数组，其数值一定是 $v_1!$ 的倍数（可以考虑组合数 $C_x^{v_1}$ ）。同时，把 $v_1$ 分给第一组可以让最终被取最大公约数的数组中包含 $v_1!$ ，因此最优结果就是 $v_1!$ 。

怎么分呢？

假设分为 $k$ 组，则需要 $[kL,kR]$ 包含 $n$ ，使得这件事最容易满足的 $k$ 应该越大越好，也就是 $\lfloor n/L\rfloor$ 。同时，分组越多，最短的一段也可以最小。因此两个目标都同时指向了最大化 $k$ 。

如果对应的 $k$ 没办法使得 $[kL,kR]$ 包含 $n$ ，则无法构造。

否则从第 $1$ 段到第 $k$ 段，分别取最短的能使得后续能够构造的长度，也就是使得后面留下的长度不超过段数乘 $R$ 。这样一定满足要求（具体可见后面代码）。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    mod = 998244353
    
    for _ in range(t):
        n, l, r = MII()
        block_cnt = n // l
        
        if block_cnt * r < n: outs.append('-1')
        else:
            ans = []
            for i in range(block_cnt):
                v = fmax(l, n - (block_cnt - 1 - i) * r)
                n -= v
                ans.append(v)
            
            v = 1
            for i in range(1, ans[0] + 1):
                v = v * i % mod
            
            outs.append(f'{len(ans)} {v}')
            
            cur = 1
            for x in ans:
                outs.append(f'{cur} {cur + x - 1}')
                cur += x
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 998244353;
	cin >> t;

	while (t --) {
		long long n, l, r;
		cin >> n >> l >> r;

		long long block_cnt = n / l;
		if (block_cnt * r < n) cout << "-1\n";
		else {
			vector<int> ans;
			for (int i = 1; i <= block_cnt; i ++) {
				long long v = max(l, n - (block_cnt - i) * r);
				n -= v;
				ans.emplace_back(v);
			}

			int res = 1;
			for (int i = 1; i <= ans[0]; i ++) res = 1ll * res * i % mod;

			cout << block_cnt << ' ' << res << '\n';
			int cur = 1;

			for (auto &x: ans) {
				cout << cur << ' ' << cur + x - 1 << '\n';
				cur += x;
			}
		}
	}

	return 0;
}
```
