**提示 1：** 把所有可获得的咖啡认为是成本为 $1$ 的。则我们需要计算 $1$ 类型咖啡的最低成本。

**提示 2：** 一定存在一个无环路径走向 $1$ ，路径长度不超过 $n$ ，所以可以……

我们认为我们有 $v$ 单位的钱，每单位的钱可以获得一单位的可获得咖啡，则我们要求 $1$ 类型咖啡的最低成本。

考虑从可获取咖啡到合成 $1$ 类型咖啡的路径，该路径一定不会重复合成已经有的咖啡——因为直观上来讲 $c_i\lt a_i+b_i$ ，绕回去一定得不偿失。

所以从可获取咖啡到第一类型的咖啡的路径中一定不会合成已经合成过的咖啡。因此到第一类型咖啡的步骤不会超过 $n$ 轮。

所以直接用类似最短路的方式进行松弛，即用 $ax+by$ 更新 $z$ 的成本即可（这里可以进一步印证得不偿失的结论，因为合成的东西的成本一定不小于原料的成本，绕一圈肯定成本更高）。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, m, v = MII()
        s = I()
        transactions = []
        
        for _ in range(m):
            a, x, b, y, c, z = MII()
            x -= 1
            y -= 1
            z -= 1
            transactions.append((a, x, b, y, c, z))
        
        cost = [-1] * n
        for i in range(n):
            if s[i] == '1':
                cost[i] = 1
        
        for _ in range(n):
            for a, x, b, y, c, z in transactions:
                if cost[x] != -1 and cost[y] != -1:
                    if cost[z] == -1: cost[z] = a * cost[x] + b * cost[y]
                    else: cost[z] = fmin(cost[z], a * cost[x] + b * cost[y])
        
        outs.append(v / cost[0] if cost[0] != -1 else 0)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> acc(n + 1);
		for (int i = 1; i <= n; i ++) {
			cin >> acc[i];
			acc[i] += acc[i - 1];
		}

		long long ans = 0;
		vector<int> stk = {n + 1};
		vector<long long> stk_acc = {0};

		for (int i = n; i >= 0; i --) {
			while (stk.back() != n + 1 && acc[i] > acc[stk.back()]) {
				stk_acc.pop_back();
				stk.pop_back();
			}

			stk_acc.emplace_back(stk_acc.back() + 1ll * (stk.back() - i) * acc[i]);
			stk.emplace_back(i);

			ans += stk_acc.back() - 1ll * (n + 1 - i) * acc[i];
		}

		cout << ans << '\n';
	}

	return 0;
}
```