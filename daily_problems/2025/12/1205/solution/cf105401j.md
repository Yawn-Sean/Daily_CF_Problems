**提示 1：** 实际上只需要三个方向就一定能覆盖任何一个位置了。

**提示 2：** 一个方向和两个方向的有啥情况呢？怎么构造呢？

首先，为了覆盖整个坐标系，我们只需要 $(-1,-1),(0,1),(1,0)$ 就够了，因为我们总能退回到超小的负数，再一步步走到需要的点。

所以答案不超过 $3$ ，接下来讨论答案是 $1,2$ 的情况。

答案是 $1$ 的情况，因为只能走一个方向，所以一定在一条以原点为端点的射线上，这条射线的方向可以根据输入的点确定。

否则，答案最小为 $2$ 。

如果构造的两个向量反向，则可以到达的位置只可能是这条直线上，所以在输入的点是经过原点的直线时，只需考虑正反两个方向作为答案即可。

否则，构造的两个向量夹角严格小于 $180$ 度。此时覆盖的区域是一个半平面的真子集。所以当输入的方向极角范围超过 $180$ 度时，直接输出 $3$ 的情况。

如何判断极角范围是否超过 $180$ 度？我们可以假设不超过，然后找到逆时针方向最靠前的方向向量，再对比别的向量是否都在这个向量的逆时针方向的 $180$ 度内，这样就可以 $\mathcal{O}(n)$ 完成任务了。

不然的话就一定可以构造答案。我们要想办法覆盖一个半平面的所有的点。两个向量一定在给出的所有方向的外侧。

不妨取第一个向量是逆时针方向的最靠前的向量，可以让 $x,y$ 除以最大公约数使得它们互质。

则这个半平面内的所有点和这个方向向量的叉乘结果都至少为 $1$ （本身跟 $(x,y)$ 同向的向量外）。

我们设构造的两个向量一个就是刚刚提到的 $(x,y)$ ，另一个是 $(nx,ny)$ ，则最后走到的方向一定是 $(k_1x+k_2nx,k_1y+k_2ny)$ ，这个方向向量和 $(x,y)$ 的叉乘恰好是 $(nx,ny)$ 和 $(x,y)$ 叉乘的 $k_2$ 倍。而这个数值可以取到任意正整数，所以我们的 $(nx,ny)$ 不得不和 $(x,y)$ 叉乘结果是 $1$ ，即 $|x\times ny-y\times nx|=1$ ，这个方程的求解需要使用拓展欧几里得。

如果我们找到了这个方向向量，其余所有这个半平面的方向向量都能用 $(x,y),(nx,ny)$ 线性表出了吗？答案是肯定的。我们先用 $(nx,ny)$ 凑到叉乘结果正确的那条平行线上，再用 $(x,y)$ 平移到对应位置。

而题目中要求我们只能往正方向走，所以我们 $(nx,ny)$ 可以加上 $-K(x,y)$ ，让后续 $(x,y)$ 的调整一定是正方向的。这样得到了 $(x,y),(nx',ny')$ 。

而走的步骤是，按照和 $(x,y)$ 叉乘数值从小到大的顺序一个个走，如果叉乘结果一致，则根据点乘结果从小到大走。如果叉乘结果小了就用 $(nx,ny)$ 调整，一旦调整，下一步需要走 $(x,y)$ 一定有重组的空间；否则，不断往 $(x,y)$ 方向走，就一定能走到这条平行线上的所需位置（因为 $x,y$ 互质，不会漏掉整数点）。

时间复杂度为 $\mathcal{O}(n+\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    LARGE = 10 ** 9
    
    for _ in range(t):
        n = II()
        xs = []
        ys = []
        
        dx, dy = 0, 0
        
        for _ in range(n):
            x, y = MII()
            
            if x or y:
                xs.append(x)
                ys.append(y)
        
        n = len(xs)
        
        dx, dy = xs[0], ys[0]
        g = abs(math.gcd(dx, dy))
        dx //= g
        dy //= g
        
        flg1 = True
        flg2 = True
        for i in range(n):
            if dx * ys[i] != dy * xs[i]:
                flg1 = False
            if dx * xs[i] < 0 or dy * ys[i] < 0:
                flg2 = False
        
        if flg1:
            if flg2:
                outs.append('1')
                outs.append(f'{dx} {dy}')
            else:
                outs.append('2')
                outs.append(f'{dx} {dy}')
                outs.append(f'{-dx} {-dy}')
        else:
            x, y = xs[0], ys[0]
            
            for i in range(1, n):
                nx, ny = xs[i], ys[i]
                if nx * y > ny * x: x, y = nx, ny
            
            flg = True
            for i in range(n):
                nx, ny = xs[i], ys[i]
                if nx * y > ny * x or (nx * y == ny * x and (x * nx < 0 or y * ny < 0)):
                    flg = False
            
            if flg:
                g = math.gcd(x, y)
                x //= g
                y //= g
    
                if y == 0:
                    nx = 0
                    ny = x
                else:
                    ny = pow(x, -1, y)
                    nx = (x * ny - 1) // y
                    if nx * y > ny * x:
                        nx = -nx
                        ny = -ny
                
                outs.append('2')
                outs.append(f'{x} {y}')
                outs.append(f'{nx - LARGE * x} {ny - LARGE * y}')
            else:
                outs.append('3')
                outs.append('1 0')
                outs.append('0 1')
                outs.append('-1 -1')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, LARGE = 1e9;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<pair<int, int>> pts;
		for (int i = 0; i < n; i ++) {
			int x, y;
			cin >> x >> y;
			if (x || y) pts.emplace_back(x, y);
		}

		n = pts.size();

		{
			auto [dx, dy] = pts[0];
			int g = abs(gcd(dx, dy));
			dx /= g;
			dy /= g;

			bool flg1 = true, flg2 = true;
			for (auto &[x, y]: pts) {
				if (1ll * dx * y != 1ll * dy * x) flg1 = false;
				if (1ll * dx * x < 0 || 1ll * dy * y < 0) flg2 = false;
			}

			if (flg1) {
				if (flg2) {
					cout << "1\n";
					cout << dx << ' ' << dy << '\n';
				}
				else {
					cout << "2\n";
					cout << dx << ' ' << dy << '\n';
					cout << -dx << ' ' << -dy << '\n';
				}
				continue;
			}
		}

		{
			auto [x, y] = pts[0];
			for (int i = 1; i < n; i ++) {
				auto [nx, ny] = pts[i];
				if (1ll * nx * y > 1ll * ny * x)
					x = nx, y = ny;
			}

			bool flg = true;

			for (int i = 0; i < n; i ++) {
				auto [nx, ny] = pts[i];
				if (1ll * nx * y > 1ll * ny * x || (1ll * nx * y == 1ll * ny * x && (1ll * x * nx < 0 || 1ll * y * ny < 0))) {
					flg = false;
				}
			}

			if (flg) {
				int g = abs(gcd(x, y));
				x /= g;
				y /= g;

				int nx, ny;
				if (!y)
					nx = 0, ny = x;
				else {
					ny = atcoder::internal::inv_gcd(x, abs(y)).second;
					nx = (1ll * x * ny - 1) / y;
					if (1ll * nx * y > 1ll * ny * x)
						nx = -nx, ny = -ny;
				}

				cout << "2\n";
				cout << x << ' ' << y << '\n';
				cout << nx - 1ll * LARGE * x << ' ' << ny - 1ll * LARGE * y << '\n';
			}
			else {
				cout << "3\n";
				cout << "0 1\n";
				cout << "1 0\n";
				cout << "-1 -1\n";
			}
		}
	}

	return 0;
}
```