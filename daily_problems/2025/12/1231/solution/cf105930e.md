**提示 1：** 最后答案需要满足什么条件？

**提示 2：** 如何快速检查可能的答案？

首先，在最终状态下所有数的和是确定的，也就是原本的和加上 $k$ ，所以最终答案一定是这个数的约数。

于是我们枚举可能的答案，如果我们能快速检查，也就解决了问题。

对于某个数 $x$ ，如果最后每个数都是它的倍数，那么我们每个数需要先变成不小于自身的最小的 $x$ 的倍数，最后把剩余的所有数全部加到一个数头上就行。而满足条件的 $x$ 的最大值就是答案。

我们相当于要 $1\sim x$ 变成 $x$ ， $x+1\sim 2x$ 变成 $2x$ ，以此类推，最后看凑成的数组的和是否超过了最终要求的数组和。

所以当 $x$ 不超过 $M$ （当前数组最大值）时，我们需要进行的区间计算是 $\mathcal{O}(M/x)$ 次的，因此对于不超过 $M$ 的部分，这些累加的结果可以用调和级数推导，是 $\mathcal{O}(M\log M)$ 的。

而如果 $x$ 比 $M$ 还大，则直接每个数都必须变成 $x$ ，直接得到 $nx$ 是最终需要比较的数组和。

综上，时间复杂度为 $\mathcal{O}(\sqrt{nM+k}+M\log M+n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, k = MII()
        nums = LII()
        
        ma = max(nums)
        acc_cnt = [0] * (ma + 1)
        
        for x in nums:
            acc_cnt[x] += 1
        
        for i in range(ma):
            acc_cnt[i + 1] += acc_cnt[i]
        
        total = sum(nums) + k
        
        def check(x):
            if x >= ma: return acc_cnt[ma] * x <= total
            
            val = 0
            for i in range(0, ma + 1, x):
                l = i
                r = fmin(i + x, ma)
                val += (acc_cnt[r] - acc_cnt[l]) * (i + x)
            
            return val <= total
    
        ans = 0
        
        for i in range(1, 10 ** 6 * 2):
            if i * i > total: break
            if total % i == 0:
                if check(i): ans = fmax(ans, i)
                if check(total // i): ans = fmax(ans, total // i)
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		long long k;
		cin >> n >> k;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		int ma = *max_element(nums.begin(), nums.end());
		vector<int> acc_cnt(ma + 1, 0);
		long long total = k;

		for (auto &x: nums) {
			total += x;
			acc_cnt[x] ++;
		}

		for (int i = 1; i <= ma; i ++)
			acc_cnt[i] += acc_cnt[i - 1];

		auto check = [&] (long long x) -> bool {
			if (x >= ma) return x * acc_cnt[ma] <= total;
			long long val = 0;
			for (int i = 0; i <= ma; i += x)
				val += (acc_cnt[min(i + x, (long long)ma)] - acc_cnt[i]) * (i + x);
			return val <= total;
		};

		long long ans = 0;

		for (long long i = 1; i * i <= total; i ++) {
			if (total % i == 0) {
				if (check(i)) ans = max(ans, i);
				if (check(total / i)) ans = max(ans, total / i);
			}
		}

		cout << ans << '\n';
	}

	return 0;
}
```
