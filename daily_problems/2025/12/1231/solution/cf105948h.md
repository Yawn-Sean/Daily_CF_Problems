**提示 1：** 考虑每个元素的贡献。

**提示 2：** 想想什么判断条件的方式比较容易。

考虑第 $i$ 个元素在 $k$ 长度子数组中的贡献。

则我们需要 $i$ 比这 $k$ 个包含它的元素的均值要大。也就等价于比其他 $k-1$ 个元素的均值要小。

所以综上，比较重要的信息是，选取 $k$ 个元素且和为 $V$ 的方案数有多少种，这件事很容易用背包预处理，时间复杂度为 $\mathcal{O}(n^4)$ 。

接下来怎么对于 $i$ 计算结果呢？我们的背包的逻辑是可以撤销一步的，所以我们计算去掉 $i$ 元素的情况下，选取 $k$ 个元素且和为 $V$ 的方案数。然后需要满足的条件就是 $V$ 大于 $k$ 个 $nums[i]$ 。撤销一个元素的复杂度是 $\mathcal{O}(n^3)$ 。

最后再把达标率对应的 $\frac{1}{m}$ ，以及任选子序列的 $C(n,k)$ 除掉就好。

综上，时间复杂度为 $\mathcal{O}(n^4)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    mod = 998244353
    
    f = Factorial(n, mod)
    
    dp = [[0] * (n * n + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    
    for i in range(n):
        for j in range(i, -1, -1):
            for k in range(n * n + 1):
                if dp[j][k]:
                    dp[j + 1][k + nums[i]] += dp[j][k]
                    dp[j + 1][k + nums[i]] %= mod
    
    ans = [0] * (n + 1)
    
    for v in nums:
        for j in range(n):
            for k in range(n * n + 1):
                if dp[j][k]:
                    dp[j + 1][k + v] -= dp[j][k]
                    dp[j + 1][k + v] %= mod
        
        for j in range(1, n):
            for k in range(n * n + 1):
                if j * v > k:
                    ans[j + 1] += dp[j][k]
                    ans[j + 1] %= mod
        
        for j in range(n - 1, -1, -1):
            for k in range(n * n + 1):
                if dp[j][k]:
                    dp[j + 1][k + v] += dp[j][k]
                    dp[j + 1][k + v] %= mod
    
    for i in range(2, n + 1):
        ans[i] = ans[i] * f.combi_inv(n, i) % mod * f.inv(i) % mod
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	int mod = 998244353;
	
	vector<int> f(n + 1), g(n + 1);

	f[0] = 1;
	for (int i = 1; i <= n; i ++) f[i] = 1ll * f[i - 1] * i % mod;
	g[n] = quickPow(f[n], mod - 2, mod);
	for (int i = n; i >= 1; i --) g[i - 1] = 1ll * g[i] * i % mod;

	auto add = [&] (int &x, int y) -> void {
		x += y;
		if (x >= mod) x -= mod;
	};

	auto minus = [&] (int &x, int y) -> void {
		x -= y;
		if (x < 0) x += mod;
	};

	auto comb_inv = [&] (int x, int y) -> int {
		return 1ll * g[x] * f[y] % mod * f[x - y] % mod;
	};

	auto inv = [&] (int x) -> int {
		return 1ll * f[x - 1] * g[x] % mod;
	};

	vector<vector<int>> dp(n + 1, vector<int>(n * n + 1, 0));
	dp[0][0] = 1;

	for (int i = 0; i < n; i ++) {
		for (int j = i; j >= 0; j --) {
			for (int k = 0; k <= n * n; k ++) {
				if (dp[j][k]) {
					add(dp[j + 1][k + nums[i]], dp[j][k]);
				}
			}
		}
	}

	vector<int> ans(n + 1);

	for (auto &v: nums) {
		for (int j = 0; j < n; j ++) {
			for (int k = 0; k <= n * n; k ++) {
				if (dp[j][k]) {
					minus(dp[j + 1][k + v], dp[j][k]);
				}
			}
		}

		for (int j = 1; j < n; j ++) {
			for (int k = 0; k <= n * n; k ++) {
				if (j * v > k) {
					add(ans[j + 1], dp[j][k]);
				}
			}
		}

		for (int j = n - 1; j >= 0; j --) {
			for (int k = 0; k <= n * n; k ++) {
				if (dp[j][k]) {
					add(dp[j + 1][k + v], dp[j][k]);
				}
			}
		}
	}

	for (int i = 2; i <= n; i ++)
		cout << 1ll * ans[i] * comb_inv(n, i) % mod * inv(i) % mod << ' ';

	return 0;
}
```
