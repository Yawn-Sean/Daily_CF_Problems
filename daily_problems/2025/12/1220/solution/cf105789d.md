**提示 1：** 很多边都没意义。

**提示 2：** 块和块的相连如何快速更新一个块？

每条边的权值可以认为是端点的点权的最大值，这意味着走这条边， $f(u,v)$ 就得根据这个数值进行更新。

而事实上我们从 $u$ 走到 $v$ 只需要经过这些边的最小生成树。可以考虑按照边权排序，越靠前且有用（即连结不同连通块的边）肯定得要。所以也就是最小生成树。

但我们要求的是权值和，怎么办？

考虑上述构造最小生成树的过程，我们相当于在连结两个连通块的时候，对其中一个连通块的全体加上另一个连通块的大小乘边权。

这件事你可以考虑用启发式合并做，对合并后的连通块用懒更新，而小的连通块进行相对懒更新的调整，但是有复杂度更低的做法。

我们尝试让合并的两个连通块 “更分开一点”，这样就更容易区别处理。我们在合并连通块的时候建立一个虚拟结点，这样我们总共 $n-1$ 次合并后就形成了一棵有 $2n-1$ 个结点的图（每次合并连通块相当于建立一个虚拟结点连两条边）。

这样，每个结点所求的数值怎么求呢？考虑从 $u$ 到 $v$ 的权值，发现就是 LCA 位置的权值。所以我们相当于要求 $u$ 和其他所有点的 LCA 的权值和。

这件事怎么算呢？直接 DFS / BFS 就行，每次从 $u$ 转移到其子节点 $v$ 时，只需将 $u$ 本身对应的数值和 $u$ 的其他子树的大小乘 $u$ 的权值更新到 $v$ 上去，就是新增的 LCA 权值和（其他的 LCA 还在 $v$ 对应的子树内）。

时间复杂度为 $\mathcal{O}(n+m\log m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    nums = LII()
    
    us = []
    vs = []
    
    for _ in range(m):
        u, v = GMI()
        us.append(u)
        vs.append(v)
    
    st_range = sorted(range(m), key=lambda x: fmax(nums[us[x]], nums[vs[x]]))
    
    path = [[] for _ in range(2 * n - 1)]
    pt = n
    
    uf = UnionFind(n)
    notes = list(range(n))
    
    for i in st_range:
        u = us[i]
        v = vs[i]
        
        if uf.find(u) != uf.find(v):
            path[pt].append(notes[uf.find(u)])
            path[pt].append(notes[uf.find(v)])
            uf.merge(u, v)
            notes[uf.find(u)] = pt
            pt += 1
    
    val = [0] * (2 * n - 1)
    sz = [0] * (2 * n - 1)
    for i in range(n):
        sz[i] = 1
        val[i] = nums[i]
    
    for u in range(n, 2 * n - 1):
        for v in path[u]:
            sz[u] += sz[v]
            val[u] = fmax(val[u], val[v])
    
    ans = [0] * (2 * n - 1)
    
    que = [2 * n - 2]
    for u in que:
        for v in path[u]:
            ans[v] = ans[u] + (sz[u] - sz[v]) * val[u]
            que.append(v)
    
    for i in range(n):
        ans[i] += val[i]
    
    print(*ans[:n])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	vector<pair<int, int>> edges(m);
	for (auto &[u, v]: edges) {
		cin >> u >> v;
		u --, v --;
	}

	sort(edges.begin(), edges.end(), [&] (pair<int, int> &x, pair<int, int> &y) {
		return max(nums[x.first], nums[x.second]) < max(nums[y.first], nums[y.second]);
	});

	atcoder::dsu uf(n);
	vector<vector<int>> path(2 * n - 1);
	vector<int> notes(n);
	
	iota(notes.begin(), notes.end(), 0);
	int pt = n;

	for (auto &[u, v]: edges) {
		if (uf.leader(u) != uf.leader(v)) {
			path[pt].emplace_back(notes[uf.leader(u)]);
			path[pt].emplace_back(notes[uf.leader(v)]);
			uf.merge(u, v);
			notes[uf.leader(u)] = pt;
			pt ++;
		}
	}

	vector<int> val(2 * n - 1, 0), sz(2 * n - 1, 0);

	auto dfs1 = [&] (auto &self, int u) -> void {
		if (u < n) sz[u] = 1, val[u] = nums[u];
		for (auto &v: path[u]) {
			self(self, v);
			sz[u] += sz[v];
			val[u] = max(val[u], val[v]);
		}
	};

	dfs1(dfs1, 2 * n - 2);

	vector<long long> ans(2 * n - 1, 0);

	auto dfs2 = [&] (auto &self, int u) -> void {
		if (u < n) ans[u] += nums[u];
		for (auto &v: path[u]) {
			ans[v] = ans[u] + 1ll * (sz[u] - sz[v]) * val[u];
			self(self, v);
		}
	};

	dfs2(dfs2, 2 * n - 2);

	for (int i = 0; i < n; i ++) cout << ans[i] << ' ';

	return 0;
}
```
