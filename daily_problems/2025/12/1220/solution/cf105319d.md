**提示 1：** 一个数组完全排好序等价于所有相邻的两项都排好序。

**提示 2：** 对于某一组相邻的两项 $x$ 需要满足的条件如何呢？

如果一个子数组需要满足要求，相当于任何相邻的两个元素满足要求。

而 $a_i,a_{i+1}$ 异或上 $x$ 之后是升序的，我们只需看 $a_i$ 和 $a_{i+1}$ 从高到低的第一个不同的位（可以异或后提取整个数字的位数得到）。如果原来就是升序， $x$ 这一位只能是 $0$ ，否则只能是 $1$ 。

这就相对来说是个很好判的条件了。而一旦对同一个数位提出两种不同的要求，则一定无法构造出对应的 $x$ 。

而这题而言，子数组新增元素肯定更不容易满足要求，删去元素更容易符合要求，因此可以考虑使用双指针。

我们可以在维护双指针的过程中，记录每一位需要满足的 $0$ 条件和 $1$ 条件的个数，这样就可以在移动指针中快速维护，并且在维护的过程中，可以快速对比更新的位置判断是否仍然符合要求，因此整体移动一个指针的复杂度是 $\mathcal{O}(1)$ 的。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    l, r = 0, 0
    ans = 0
    
    c0 = [0] * 30
    c1 = [0] * 30
    
    while l < n:
        while r + 1 < n:
            v = (nums[r] ^ nums[r + 1]).bit_length() - 1
            if v >= 0:
                if nums[r] >> v & 1:
                    if c0[v]: break
                    c1[v] += 1
                else:
                    if c1[v]: break
                    c0[v] += 1
            r += 1
        
        ans += r - l + 1
        if l + 1 < n:
            v = (nums[l] ^ nums[l + 1]).bit_length() - 1
            if v >= 0:
                if nums[l] >> v & 1: c1[v] -= 1
                else: c0[v] -= 1
        l += 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	int l = 0, r = 0;
	long long ans = 0;

	vector<int> c0(30, 0), c1(30, 0);

	while (l < n) {
		while (r + 1 < n) {
			if (nums[r] ^ nums[r + 1]) {
				int v = 31 - __builtin_clz(nums[r] ^ nums[r + 1]);
				if (v >= 0) {
					if (nums[r] >> v & 1) {
						if (c0[v]) break;
						c1[v] ++;
					}
					else {
						if (c1[v]) break;
						c0[v] ++;
					}
				}
			}
			r ++;
		}

		ans += r - l + 1;
		if (l + 1 < n && nums[l] != nums[l + 1]) {
			int v = 31 - __builtin_clz(nums[l] ^ nums[l + 1]);
			if (v >= 0) {
				if (nums[l] >> v & 1) c1[v] --;
				else c0[v] --;
			}
		}
		l ++;
	}

	cout << ans;

	return 0;
}
```
