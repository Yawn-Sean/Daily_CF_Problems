**提示 1：** 考虑找到 $0$ 所在块的左右边界。

**提示 2：** 想办法不要让更多的块影响你的判断。

考虑 $0$ 所在的块的左右边界。

那我们得先查询 $0$ 对应的颜色。不妨设为白色。

我们先考虑如何求右侧边界。则右侧应该是一段部分的白色，一段完整的黑色，依次往后。（注意一定有完整的黑色，因为题目保证了范围内有至少 $5$ 段颜色。）

我们如果找到了一个第二段的黑色的格点，则利用二分显然可以快速找到 $0$ 所在的白色段的右端点。那么怎么找到第二段的黑色位置呢？

这里有个重点是，第一段白色的长度不超过第二段的黑色。所以我们不断找第 $1,2,2^2,\dots$ 个位置，其中第一个黑色的一定在第一段黑色中。因此，问题就解决了。

这段白色的左端点也是类似的处理。我们先倍增再二分，查询次数都是对数量级的，所以查询次数是 $\mathcal{O}(\log M)$ 的。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def query(x):
        print('?', x, flush=True)
        return I() == 'W'
    
    def answer(x):
        print('!', x, flush=True)
    
    t = II()
    for _ in range(t):
        orig = query(0)
        
        length = 1
        while query(2 * length - 1) == orig:
            length *= 2
        
        l, r = length - 1, 2 * length - 2
        while l <= r:
            mid = (l + r) // 2
            if query(mid) == orig: l = mid + 1
            else: r = mid - 1
        
        rbound = r
        
        length = 1
        while query(-2 * length + 1) == orig:
            length *= 2
        
        l, r = -2 * length + 2, -length + 1
        while l <= r:
            mid = (l + r) // 2
            if query(mid) == orig: r = mid - 1
            else: l = mid + 1
        
        lbound = l
        
        answer(rbound - lbound + 1)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	auto query = [&] (long long x) -> bool {
		cout << "? " << x << endl;
		char c; cin >> c;
		return c == 'W';
	};

	auto answer = [&] (long long x) -> void {
		cout << "! " << x << endl;
	};

	while (t --) {
		auto orig = query(0);
		long long lbound, rbound;

		{
			long long length = 1;
			while (query(2 * length - 1) == orig) length <<= 1;

			long long l = length - 1, r = 2 * length - 2;
			while (l <= r) {
				long long mid = (l + r) / 2;
				if (query(mid) == orig) l = mid + 1;
				else r = mid - 1;
			}

			rbound = r;
		}
		
		{
			long long length = 1;
			while (query(-2 * length + 1) == orig) length <<= 1;

			long long l = -2 * length + 2, r = -length + 1;
			while (l <= r) {
				long long mid = (l + r) / 2;
				if (query(mid) == orig) r = mid - 1;
				else l = mid + 1;
			}
			
			lbound = l;
		}

		answer(rbound - lbound + 1);
	}

	return 0;
}
```