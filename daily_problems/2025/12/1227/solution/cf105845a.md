**提示 1：** 用一个变量代表当前的状态。

**提示 2：** 状态是如何转移的？应该如何由此推到初始状态和结束状态的关系。

这题表面上操作后的状态特别多，因为每个队伍都有一定的人数，相互组合肯定很庞大。而这题既然可做一定有一个很好的方式来概括当前的状态。

事实上，我们考虑：当前状态至少需要多少次操作到达最终状态。即，此时每条队伍为 $v_1,v_2,\dots,v_n$ ，则我们取变量 $X=\max(a_1-v_1,a_2-v_2,\dots,a_n-v_n)$ ，我们初始的 $X=\max a_i$ ，最终的状态是 $X=0$ 。

这个状态转移好考虑吗？实际上是肯定的。

假设当前状态是 $X$ ，如果操作了第 $i$ 个队列，那么上述最大值怎么改变呢？别的项都减少 $1$ ，就第 $i$ 项重置为 $a_i$ ，因此会变成 $\max(X-1,a_i)$ 。

因此这个状态就足够概括解决问题需要的全部信息。

考虑 $a_i$ 将各个状态分为一段一段的，则上述转移在不同段之间是有差异的，一段段转移即可。

是根据 $f(x)=\frac{1}{n}\sum f(\max(x-1,a_i))+1$ ，推出 $f(x-1)=kf(x)+一堆更大的f(x')+b$ 。

我们不妨设 $f(\max a_i)$ 是 $V$ ，则每一个 $f(x)$ 都可以用 $V$ 的一次函数表示，从后往前，维护 $f(x')$ 的和，则每一段的递推都是类似 $a_{x-1}=Aa_x+B$ 的形式，这个形式可以用矩阵快速幂 / 不动点法 + 快速幂快速完成一段的递推。

具体而言，找到 $x=Ax+B$ 的解 $x_0$ ，则 $a_{x-1}-x_0=A(a_x-x_0)$ ，这样就得到了一段等比数列，快速幂就能得到这一段开头的结果了。

最后，根据 $f(0)=0$ ，求解关于 $V$ 的方程就能得到答案了。

时间复杂度为 $\mathcal{O}(n\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    mod = 10 ** 9 + 7
    
    f = Factorial(n, mod)
    
    nums.sort()
    cnt = [0] * n
    
    for x in nums:
        cnt[bisect.bisect_left(nums, x)] += 1
    
    revn = pow(n, -1, mod)
    
    last_k, last_b = 0, 0
    k, b = 0, 0
    cur = -1
    resid = n
    
    for i in range(n - 1, -1, -1):
        if cnt[i]:
            if cur == -1:
                last_k, last_b = 1, 0
            else:
                rev_resid = f.inv(resid)
                vk = n * rev_resid % mod
                rev_vk_1 = pow(vk - 1, -1, mod)
                pw_vk = pow(vk, cur - nums[i], mod)
                
                vb = (mod - k) * rev_resid % mod
                fix = (mod - vb) * rev_vk_1 % mod
                last_k = ((last_k - fix) * pw_vk + fix) % mod
                
                vb = (mod - (n + b) % mod) * rev_resid % mod
                fix = (mod - vb) * rev_vk_1 % mod
                last_b = ((last_b - fix) * pw_vk + fix) % mod
            
            k = (k + last_k * cnt[i]) % mod
            b = (b + last_b * cnt[i]) % mod
            cur = nums[i]
            
            resid -= cnt[i]
    
    print((mod - last_b) * pow(last_k, -1, mod) % mod)
```

C++ 做法如下——

```cpp []
long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mod = 1e9 + 7;
	cin >> n;

	vector<long long> nums(n);
	for (auto &x: nums) cin >> x;

	vector<int> f(n + 1), g(n + 1);
	f[0] = 1;
	for (int i = 1; i <= n; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;
	g[n] = quickPow(f[n], mod - 2, mod);
	for (int i = n; i >= 1; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	sort(nums.begin(), nums.end());
	vector<int> cnt(n, 0);

	for (auto &x: nums)
		cnt[lower_bound(nums.begin(), nums.end(), x) - nums.begin()] ++;

	int revn = 1ll * f[n - 1] * g[n] % mod;

	int last_k = 0, last_b = 0;
	int k = 0, b = 0;
	long long cur = -1;
	int resid = n;

	for (int i = n - 1; i >= 0; i --) {
		if (cnt[i]) {
			if (cur == -1)
				last_k = 1, last_b = 0;
			else {
				int rev_resid = 1ll * f[resid - 1] * g[resid] % mod;
				int vk = 1ll * n * rev_resid % mod;
				int rev_vk_1 = quickPow(vk - 1, mod - 2, mod);
				int pw_vk = quickPow(vk, cur - nums[i], mod);

				int vb, fix;
				vb = 1ll * (mod - k) * rev_resid % mod;
				fix = 1ll * (mod - vb) * rev_vk_1 % mod;
				last_k = (1ll * (last_k - fix + mod) % mod * pw_vk % mod + fix) % mod;

				vb = 1ll * (mod - (n + b) % mod) * rev_resid % mod;
				fix = 1ll * (mod - vb) * rev_vk_1 % mod;
				last_b = (1ll * (last_b - fix + mod) % mod * pw_vk % mod + fix) % mod;
			}
			k = (1ll * last_k * cnt[i] + k) % mod;
			b = (1ll * last_b * cnt[i] + b) % mod;
			cur = nums[i];
			resid -= cnt[i];
		}
	}

	cout << 1ll * (mod - last_b) * quickPow(last_k, mod - 2, mod) % mod;

	return 0;
}
```
