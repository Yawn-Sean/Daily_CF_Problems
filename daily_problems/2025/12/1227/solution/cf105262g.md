**提示 1：** 找回文的子数组显然用 Manacher 。

**提示 2：** 考虑每个元素对最终结果的贡献。

对称子数组就是回文子数组，因此可以用 Manacher 得到每个中心位置对应的回文串。

接下来考虑每个位置的对最终结果的贡献。

考虑 $idx$ 为中心的最长回文子数组是 $[l,r]$ ，则 $[l,r],[l+1,r-1],\dots$ 这些都得在最终结果中算一遍，因此每个位置的权值分别是 $1,2,3,\dots,3,2,1$ ，我们只要能更新这个权值，则对于所有中心都更新一遍，就可以得到某个位置的总权值，乘以数值再相加就是答案了。

这个怎么更新呢？我们看成更新两段线段。每段线段相当于取一个区间加了 $k\times 下标+b$ ，因此差分的时候分斜率和截距两部分更新就行。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    mod = 10 ** 9 + 7
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        tmp = [-1]
        for x in nums:
            tmp.append(x)
            tmp.append(-1)
        
        wing = [0] * (2 * n + 1)
        idx = 0
        
        for i in range(2 * n + 1):
            if idx + wing[idx] >= i:
                wing[i] = fmin(wing[2 * idx - i], idx + wing[idx] - i)
            
            while i > wing[i] and i + wing[i] < 2 * n and tmp[i - wing[i] - 1] == tmp[i + wing[i] + 1]:
                wing[i] += 1
            
            if wing[i] + i > wing[idx] + idx:
                idx = i
        
        diff_k = [0] * (n + 1)
        diff_b = [0] * (n + 1)
        
        for i in range(2 * n + 1):
            l = (i - wing[i]) // 2
            r = (i + wing[i]) // 2
            
            mid = (l + r + 1) // 2
            diff_k[l] += 1
            diff_k[mid] -= 1
            diff_b[l] -= l - 1
            diff_b[mid] += l - 1
            
            diff_k[mid] -= 1
            diff_k[r] += 1
            diff_b[mid] += r
            diff_b[r] -= r
        
        for i in range(n):
            diff_k[i] %= mod
            diff_b[i] %= mod
            diff_k[i + 1] += diff_k[i]
            diff_b[i + 1] += diff_b[i]
        
        ans = 0
        for i in range(n):
            ans += (diff_k[i] * i + diff_b[i]) % mod * nums[i] % mod
            ans %= mod
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 1e9 + 7;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n), tmp(2 * n + 1, -1);
		for (int i = 0; i < n; i ++) {
			cin >> nums[i];
			tmp[2 * i + 1] = nums[i];
		}

		vector<int> wing(2 * n + 1, 0);
		int idx = 0;

		for (int i = 0; i <= 2 * n; i ++) {
			if (idx + wing[idx] >= i)
				wing[i] = min(wing[2 * idx - i], idx + wing[idx] - i);
			while (i > wing[i] && i + wing[i] < 2 * n && tmp[i - wing[i] - 1] == tmp[i + wing[i] + 1])
				wing[i] ++;
			if (wing[i] + i > wing[idx] + idx) idx = i;
		}

		vector<int> diff_k(n + 1, 0), diff_b(n + 1, 0);

		auto add = [&] (int &x, int y) -> void {
			x += y;
			if (x >= mod) x -= mod;
		};

		auto minus = [&] (int &x, int y) -> void {
			x -= y;
			if (x < 0) x += mod;
		};

		for (int i = 0; i <= 2 * n; i ++) {
			int l = (i - wing[i]) / 2, r = (i + wing[i]) / 2;
			int mid = (l + r + 1) / 2;

			add(diff_k[l], 1);
			minus(diff_k[mid], 1);
			minus(diff_b[l], (l - 1 + mod) % mod);
			add(diff_b[mid], (l - 1 + mod) % mod);

			minus(diff_k[mid], 1);
			add(diff_k[r], 1);
			add(diff_b[mid], r);
			minus(diff_b[r], r);
		}

		for (int i = 0; i < n; i ++) {
			add(diff_k[i + 1], diff_k[i]);
			add(diff_b[i + 1], diff_b[i]);
		}

		int ans = 0;
		for (int i = 0; i < n; i ++)
			add(ans, (1ll * diff_k[i] * i + diff_b[i]) % mod * nums[i] % mod);
		
		cout << ans << '\n';
	}

	return 0;
}
```
