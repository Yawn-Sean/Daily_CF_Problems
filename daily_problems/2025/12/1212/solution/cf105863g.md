**提示 1：** 考虑随机取一个序列对应的期望。

**提示 2：** 用期望的可加性，考虑第 $i$ 位是 $j$ 且最小的贡献。

先看提示 1 ，对于这种对全体数列求个值的和的题，可以考虑任取一个序列的答案的期望，再乘序列的总个数。

考虑第 $i$ 位对结果的贡献，其是 $j$ 的概率是 $\frac{1}{k}$ ，而此时前面的元素不比它小的概率是 $\frac{k-j+1}{k}$ ，所以是 $j$ 的情况下满足条件的概率是 $\left(\frac{k-j+1}{k}\right)^{i-1}$ ，所以根据全概率公式，第 $i$ 位的总贡献是 $\sum\limits_{j=1}^k\frac{1}{k}\left(\frac{k-j+1}{k}\right)^{i-1}=\frac{1}{k}\sum\limits_{j=1}^k\left(\frac{k-j+1}{k}\right)^{i-1}$ 。

所以最终求的东西就是 $\frac{1}{k}\sum\limits_{i=1}^n\sum\limits_{j=1}^k\left(\frac{k-j+1}{k}\right)^{i-1}$ 。我们可以先关于 $i$ 求和，这样求和的就是个等比数列 $\sum\limits_{i=1}^n\left(\frac{k-j+1}{k}\right)^{i-1}$ ，再关于 $j$ 求和 $k$ 次就是答案。

等比数列求和的时间复杂度是 $\mathcal{O}(\log MOD)$ 的，所以时间复杂度为 $\mathcal{O}(k\log MOD)$ 。注意公比为 $1$ 时等比数列求和公式需要用 $na_0$ 。你也可以使用矩阵快速幂做等比数列求和。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    mod = 998244353
    
    for _ in range(t):
        n, k = MII()
        
        ans = n
        revk = pow(k, -1, mod)
        for i in range(1, k):
            prob = i * revk % mod
            ans += (1 - pow(prob, n, mod)) * pow(1 - prob, -1, mod)
            ans %= mod
        
        outs.append(ans * pow(k, n - 1, mod) % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 998244353;
	cin >> t;

	while (t --) {
		int n, k;
		cin >> n >> k;

		int ans = n, revk = quickPow(k, mod - 2, mod);
		for (int i = 1; i < k; i ++) {
			int prob = 1ll * i * revk % mod;
			ans += (mod + 1 - quickPow(prob, n, mod)) * quickPow(mod + 1 - prob, mod - 2, mod) % mod;
			ans %= mod;
		}

		cout << ans * quickPow(k, n - 1, mod) % mod << '\n';
	}

	return 0;
}
```
