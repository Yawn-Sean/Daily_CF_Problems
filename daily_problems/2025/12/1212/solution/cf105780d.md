**提示 1：** 相当于有多少组点构成正多边形。

**提示 2：** 给出的点都是整数——所以不太可能有乱七八糟的多边形。

格点多边形是正多边形，只可能是正方形。

所以只需枚举正方形的一条边 / 一条对角线，看另外对应的点是否存在即可。注意可能重复计数，把重复的次数除掉就好。

时间复杂度为 $\mathcal{O}(n^2)$ ，如果用哈希表判断元素是否存在。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    pts = [tuple(MII()) for _ in range(n)]
    vis = set(pts)
    
    ans = 0
    for i in range(n):
        for j in range(i):
            x1, y1 = pts[i]
            x2, y2 = pts[j]
            
            dx = x2 - x1
            dy = y2 - y1
            
            if (x1 + dx - dy, y1 + dx + dy) in vis and (x1 - dy, y1 + dx) in vis:
                ans += 1
            if (x1 + dy, y1 - dx) in vis and (x1 + dx + dy, y1 + dy - dx) in vis:
                ans += 1
    
    print(ans // 4)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<pair<long long, long long>> pts(n);
	for (auto &[x, y]: pts) cin >> x >> y;

	set<pair<long long, long long>> st(pts.begin(), pts.end());

	int ans = 0;
	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < i; j ++) {
			auto [x1, y1] = pts[i];
			auto [x2, y2] = pts[j];
			long long dx = x2 - x1;
			long long dy = y2 - y1;

			if (st.find({x1 + dx - dy, y1 + dx + dy}) != st.end() && st.find({x1 - dy, y1 + dx}) != st.end()) ans ++;
			if (st.find({x1 + dy, y1 - dx}) != st.end() && st.find({x1 + dx + dy, y1 + dy - dx}) != st.end()) ans ++;
		}
	}

	cout << ans / 4;

	return 0;
}
```
