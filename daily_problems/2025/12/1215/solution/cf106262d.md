**提示 1：** 对于某一个容量而言，可能的浓度是多少？

**提示 2：** 应该要点很基础的积分。

对于某个容量而言，可能的浓度如何确定呢？

最高浓度——显然挑选最高浓度的几瓶东西混在一起，最低浓度——显然挑选最低浓度的几瓶混在一起。

所以我们可以根据浓度进行排序，然后把对应的容量拼接起来，就能得到最低 / 高酒精含量与总容积的关系图。

而把总容积设定为横坐标，则上下的两条曲线都是分段函数，只有 $\mathcal{O}(n)$ 段，因此每一段算出一个结果进行加总即可。

每一段的上下界都是直线。假设某一段的上界是 $k_1x+b_1$ ，下界是 $k_2x+b_2$ ，则对应的浓度上界是 $k_1+b_1/x$ ，下界是 $k_2+b_2/x$ ，所以满足条件的概率是 $(k_1-k_2)+(b_1-b_2)/x$ 。

我们对这个函数进行积分加总后，最后除以总的积分长度就是要求的概率了，相当于对每个横坐标的计算结果加总后取平均值。

上面这个定积分，其实第一部分 $k_1-k_2$ 是可以不算的，因为整个图形是中心对称的，左边计算的结果和右边计算的结果这一项是抵消的。而 $(b_1-b_2)/x$ 的积分结果是 $(b_1-b_2)(\mathrm{ln}(r)-\mathrm{ln}(l))$ ，直接计算即可。

需要注意第一段左端点是 $0$ ，直接求对数会报错，但其对应的两条线段都过原点，所以 $b_1=b_2=0$ ，忽略这段不影响最终答案。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    tots = LII()
    vals = LII()
    
    portion = [vals[i] / tots[i] for i in range(n)]
    st_range = sorted(range(n), key=lambda x: portion[x])
    
    down_xs = [0]
    down_ys = [0]
    
    for i in st_range:
        down_xs.append(down_xs[-1] + tots[i])
        down_ys.append(down_ys[-1] + vals[i])
    
    st_range.reverse()
    
    up_xs = [0]
    up_ys = [0]
    
    for i in st_range:
        up_xs.append(up_xs[-1] + tots[i])
        up_ys.append(up_ys[-1] + vals[i])
    
    pt1 = 0
    pt2 = 0
    ans = 0
    
    while pt1 < n and pt2 < n:
        l = fmax(down_xs[pt1], up_xs[pt2])
        r = fmin(down_xs[pt1 + 1], up_xs[pt2 + 1])
    
        if l < r and l > 0:
            kup = (up_ys[pt2 + 1] - up_ys[pt2]) / (up_xs[pt2 + 1] - up_xs[pt2])
            kdown = (down_ys[pt1 + 1] - down_ys[pt1]) / (down_xs[pt1 + 1] - down_xs[pt1])
            
            bup = up_ys[pt2] - kup * up_xs[pt2]
            bdown = down_ys[pt1] - kdown * down_xs[pt1]
            
            ans += (bup - bdown) * (math.log(r) - math.log(l))
        
        if down_xs[pt1 + 1] < up_xs[pt2 + 1]: pt1 += 1
        else: pt2 += 1
    
    ans /= up_xs[-1]
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> xs(n), ys(n);

	for (auto &x: xs) cin >> x;
	for (auto &x: ys) cin >> x;

	vector<int> order(n);
	iota(order.begin(), order.end(), 0);

	sort(order.begin(), order.end(), [&](int a, int b) {
		return 1ll * xs[b] * ys[a] < 1ll * xs[a] * ys[b];
	});

	vector<long long> down_xs = {0}, down_ys = {0};
	for (auto &x: order) {
		down_xs.push_back(down_xs.back() + xs[x]);
		down_ys.push_back(down_ys.back() + ys[x]);
	}

	reverse(order.begin(), order.end());
	vector<long long> up_xs = {0}, up_ys = {0};
	for (auto &x: order) {
		up_xs.push_back(up_xs.back() + xs[x]);
		up_ys.push_back(up_ys.back() + ys[x]);
	}

	long double ans = 0;
	int pt1 = 0, pt2 = 0;

	while (pt1 < n && pt2 < n) {
		long long l = max(up_xs[pt1], down_xs[pt2]);
		long long r = min(up_xs[pt1 + 1], down_xs[pt2 + 1]);

		if (l < r && l > 0) {
			long double kup = (long double)(up_ys[pt1 + 1] - up_ys[pt1]) / (up_xs[pt1 + 1] - up_xs[pt1]);
			long double kdown = (long double)(down_ys[pt2 + 1] - down_ys[pt2]) / (down_xs[pt2 + 1] - down_xs[pt2]);

			long double bup = up_ys[pt1] - kup * up_xs[pt1];
			long double bdown = down_ys[pt2] - kdown * down_xs[pt2];

			ans += (bup - bdown) * (logl(r) - logl(l));
		}

		if (down_xs[pt2 + 1] < up_xs[pt1 + 1]) pt2++;
		else pt1++;
	}

	ans /= up_xs[n];

	cout << fixed << setprecision(15) << ans << '\n';

	return 0;
}
```
