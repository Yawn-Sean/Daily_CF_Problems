**提示 1：** 因为要算二进制表示中 $1$ 的个数，尝试用二进制表示结果。

**提示 2：** 二项式定理。

首先 $n=m$ 时，显然只有 $1$ 位。

不然的话，不妨设 $n\gt m$ ，则 $(2^n+2^m)^k=(2^{n-m}+1)^k2^{mk}$ 。所以只需要考虑一个形如 $(2^x+1)^k$ 的二进制是 $1$ 的数位个数即可。

而这个怎么算呢？我们用二项式定理展开，就是：

$\sum C_k^i2^{ix}$

先考虑计算 $C_k^i$ ，这件事可以用 $C_n^x=C_{n-1}^{x-1}+C_{n-1}^x$ 算出来，这里需要使用高精度加法之类的（不过好像 $100$ 的数据范围 `__int128_t` 是够用的，不过稍微放大一点就不够了）。

最后得到这些 $C_k^i$ 后，整体是个 $2^x$ 为进制的一个进位的计算，把需要进位的项往下一位算就好了。

时间复杂度为 $\mathcal{O}(k^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m, k = MII()
    
    if n == m: print(1)
    else:
        v = abs(n - m)
        
        combs = [[1]]
        
        def add_val(x1, x2):
            cur = []
            n1, n2 = len(x1), len(x2)
            
            carry = 0
            for i in range(fmax(n1, n2)):
                if i < n1: carry += x1[i]
                if i < n2: carry += x2[i]
                cur.append(carry % 2)
                carry //= 2
            
            if carry: cur.append(carry)
            
            return cur
        
        for i in range(1, k + 1):
            ncombs = [[] for _ in range(i + 1)]
            ncombs[0] = [1]
            ncombs[i] = [1]
            
            for j in range(1, i):
                ncombs[j] = add_val(combs[j - 1], combs[j])
            
            combs = ncombs
        
        carry = []
        ans = 0
        
        for x in combs:
            x = add_val(x, carry)
            ans += sum(x[:v])
            carry = x[v:]
        
        ans += sum(carry)
        print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m, k;
	cin >> n >> m >> k;

	if (n == m) cout << 1;
	else {
		int v = abs(n - m);

		auto add_val = [&] (vector<int> &v1, vector<int> &v2) -> vector<int> {
			vector<int> cur;
			int n1 = v1.size(), n2 = v2.size();

			int carry = 0;
			for (int i = 0; i < max(n1, n2); i ++) {
				if (i < n1) carry += v1[i];
				if (i < n2) carry += v2[i];
				cur.emplace_back(carry & 1);
				carry >>= 1;
			}

			if (carry) cur.emplace_back(carry);

			return cur;
		};

		vector<vector<int>> combs = {{1}};

		for (int i = 1; i <= k; i ++) {
			vector<vector<int>> ncombs(i + 1);
			ncombs[0] = {1};
			ncombs[i] = {1};

			for (int j = 1; j < i; j ++)
				ncombs[j] = add_val(combs[j - 1], combs[j]);
			
			combs.swap(ncombs);
		}

		vector<int> carry;
		int ans = 0;

		for (auto &x: combs) {
			x = add_val(x, carry);

			int val = min(v, (int)x.size());
			vector<int> ncarry;

			for (int i = 0; i < x.size(); i ++) {
				if (i < val) ans += x[i];
				else ncarry.emplace_back(x[i]);
			}

			carry.swap(ncarry);
		}

		for (auto &x: carry) ans += x;

		cout << ans;
	}

	return 0;
}
```