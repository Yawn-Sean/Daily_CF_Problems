**提示 1：** 肯定先求最短路。

**提示 2：** 一个典型的 DP 状态是，走到 $x$ 结点且当前距离是 $y$ 的方案数。这个怎么转移？怎么降低这里的状态数？

我们先求从源点出发的最短路。

接下来考虑一个最基础的 DP，就是走到 $x$ 结点时，当前距离是 $y$ 的方案数。

考虑从 $u$ 走到 $v$ ，则状态从 $(u,d)$ 变为了 $(v,d+1)$ 。

如果我们留存所有可能的距离，则状态数就有 $\mathcal{O}(n^2)$ 了，怎么办呢？

事实上，走到 $u$ 结点时，如果距离已经超过了到 $u$ 的最短路长度 $+2$ ，则最后走到终点的总路程也一定至少为最短路长度 $+2$ 了，就一定不满足要求了。（否则，考虑 $S\to u\to T$ ，如果当前的走法路程不超过 $D+1$ ，则把 $S\to t$ 的部分长度减少 $2$ ，即替换为最短路，则 $S\to u\to T$ 的总路程不超过 $D-1$ ，与 $D$ 是最短路长度矛盾）。

综上，对于 $u$ 结点而言，我们只在意距离是最短路 / 最短路长度 $+1$ 的对应的方案数，这样总状态数就被压缩到 $\mathcal{O}(n)$ 了，而总转移是 $\mathcal{O}(m)$ 的（因为每个结点恰好俩状态）。所以最终可以达到 $\mathcal{O}(n+m)$ 的复杂度。

注意这里转移的过程根据从原点当前走的路程从小到大进行转移。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m, s, t = MII()
    s -= 1
    t -= 1
    
    path = lst_lst(n)
    
    for _ in range(m):
        u, v = GMI()
        path.append(u, v)
        path.append(v, u)
    
    dis = [-1] * n
    que = [s]
    dis[s] = 0
    
    dist_nodes = lst_lst(n)
    
    for u in que:
        dist_nodes.append(dis[u], u)
        for v in path.iterate(u):
            if dis[v] == -1:
                dis[v] = dis[u] + 1
                que.append(v)
    
    mod = 10 ** 9 + 7
    dp = [[0] * n for _ in range(2)]
    
    dp[0][s] = 1
    
    for i in range(n):
        for u in dist_nodes.iterate(i):
            for v in path.iterate(u):
                if dis[v] == dis[u]:
                    dp[1][v] += dp[0][u]
                    dp[1][v] %= mod
        
        for u in dist_nodes.iterate(i):
            for v in path.iterate(u):
                if dis[v] == dis[u] + 1:
                    dp[0][v] += dp[0][u]
                    dp[0][v] %= mod
                    dp[1][v] += dp[1][u]
                    dp[1][v] %= mod
    
    print(dp[1][t])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m, s, t;
	cin >> n >> m >> s >> t;

	s --, t --;

	vector<vector<int>> path(n);
	while (m --) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		path[u].emplace_back(v);
		path[v].emplace_back(u);
	}

	vector<int> dis(n, -1);
	vector<vector<int>> saved(n);
	dis[s] = 0;

	queue<int> q;
	q.push(s);

	while (!q.empty()) {
		int u = q.front(); q.pop();
		saved[dis[u]].emplace_back(u);
		for (auto &v: path[u]) {
			if (dis[v] == -1) {
				dis[v] = dis[u] + 1;
				q.push(v);
			}
		}
	}

	int mod = 1e9 + 7;
	vector<vector<int>> dp(2, vector<int>(n, 0));
	dp[0][s] = 1;

	for (int i = 0; i < n; i ++) {
		for (auto &u: saved[i]) {
			for (auto &v: path[u]) {
				if (dis[v] == dis[u]) {
					dp[1][v] = (dp[1][v] + dp[0][u]) % mod;
				}
			}
		}
		for (auto &u: saved[i]) {
			for (auto &v: path[u]) {
				if (dis[v] == dis[u] + 1) {
					dp[0][v] = (dp[0][v] + dp[0][u]) % mod;
					dp[1][v] = (dp[1][v] + dp[1][u]) % mod;
				}
			}
		}
	}

	cout << dp[1][t];

	return 0;
}
```