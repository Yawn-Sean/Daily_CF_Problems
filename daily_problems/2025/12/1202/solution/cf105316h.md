**提示 1：** 实际上数组是什么？

**提示 2：** 每一次删去的元素对答案的贡献如何？

考虑将删去的元素写成一个序列，则我们每次的 MEX 结果相当于前缀的最小值。

考虑第 $i$ 位的数值的期望。

这里有个离散变量期望的事情，当一个非负随机变量取整数的数值时，我们可以先对于 $i=1,2,\dots$ 计算该数值大于等于 $k\geq i$ 的概率，这些概率相加就是答案。

可以考虑当这个随机变量为 $x$ 时，恰好在上述概率的计算中被算了 $x$ 次。

所以我们只需计算第 $i$ 位大于等于 $j$ 的概率，再对该概率求和，即可得到该位的期望。

而第 $i$ 位的前缀最小值不小于 $j$ 等价于 $1\sim n$ 中选出 $i$ 个数都不小于 $j$ ，所以总共可选集有 $n-j+1$ 个数，方案有 $C_{n-j+1}^i$ 种，而整体有 $C_n^i$ 种方案，所以，这一部分概率是 $\frac{C_{n-j+1}^i}{C_n^i}$ 。

考虑分母，我们要对所有的 $j$ 求和，即求 $C_1^i+C_2^i+\dots+C_n^i$ 。

我们可以使用 $C_{n+1}^{k+1}=C_n^k+C_n^{k+1}$ ，因此有：

$C_1^i+C_2^i+\dots+C_n^i=C_1^{i+1}+C_1^i+C_2^i\dots+C_n^i=C_2^{i+1}+C_2^i\dots+C_n^i=\dots=C_{n+1}^{i+1}$ 

所以第 $i$ 位的期望是 $\frac{C_{n+1}^{i+1}}{C_n^i}=\frac{n+1}{i+1}$ 。

再对 $i$ 求和即可，答案是 $(n+1)\sum\limits_{i=1}^n\frac{1}{i+1}$ 。如果你预处理下 $\sum\limits_{i=1}^n\frac{1}{i+1}$ 就可以 $\mathcal{O}(1)$ 查询了。

可以做到 $\mathcal{O}(M)$ 预处理， $\mathcal{O}(1)$ 查询。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    mod = 998244353
    M = 10 ** 5
    
    f = Factorial(M + 1, mod)
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        ans = 0
        
        for k in range(1, n + 1):
            ans += (n + 1) * f.inv(k + 1) % mod
            ans %= mod
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e5 + 5, mod = 998244353;

	vector<int> f(M, 1), g(M);

	for (int i = 1; i < M; i ++)
		f[i] = 1ll * f[i - 1] * i % mod;

	g[M - 1] = quickPow(f[M - 1], mod - 2, mod);

	for (int i = M - 1; i > 0; i --)
		g[i - 1] = 1ll * g[i] * i % mod;

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		int ans = 0;
		for (int k = 1; k <= n; k ++) {
			ans += 1ll * (n + 1) * f[k] % mod * g[k + 1] % mod;
			ans %= mod;
		}
		
		cout << ans << '\n';
	}

	return 0;
}
```