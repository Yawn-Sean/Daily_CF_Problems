**提示 1：** 括号序列本质上是一棵树。

**提示 2：** 包含两个括号的括号在树上是什么？

这题涉及到一个括号序列，并涉及到匹配的括号，这件事可以理解为一棵树的欧拉序。

得到这棵树只需使用判断括号序列时用到的栈，在每个左括号时，将当前结点跟栈顶结点相连并推入栈，在右括号时弹出栈顶，这样就可以找到唯一对应的一棵树。

而一个括号被另一个括号包含，等价于这个括号在外面那个括号对应的结点的子树内部。所以要同时包含两个括号，也就相当于求共同祖先，我们需要对共同祖先同时加一个数，并查询某个结点的当前权值。

某个结点的当前权值等于初始权值加上更新权值。而对公共祖先同时加数，我们可以找到 LCA ，再对 LCA 及其祖先同时加数。

我们考虑成对 LCA 进行 $+x$ 的标记，查询某个结点的时候相当于查询这个结点对应的子树进行的总增加的数的和。于是整体就是单点更新、子树求和的问题，可以使用 DFS 序一类的工具将子树理解为区间，就变成了单点更新、区间求和的问题，显然可以树状数组解决。（这里原括号序列显然也是个合法的 DFS 序，所以可以用原先的数组来做，下面的代码还是新开了个序列的。）

时间复杂度为 $\mathcal{O}((n+q)\log n)$ ，如果你使用倍增求 LCA 并用树状数组维护后面的更新和查询。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, q = MII()
        s = I()
        nums = LII()
        
        notes = [0] * (2 * n)
        
        path = [[] for _ in range(n + 1)]
        parent = [-1] * (n + 1)
    
        stk = [0]
        pt = 1
        
        for i in range(2 * n):
            if s[i] == '(':
                parent[pt] = stk[-1]
                path[stk[-1]].append(pt)
                stk.append(pt)
                
                notes[i] = pt
                pt += 1
            else:
                stk.pop()
        
        stk = [0]
        ls = [0] * (n + 1)
        rs = [0] * (n + 1)
        tmstamp = 0
        
        while stk:
            u = stk.pop()
            if u >= 0:
                ls[u] = tmstamp
                tmstamp += 1
                stk.append(~u)
                
                for v in path[u]:
                    stk.append(v)
            else:
                rs[~u] = tmstamp
        
        fen = FenwickTree(n + 1)
        
        depth = [0] * (n + 1)
        
        for i in range(1, n + 1):
            depth[i] = depth[parent[i]] + 1
        
        nth_parent = [[-1] * (n + 1) for _ in range(20)]
        nth_parent[0] = parent
        
        for i in range(19):
            for j in range(n + 1):
                if nth_parent[i][j] != -1:
                    nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
        
        def lca(u, v):
            if depth[u] > depth[v]:
                u, v = v, u
            
            d = depth[v] - depth[u]
            
            while d:
                x = d & -d
                v = nth_parent[x.bit_length() - 1][v]
                d -= x
            
            if u == v: return u
            
            for i in range(19, -1, -1):
                if nth_parent[i][u] != nth_parent[i][v]:
                    u = nth_parent[i][u]
                    v = nth_parent[i][v]
            
            return parent[u]
        
        for _ in range(q):
            query = LII()
            
            if query[0] == 1:
                u = notes[query[1] - 1]
                v = notes[query[3] - 1]
                val = query[5]
                l = lca(u, v)
                fen.add(ls[l], val)
            else:
                idx = query[1] - 1
                u = notes[idx]
                outs.append(fen.rsum(ls[u], rs[u] - 1) + nums[idx])
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, q;
		cin >> n >> q;

		string s;
		cin >> s;

		vector<int> nums(2 * n);
		for (auto &v: nums) cin >> v;

		vector<vector<int>> path(n + 1);
		vector<int> parent(n + 1, -1), notes(2 * n), stk = {0};
		int pt = 1;

		for (int i = 0; i < 2 * n; i ++) {
			if (s[i] == '(') {
				parent[pt] = stk.back();
				path[stk.back()].emplace_back(pt);
				stk.emplace_back(pt);
				notes[i] = pt ++;
			}
			else stk.pop_back();
		}

		vector<int> ls(n + 1, 0), rs(n + 1, 0), depth(n + 1, 0);
		int tmstamp = 0;

		auto dfs = [&] (auto &self, int u) -> void {
			ls[u] = tmstamp ++;
			for (auto &v: path[u]) {
				depth[v] = depth[u] + 1;
				self(self, v);
			}
			rs[u] = tmstamp;
		};

		dfs(dfs, 0);

		vector<vector<int>> nth_parent(20, vector<int>(n + 1, -1));
		nth_parent[0] = parent;

		for (int i = 0; i < 19; i ++) {
			for (int j = 0; j <= n; j ++) {
				if (nth_parent[i][j] != -1) {
					nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
				}
			}
		}

		auto lca = [&] (int u, int v) -> int {
			if (depth[u] > depth[v]) swap(u, v);

			int d = depth[v] - depth[u];

			while (d) {
				int x = d & -d;
				v = nth_parent[__builtin_ctz(x)][v];
				d -= x;
			}

			if (u == v) return u;

			for (int i = 19; i >= 0; i --) {
				if (nth_parent[i][u] != nth_parent[i][v]) {
					u = nth_parent[i][u];
					v = nth_parent[i][v];
				}
			}

			return parent[u];
		};

		atcoder::fenwick_tree<long long> fen(n + 1);

		while (q --) {
			int t;
			cin >> t;

			if (t == 1) {
				int l1, r1, l2, r2, val;
				cin >> l1 >> r1 >> l2 >> r2 >> val;
				int u = notes[l1 - 1], v = notes[l2 - 1];
				int l = lca(u, v);
				fen.add(ls[l], val);
			}
			else {
				int l, r;
				cin >> l >> r;
				int u = notes[l - 1];
				cout << fen.sum(ls[u], rs[u]) + nums[l - 1] << '\n';
			}
		}
	}

	return 0;
}
```