**提示 1：** 遇到一个位置需要填的就填。这样做为啥是对的？

实际题目给的限制比较弱，所以考虑一个一个放灯。我们任选一个没被照亮的位置放灯，直到最后每个位置都被照亮即可。这样做显然是合法的构造。

但如果你每次循环都遍历整个矩阵就超时了，怎么办？

从上往下从左往右，边遍历的时候边操作，并记录被照亮的位置，这样复杂度为啥正确呢？

每个位置只可能被点亮 / 被上面的灯点亮一次 / 被左边的灯点亮一次，所以每个位置的操作次数都是常数量级的。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    grid = [[0 if c == '.' else 1 for c in I()] for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 0:
                grid[i][j] = 2
                
                for ni in range(i + 1, n):
                    if grid[ni][j] == 1: break
                    grid[ni][j] = 3
                
                for nj in range(j + 1, m):
                    if grid[i][nj] == 1: break
                    grid[i][nj] = 3
    
    print('\n'.join(''.join(" #L."[x] for x in y) for y in grid))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<string> grid(n);
	for (auto &s: grid) cin >> s;

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < m; j ++) {
			if (grid[i][j] == '.') {
				grid[i][j] = 'L';
				
				for (int ni = i + 1; ni < n; ni ++) {
					if (grid[ni][j] == '#') break;
					grid[ni][j] = '*';
				}

				for (int nj = j + 1; nj < m; nj ++) {
					if (grid[i][nj] == '#') break;
					grid[i][nj] = '*';
				}
			}
		}
	}

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < m; j ++) {
			if (grid[i][j] == '*') {
				grid[i][j] = '.';
			}
		}
	}

	for (auto &s: grid) cout << s << '\n';

	return 0;
}
```
