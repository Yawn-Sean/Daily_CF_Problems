**提示 1：** 找到一系列的组合，使得他们很容易说明满足要求。

**提示 2：** 计数，容斥。

如果我们选取的所有序列的和都相等，那么任意两个不同的序列一定存在一项一个比另一个大，一项一个比另一个小。

什么情况下这个和对应的序列最多呢？就是中间的时候，也就是值在 $\frac{n(m+1)}{2}$ 的情况下（取整 / 上取整都行）。

这个是上界的说明需要不少组合知识，不太容易在这里快速说清楚所以感兴趣的话可以自己去找找，可能涉及到拆链之类的。

接下来如何统计用 $n$ 个 $1\sim m$ 的数凑出来 $target$ 的方案数呢？

我们先不管这个上界，则就是一个简单的隔板法问题，就是 $C_{target-1}^{n-1}$ 。

而这样多算了什么呢？多算了存在至少一个元素满足 $x\geq m+1$ 的那些情况。

于是考虑用容斥（其实是二项式反演），在有 $k$ 个元素不小于 $m+1$ 的情况下，把这些元素全部减掉 $m$ ，就变成了类似的问题，方案数是 $C_{target-mk-1}^{n-1}$ ，而这里选取 $k$ 个元素有 $C_n^k$ 种方法，所以有 $C_{target-mk-1}^{n-1}C_n^k$ 种方案。将这些结果用类似容斥的方式组合即答案。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    mod = 998244353
    
    f = Factorial(n * m, mod)
    
    ans = 0
    target = n * (m + 1) // 2
    
    for i in range(target // (m + 1) + 1):
        total = target - i * m
        ans += f.combi(total - 1, n - 1) * f.combi(n, i) % mod * (1 if i % 2 == 0 else -1) % mod
        ans %= mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e6, mod = 998244353;

	vector<int> f(M + 1), g(M + 1);
	f[0] = 1;
	for (int i = 1; i <= M; i ++) f[i] = 1ll * i * f[i - 1] % mod;
	g[M] = quickPow(f[M], mod - 2, mod);
	for (int i = M; i >= 1; i --) g[i - 1] = 1ll * i * g[i] % mod;

	auto comb = [&] (int x, int y) -> int {
		if (y < 0 || y > x) return 0;
		return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
	};

	int n, m;
	cin >> n >> m;

	int ans = 0, target = n * (m + 1) / 2;

	for (int i = 0; i <= target / (m + 1); i ++) {
		int total = target - i * m;
		int v = 1ll * comb(total - 1, n - 1) * comb(n, i) % mod;
		if (i & 1) ans += mod - v;
		else ans += v;
		ans %= mod;
	}

	cout << ans;

	return 0;
}
```
