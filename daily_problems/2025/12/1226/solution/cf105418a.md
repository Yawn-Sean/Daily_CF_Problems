**提示 1：** 将两次缩短视为两次状态的变化。

**提示 2：** 在新状态下进行最短路。

先看提示。我们认为点有三种状态 —— 还没用过操作，刚用过一次操作，不能再用操作。认为是三层。

则第一层间的点需要有原图中所有的边，最后一层也是。

而第一层用 $(u,v,w/2)$ 可以进入第二层，第二层用 $(u,v,w/2)$ 可以进入第三层。注意第二层内不能用原有的边，这样就会导致操作的两条边不连续了。

综上我们形成了一个新的分层图，在这个分层图上跑最短路。我们只要在任何一层中到达 $n$ 就行，因此取各个状态对应的 $n$ 的答案的最小值即可。

时间复杂度为 $\mathcal{O}(n+m\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    path = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v, w = MII()
        u -= 1
        v -= 1
        path[u].append(w * n + v)
    
    inf = 10 ** 15
    
    dis = [[inf] * n for _ in range(3)]
    dis[0][0] = 0
    
    def g(d, u, cur):
        return (d * n + u) * 3 + cur
    
    pq = [g(0, 0, 0)]
    
    while pq:
        v = heappop(pq)
        v, cur = divmod(v, 3)
        d, u = divmod(v, n)
        
        if dis[cur][u] == d:
            if cur == 0:
                for msk in path[u]:
                    w, v = divmod(msk, n)
                    if dis[0][v] > d + w:
                        dis[0][v] = d + w
                        heappush(pq, g(dis[0][v], v, 0))
                    
                    if dis[1][v] > d + w // 2:
                        dis[1][v] = d + w // 2
                        heappush(pq, g(dis[1][v], v, 1))
            
            elif cur == 1:
                for msk in path[u]:
                    w, v = divmod(msk, n)
                    if dis[2][v] > d + w // 2:
                        dis[2][v] = d + w // 2
                        heappush(pq, g(dis[2][v], v, 2))
            
            else:
                for msk in path[u]:
                    w, v = divmod(msk, n)
                    if dis[2][v] > d + w:
                        dis[2][v] = d + w
                        heappush(pq, g(dis[2][v], v, 2))
    
    print(fmin(dis[1][n - 1], dis[2][n - 1]))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<vector<pair<int, int>>> path(n);

	for (int i = 0; i < m; i ++) {
		int u, v, w;
		cin >> u >> v >> w;
		u --, v --;
		path[u].emplace_back(v, w);
	}

	long long inf = 1e15;

	vector<vector<long long>> dis(3, vector<long long>(n, inf));
	dis[0][0] = 0;

	priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<tuple<long long, int, int>>> pq;
	pq.push({0, 0, 0});

	while (!pq.empty()) {
		auto [d, u, cur] = pq.top(); pq.pop();

		if (dis[cur][u] == d) {
			if (cur == 0) {
				for (auto &[v, w]: path[u]) {
					if (dis[0][v] > d + w) {
						dis[0][v] = d + w;
						pq.push({dis[0][v], v, 0});
					}
					if (dis[1][v] > d + w / 2) {
						dis[1][v] = d + w / 2;
						pq.push({dis[1][v], v, 1});
					}
				}
			}
			else if (cur == 1) {
				for (auto &[v, w]: path[u]) {
					if (dis[2][v] > d + w / 2) {
						dis[2][v] = d + w / 2;
						pq.push({dis[2][v], v, 2});
					}
				}
			}
			else {
				for (auto &[v, w]: path[u]) {
					if (dis[2][v] > d + w) {
						dis[2][v] = d + w;
						pq.push({dis[2][v], v, 2});
					}
				}
			}
		}
	}

	cout << min(dis[1][n - 1], dis[2][n - 1]);

	return 0;
}
```
