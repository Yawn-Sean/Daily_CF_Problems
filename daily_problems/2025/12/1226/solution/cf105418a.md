**提示 1：** 假设某一轮插入了元素 $a_i$ ，逆序对数量如何改变？

**提示 2：** 实际选择是独立的。

考虑第 $i$ 轮，在前面插入元素的新增逆序对个数等于前面的数中比它小的数的个数，在后面插入元素的新增逆序对个数等于前面的数中比它大的数的个数。

这两件事都不跟前面 / 后面的选择有关，所以每次选择是独立的。

我们先用树状数组分别求两种贡献。

接下来假设全部插入到后面去，然后不断把一个个操作调整为从前面插入，相当于我们要最小化修改后的变动数值。

考虑将变动数值存在一个数组中，进行排序，按照排序结果一个个变动就行。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        fen = FenwickTree(n + 1)
        ans = 0
        diff = []
        
        for x in nums:
            v1 = fen.rsum(x + 1, n)
            v2 = fen.rsum(0, x - 1)
            
            ans += v1
            diff.append(v2 - v1)
            
            fen.add(x, 1)
    
        diff.sort()
        
        res = [ans]
        
        for x in diff:
            res.append(res[-1] + x)
        
        outs.append(' '.join(map(str, res)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		atcoder::fenwick_tree<int> fen(n + 1);

		long long cur = 0;
		vector<int> diff;

		for (int i = 0; i < n; i ++) {
			int v;
			cin >> v;

			int v1 = fen.sum(v + 1, n + 1);
			int v2 = fen.sum(0, v);

			cur += v1;
			diff.emplace_back(v2 - v1);

			fen.add(v, 1);
		}

		sort(diff.begin(), diff.end());

		cout << cur;
		for (auto &x: diff)
			cur += x, cout << ' ' << cur;
		cout << '\n';
	}

	return 0;
}
```
