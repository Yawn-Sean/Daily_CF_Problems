**提示 1：** 把一个数变成 evenly even / oddly odd 的最小成本分别如何？

**提示 2：** 如何调整到题目要求的最终情况？

首先我们先看一个数变成目标数的最小成本。

一种情况是所有质因子都是奇数，也就是去掉所有质因子 $2$ 。显然一个一个除以 $2$ 就是最优的。

否则需要去除所有的奇数因子。事实上一个个除以奇质数因子也是最优的。

因为乘法操作是可以最后分配给对应 evenly even 和 oddly odd 的数的，同时最后结局时，两种数都至少有 $1$ 个，因此总能构造，所以我们直接忽略这个乘法。

我们先不考虑 $a,b$ 的条件，都挑选成本小的那种方式进行操作。

接下来，如果 evenly even 不够多？就需要把一些变成 oddly odd 的数变成 evenly even ，我们就看哪些调整是成本最低的，进行对应的调整。

如果 oddly odd 不够多我们也这样操作。

因为要对成本进行排序，所以复杂度总是 $\mathcal{O}(n\log n)$ 的，前面的成本计算可以预处理。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 10 ** 6
    cost = list(range(M + 1))
    
    cost[1] = 0
    for i in range(2, M + 1):
        if i % 2 and cost[i] == i:
            for j in range(i, M + 1, i * 2):
                cost[j] = i + cost[j // i]
    
    t = II()
    outs = []
    
    for _ in range(t):
        n, a, b = MII()
        nums = LII()
        
        adj0 = []
        adj1 = []
        
        cnt0 = 0
        cnt1 = 0
        
        ans = 0
        
        for i in range(n):
            c1 = 0
            while nums[i] % 2 == 0:
                nums[i] //= 2
                c1 += 2
            
            c0 = cost[nums[i]]
            
            if c0 < c1:
                cnt0 += 1
                ans += c0
                adj1.append(c1 - c0)
            else:
                cnt1 += 1
                ans += c1
                adj0.append(c0 - c1)
        
        adj0.sort()
        adj1.sort()
        
        if cnt0 < a:
            for i in range(a - cnt0):
                ans += adj0[i]
        
        if cnt1 < b:
            for i in range(b - cnt1):
                ans += adj1[i]
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int M = 1e6;
    vector<int> cost(M + 1);
    iota(cost.begin(), cost.end(), 0);

    cost[1] = 0;
    for (int i = 2; i <= M; i ++) {
        if ((i & 1) && cost[i] == i) {
            for (int j = i; j <= M; j += 2 * i) {
                cost[j] = i + cost[j / i];
            }
        }
    }

    int t;
    cin >> t;

    while (t --) {
        int n, a, b;
        cin >> n >> a >> b;

        long long ans = 0;
        vector<int> adj0, adj1;
        int cnt0 = 0, cnt1 = 0;

        while (n --) {
            int x;
            cin >> x;

            int c0, c1 = 0;

            while (x % 2 == 0) {
                x /= 2;
                c1 += 2;
            }

            c0 = cost[x];

            if (c0 < c1) {
                cnt0 ++;
                ans += c0;
                adj1.emplace_back(c1 - c0);
            }
            else {
                cnt1 ++;
                ans += c1;
                adj0.emplace_back(c0 - c1);
            }
        }

        sort(adj0.begin(), adj0.end());
        sort(adj1.begin(), adj1.end());

        if (cnt0 < a) {
            for (int i = 0; i < a - cnt0; i ++) {
                ans += adj0[i];
            }
        }

        if (cnt1 < b) {
            for (int i = 0; i < b - cnt1; i ++) {
                ans += adj1[i];
            }
        }

        cout << ans << '\n';
    }

	return 0;
}
```
