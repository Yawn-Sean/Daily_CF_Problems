**提示 1：** 先看选取 $k$ 的问题，应该选啥？

**提示 2：** 对于一组 $(idx,k)$ ，何时概率为 $0$ ？非 $0$ 的情况怎么算？

首先对于第二类查询，我们看怎么选择 $k$ 。

首先，如果 $k$ 能让整个过程走到 $idx$ 这个位置，那么 $k$ 在这种情况下应该越小越好 —— 可以让整体过程更短。

所以，我们模拟从头到尾的过程，看走到每个位置至少需要多大的 $k$ ，这就是第二种查询对应的 $k$ 的答案了。

接下来两个问题就都是求概率了，即考虑 $(idx,k)$ 对应的答案。

我们先看什么情况下答案是 $0$ 。如果最后可以选到 $idx$ 这个位置，则这次操作的停止位置一定是 $pos=\min(nums[idx]第一次出现的位置+k-1,n-1)$ 。

所以，如果在这个前缀中存在比 $nums[idx]$ 更大的数，那么一定是矛盾的。这件事多维护一个前缀最大值就行。

同时如果这个位置比 $idx$ 小，也一定是矛盾的。

最后，我们还需要能走到 $pos$ ，这就对 $k$ 提出了要求， $k$ 需要不小于走到 $pos$ 所需的最小 $k$ 值，这在前一问我们预处理过了。

否则一定可能选到 $idx$ 这个位置。

首先，遍历到 $idx$ 这个位置的时候我们需要选上它。如果是这个数字第一次出现，则我们一定因为其比前面元素都大而选它，概率是 $1$ ；否则只有 $\frac{1}{2}$ 的概率选到。

接下来从 $idx+1$ 一直到 $pos$ ，一旦遇到一个等于 $nums[idx]$ 的数我们都有 $\frac{1}{2}$ 的概率放弃掉它，所以我们统计区间内 $nums[idx]$ 的出现次数 $cnt$ ，求 $\frac{1}{2^{cnt}}$ 将其跟前面的概率相乘即可。

怎么求出现次数呢？我们可以把一个数出现的所有下标存起来，之后查询的时候二分找区间端点在数组中的位置就行。

时间复杂度为 $\mathcal{O}(n+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    rnd = random.getrandbits(30)
    
    n, q = MII()
    nums = [x + rnd for x in LII()]
    
    mod = 10 ** 9 + 7
    
    cur_ma = 0
    step = 1
    
    pref_steps = [0] * n
    pos = defaultdict(list)
    
    for i in range(n):
        pref_steps[i] = step
        if nums[i] > cur_ma:
            cur_ma = nums[i]
            step = 0
        step += 1
    
        pos[nums[i]].append(i)
    
    pref_max = nums[:]
    
    for i in range(1, n):
        pref_steps[i] = fmax(pref_steps[i - 1], pref_steps[i])
        pref_max[i] = fmax(pref_max[i - 1], pref_max[i])
    
    rev2_pows = [0] * (n + 1)
    rev2_pows[0] = 1
    rev2 = (mod + 1) // 2
    
    for i in range(n):
        rev2_pows[i + 1] = rev2_pows[i] * rev2 % mod
    
    def solve(idx, k):
        last_pos = fmin(pos[nums[idx]][0] + k, n - 1)
        if pref_max[last_pos] > nums[idx]: return 0
        if pref_steps[last_pos] > k: return 0
        if last_pos < idx: return 0
        ans = 1 if pos[nums[idx]][0] == idx else rev2
        ans = ans * rev2_pows[bisect.bisect_right(pos[nums[idx]], last_pos) - bisect.bisect_right(pos[nums[idx]], idx)] % mod
        
        return ans
    
    outs = []
    for _ in range(q):
        query = LII()
        
        if query[0] == 1:
            idx = query[1] - 1
            k = query[2]
            outs.append(f'{solve(idx, k)}')
        else:
            idx = query[1] - 1
            k = pref_steps[idx]
            outs.append(f'{k} {solve(idx, k)}')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int n, q;
    cin >> n >> q;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    int mod = 1e9 + 7;
    int cur_ma = 0, step = 1;

    vector<int> pref_steps(n);
    map<int, vector<int>> pos;

    for (int i = 0; i < n; i ++) {
        pref_steps[i] = step;
        if (nums[i] > cur_ma) {
            cur_ma = nums[i];
            step = 0;
        }
        step ++;

        pos[nums[i]].emplace_back(i);
    }

    vector<int> pref_max = nums;
    for (int i = 1; i < n; i ++) {
        pref_steps[i] = max(pref_steps[i - 1], pref_steps[i]);
        pref_max[i] = max(pref_max[i - 1], pref_max[i]);
    }

    int rev2 = (mod + 1) / 2;
    vector<int> rev2_pows(n + 1);
    rev2_pows[0] = 1;

    for (int i = 1; i <= n; i ++)
        rev2_pows[i] = 1ll * rev2_pows[i - 1] * rev2 % mod;

    auto solve = [&] (int idx, int k) -> int {
        auto &to_find = pos[nums[idx]];
        int last_pos = min(to_find[0] + k, n - 1);
        if (pref_max[last_pos] > nums[idx]) return 0;
        if (pref_steps[last_pos] > k) return 0;
        if (last_pos < idx) return 0;

        int ans = (to_find[0] == idx ? 1 : rev2);
        auto r = upper_bound(to_find.begin(), to_find.end(), last_pos);
        auto l = upper_bound(to_find.begin(), to_find.end(), idx);
        ans = 1ll * ans * rev2_pows[r - l] % mod;
        return ans;
    };

    while (q --) {
        int t;
        cin >> t;

        if (t == 1) {
            int idx, k;
            cin >> idx >> k;
            cout << solve(idx - 1, k) << '\n';
        }
        else {
            int idx;
            cin >> idx;
            idx --;
            int k = pref_steps[idx];
            cout << k << ' ' << solve(idx, k) << '\n';
        }
    }

	return 0;
}
```
