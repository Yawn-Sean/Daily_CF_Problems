**提示 1：** 实际上求的是子数组的前缀和的最大值的和。

**提示 2：** 是一系列区间和，所以用前缀和表示，实际上要求什么？

先看提示 1，我们要求所有子数组的前缀和的最大值。

而子数组的前缀和也是一个子数组，而子数组的和用前缀和比较好描述，所以考虑先计算原数组的前缀和。

而对于区间 $[l,r]$ ，找子数组的最大前缀和，相当于找原前缀和数组中该区间对应的最大值。

所以我们相当于要求所有区间的最大值的和，再减去所有左端点对应的前缀和的和。这件事是典型的可以用单调栈完成的问题。

具体的，我们可以用单调栈维护从 $l$ 开始的前缀和数组的最大值，我们只需对这些最大值求和，为此多维护一个单调栈中的当前和的变量即可，具体可见下面的代码。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
    
        acc = [0] * (n + 1)
        for i in range(n):
            acc[i + 1] = acc[i] + nums[i]
    
        ans = 0
    
        stk = [n + 1]
        stk_acc = [0]
        
        for i in range(n, -1, -1):
            while stk[-1] != n + 1 and acc[i] >= acc[stk[-1]]:
                stk_acc.pop()
                stk.pop()
            
            stk_acc.append(stk_acc[-1] + (stk[-1] - i) * acc[i])
            stk.append(i)
            
            ans += stk_acc[-1] - (n + 1 - i) * acc[i]
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> acc(n + 1);
		for (int i = 1; i <= n; i ++) {
			cin >> acc[i];
			acc[i] += acc[i - 1];
		}

		long long ans = 0;
		vector<int> stk = {n + 1};
		vector<long long> stk_acc = {0};

		for (int i = n; i >= 0; i --) {
			while (stk.back() != n + 1 && acc[i] > acc[stk.back()]) {
				stk_acc.pop_back();
				stk.pop_back();
			}

			stk_acc.emplace_back(stk_acc.back() + 1ll * (stk.back() - i) * acc[i]);
			stk.emplace_back(i);

			ans += stk_acc.back() - 1ll * (n + 1 - i) * acc[i];
		}

		cout << ans << '\n';
	}

	return 0;
}
```