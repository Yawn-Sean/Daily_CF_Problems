**提示 1：** 先猜答案，再尝试构造。

**提示 2：** 两个排列给了很大的自由度，可以尝试用某种形式固定一个再看能否构造另一个。

首先尝试给出一个 $f(x,y)$ 的下界。

首先，出现频率最多的元素如果出现了 $c$ 次，答案肯定不小于 $c$ ，因为直接取这些元素作为子序列就好了。

如果还多了至少一个元素，则 $f(x,y)\geq c+1$ ，因为我们总可以选定该元素，通过旋转将该元素和 $c$ 个频率最高的元素调整成跟第一个序列相同的顺序就行。

事实上这就是可以达到的最小值。下面只需给出构造。

两个排列都能瞎构造，这就给了很高自由度，可以尝试固定其一。

公共子序列相对是没那么直观的。我们把第一个序列直接设定为排序后的序列，那么我们只需第二个子数组无论怎么旋转，最长非递减子序列长度都不超过 $\min(c+1,n)$ 就行，这看起来比原问题是简单一些的。

事实上这件事很容易构造。因为我们的答案跟最多数字出现的频率有关，所以把每个数字的第 $i$ 次出现放到一堆。在同一堆内的元素我们倒序排列，再把这些堆拼起来。

为啥这样符合要求呢？因为这样恰好有 $c$ 堆，而无论怎么旋转，只要这一堆仍然是连续的一段，那么仍然只能选取其中的一个元素作为非递减子序列的一员。而只有被切割的段可能新增一个子序列的长度。也就无论如何都没法比 $\min(c+1,n)$ 大了。

综上，我们给出了该界限的证明和构造，也就完成了必要性和充分性的说明。

上面的构造方法是 $\mathcal{O}(n\log n)$ 的。题目给的数据范围比较小可能是因为这题的 checker 写的是 $\mathcal{O}(n^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        nums.sort(reverse=True)
        
        cnt = Counter()
        tmp = [[] for _ in range(n)]
        
        for x in nums:
            tmp[cnt[x]].append(x)
            cnt[x] += 1
        
        ans = []
        for v in tmp:
            ans += v
        
        nums.reverse()
        
        outs.append(' '.join(map(str, nums)))
        outs.append(' '.join(map(str, ans)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &x: nums) cin >> x;

		sort(nums.rbegin(), nums.rend());

		vector<vector<int>> tmp(n);
		map<int, int> mp;

		for (auto &x: nums) {
			tmp[mp[x]].emplace_back(x);
			mp[x] ++;
		}

		reverse(nums.begin(), nums.end());
		for (auto &x: nums) cout << x << ' '; cout << '\n';
		for (auto &y: tmp) for (auto &x: y) cout << x << ' '; cout << '\n';
	}

	return 0;
}
```
