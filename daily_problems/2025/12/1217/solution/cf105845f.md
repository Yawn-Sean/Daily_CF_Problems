**提示 1：** 典型 DP 计数，状态如何？

**提示 2：** 转移的要求实际是什么？如何优化？

我们设前 $i$ 项分为 $j$ 段的方案数是 $dp[i][j]$ ，则我们要求的是所有 $dp[n][j]$ 的和。

我们从 $j$ 段变为 $j+1$ 段，假设可以从 $i$ 转移到 $i'$ 位置，则 $(i+1)+(i+2)+\dots+i'$ 需要是 $j+1$ 的倍数。

怎么处理比较干净呢？你可以用前缀和表示区间和，即 $(i+1)+(i+2)+\dots+i'=\frac{(i'+1)i'}{2}-\frac{(i+1)i}{2}$ ，即前后两个位置的 $x(x+1)/2$ 关于 $j+1$ 同余。

所以我们只需统计前缀中跟 $i'$ 满足 $(x+1)x/2$ 同余的位置的前一轮的 DP 结果的和，就可以得到当前 $i'$ 的答案。这件事在顺序遍历的过程中很容易维护，只需在遍历某个下标时，更新对应取模结果位置的统计。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    mod = 10 ** 9 + 7
    
    dp = [0] * (n + 1)
    dp[0] = 1
    
    ans = 0
    
    for i in range(1, n + 1):
        ndp = [0] * (n + 1)
        
        cur = [0] * i
        pre = 0
        
        for j in range(n + 1):
            pre = (pre + j) % i
            ndp[j] = cur[pre]
            cur[pre] = (cur[pre] + dp[j]) % mod
        
        dp = ndp
        ans = (ans + dp[n]) % mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mod = 1e9 + 7;
	cin >> n;

	vector<int> dp(n + 1, 0);
	dp[0] = 1;

	int ans = 0;

	for (int i = 1; i <= n; i ++) {
		vector<int> ndp(n + 1, 0);
		vector<int> saved(i, 0);
		int cur = 0;

		for (int j = 0; j <= n; j ++) {
			cur = (cur + j) % i;
			ndp[j] = saved[cur];
			saved[cur] = (saved[cur] + dp[j]) % mod;
		}

		dp.swap(ndp);
		ans = (ans + dp[n]) % mod;
	}

	cout << ans;

	return 0;
}
```
