**提示 1：** 我们考虑某一对时，其他对对他的影响如何？

**提示 2：** 如何对每一对比赛者都计算答案呢？

我们只需计算必然比某个人得分高的人数有多少个就行。

先考虑 $u,v$ 俩人比赛，剩余人对 $u$ 的影响。不妨考虑某一组 $x,y$ （这里 $x,y$ 指的是分数），其中有多少人必然比 $u$ 得分高。

对于 $u$ 而言最好的结果肯定是这把赢了，所以只需考虑其他人得分是否超过 $nums[u]+3$ 。

首先，如果有办法让 $x,y$ 分数都不比 $nums[u]+3$ 高，那一定这么做。所以我们计算下 $\max(x+3,y),\max(x+1,y+1),\max(x,y+3)$ 的最小值，一旦 $nums[u]+3$ 超过它，就能使得这组 $x,y$ 中没有人超过它的分数。

否则， $x,y$ 至少有一个人分数比 $u$ 高。有没有办法使得只有一个人分数更高呢？条件如何呢？实际上，只要 $\min(x,y)$ 不超过 $nums[u]+3$ ，则我们让对应的人输就能达成要求了。

综上，我们求得两个数值——大于等于 $v_1$ 的可以使得没有人比当前的人分数更高，大于等于 $v_2$ 的可以使得只有一个人比当前的人分数更高。也就是比其中一个数高就多打败一个人。

因此，相当于把这些数值存起来，看 $nums[u]+3$ 比其中多少个数大，就计算出了战胜了除本组外的多少人，再加上自己这组能否分数超越对手，就是总战胜的人数，也就解决了问题。

而对于不同的组别都要算出答案，所以可以先对整体先统计，考虑某一组时，删去这两个数，计算下结果，再添加回来就好。这件事很容易用树状数组维护，也可以直接前缀和预处理，再精密处理下变化量。

可以达到的较优时间复杂度为 $\mathcal{O}(n+M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    xs = []
    ys = []
    
    for _ in range(n):
        x, y = MII()
        xs.append(x)
        ys.append(y)
    
    M = 5 * 10 ** 5 + 100
    fen = FenwickTree(M)
    
    for i in range(n):
        x, y = nums[xs[i]], nums[ys[i]]
        
        if x > y:
            x, y = y, x
        
        fen.add(x, 1)
        fen.add(fmin(fmax(x + 1, y + 1), fmax(x + 3, y)), 1)
    
    ans = [0] * (2 * n)
    
    for i in range(n):
        x, y = nums[xs[i]], nums[ys[i]]
        
        if x > y:
            x, y = y, x
        
        fen.add(x, -1)
        fen.add(fmin(fmax(x + 1, y + 1), fmax(x + 3, y)), -1)
        
        ans[xs[i]] = 2 * n - fen.rsum(0, nums[xs[i]] + 3)
        ans[ys[i]] = 2 * n - fen.rsum(0, nums[ys[i]] + 3)
        
        if nums[xs[i]] + 3 >= nums[ys[i]]: ans[xs[i]] -= 1
        if nums[ys[i]] + 3 >= nums[xs[i]]: ans[ys[i]] -= 1
        
        fen.add(x, 1)
        fen.add(fmin(fmax(x + 1, y + 1), fmax(x + 3, y)), 1)
    
    print(' '.join(map(str, ans)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(2 * n);
	for (auto &x: nums) cin >> x;

	vector<pair<int, int>> competitions(n);
	for (auto &[x, y]: competitions) cin >> x >> y;

	int M = 5e5 + 100;
	atcoder::fenwick_tree<int> fen(M);

	for (auto &[u, v]: competitions) {
		int x = nums[u], y = nums[v];
		if (x > y) swap(x, y);

		fen.add(x, 1);
		fen.add(min(max(x + 1, y + 1), max(x + 3, y)), 1);
	}

	vector<int> ans(2 * n);

	for (auto &[u, v]: competitions) {
		int x = nums[u], y = nums[v];
		if (x > y) swap(x, y);

		fen.add(x, -1);
		fen.add(min(max(x + 1, y + 1), max(x + 3, y)), -1);

		ans[u] = 2 * n - fen.sum(0, nums[u] + 4);
		ans[v] = 2 * n - fen.sum(0, nums[v] + 4);

		if (nums[u] + 3 >= nums[v]) ans[u] --;
		if (nums[v] + 3 >= nums[u]) ans[v] --;

		fen.add(x, 1);
		fen.add(min(max(x + 1, y + 1), max(x + 3, y)), 1);
	}

	for (auto &x: ans) cout << x << ' ';

	return 0;
}
```