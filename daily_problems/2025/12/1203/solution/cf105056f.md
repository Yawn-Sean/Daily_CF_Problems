**提示 1：** 可以离线解决问题。

**提示 2：** 我们只需二分操作的序列，看到哪里可以使得 $u$ 结点符合要求。这个序列如何维护？

先看提示。

显然一个数变成 $k$ 的倍数就一直是了。所以如果我们知道一个点对应的操作序列，则答案一定对应于一个前缀。

怎么维护一个点经历过的各种操作呢？其实就是其祖先结点经历的各种操作了，因此可以在 DFS 的过程中遍历到一个结点时添加操作，离开结点时删去操作即可。而这些操作需要按照按照操作时间排列，我们要取一个按照操作时间的前缀来检查是否操作后是 $k$ 的倍数。

最方便的方式就是直接开一个数组表示各个时间上进行的操作，我们需要维护的操作是一堆乘法，因此没有操作的时间直接标记 $1$ 就行。所以操作的时间标记上对应数字，否则标记 $1$ ，就等价于当前结点受到的操作了。

但这件事没办法快速查询一个前缀的效果，而两个操作 $x,y$ 先后进行等价于进行 $x\times y\bmod k$ 的操作，所以是可以用线段树维护的。而我们也只需用线段树二分，找到第一个满足条件的前缀。

所以综上，DFS 的过程中用线段树维护操作序列，并用线段树二分找到答案即可。

时间复杂度为 $\mathcal{O}(q+n\log q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k, q = MII()
    nums = LII()
    parent = LII()
    
    path = [[] for _ in range(n)]
    for i in range(n - 1):
        path[parent[i] - 1].append(i + 1)
    
    updates = [[] for _ in range(n)]
    
    for qid in range(q):
        u, x = MII()
        u -= 1
        updates[u].append((qid, x))
    
    seg = SegTree(lambda x, y: x * y % k, 1, q)
    ans = [0] * n
    
    stk = [0]
    
    while stk:
        u = stk.pop()
        
        if u >= 0:
            for qid, x in updates[u]:
                seg.set(qid, x)
            
            if nums[u] % k == 0: ans[u] = 0
            else:
                res = seg.max_right(0, lambda x: x * nums[u] % k)
                ans[u] = -1 if res == q else res + 1
            
            stk.append(~u)
            for v in path[u]:
                stk.append(v)
            
        else:
            for qid, x in updates[~u]:
                seg.set(qid, 1)
    
    print(' '.join(map(str, ans)))
```

C++ 做法如下——

```cpp []
int mod;

int op(int x, int y) {return 1ll * x * y % mod;}

int e() {return 1;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> mod >> q;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<vector<int>> path(n);

	for (int i = 1; i < n; i ++) {
		int p;
		cin >> p;
		path[p - 1].emplace_back(i);
	}

	vector<vector<pair<int, int>>> updates(n);

	for (int i = 0; i < q; i ++) {
		int u, x;
		cin >> u >> x;
		updates[u - 1].emplace_back(i, x);
	}

	atcoder::segtree<int, op, e> seg(q);
	vector<int> ans(n);

	auto dfs = [&] (auto &self, int u) -> void {
		for (auto &[i, x]: updates[u]) seg.set(i, x);

		if (nums[u] % mod == 0) ans[u] = 0;
		else {
			int res = seg.max_right(0, [&] (int x) {return 1ll * x * nums[u] % mod != 0;});
			ans[u] = (res == q ? -1 : res + 1);
		}

		for (auto &v: path[u]) self(self, v);

		for (auto &[i, x]: updates[u]) seg.set(i, 1);
	};

	dfs(dfs, 0);

	for (auto &x: ans) cout << x << ' ';

	return 0;
}
```