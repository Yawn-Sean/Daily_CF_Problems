**提示 1：** 在没有环的图中，连通块数量可以用点数和边数表示。

**提示 2：** 期望可加性。

在没有环的图中，连通块数量等于点的数量减去边的数量。我们从没有边的情况开始考虑，新增一条边就少一个连通块，所以也就证明了这个结论。

所以答案就是点数的期望减去边数的期望。

点的数量可以用每个点的存在概率相加得到，边的数量可以用每条边的存在概率相加得到（相当于每个点对），而两个概率分别是 $\frac{1}{i}$ 和 $\frac{1}{i(i+1)}$ 。

两个都可以用前缀和预处理，同时逆元也很容易求（不熟悉的可以搜索一下），当然后者也可以裂项化简。

所以 $\mathcal{O}(M)$ 预处理， $\mathcal{O}(1)$ 查询即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 10 ** 6
    mod = 10 ** 9 + 7
    
    f = Factorial(M, mod)
    
    acc = [0] * (M + 1)
    
    for i in range(1, M + 1):
        acc[i] = (acc[i - 1] + f.inv(i)) % mod
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        outs.append((acc[n] - (1 - f.inv(n))) % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 1e9 + 7, M = 1e6;
	cin >> t;

	vector<int> f(M + 1), g(M + 1);
	f[0] = 1;
	for (int i = 1; i <= M; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;

	g[M] = quickPow(f[M], mod - 2, mod);
	for (int i = M; i >= 1; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	vector<int> acc(M + 1);
	acc[0] = 0;

	for (int i = 1; i <= M; i ++)
		acc[i] = (acc[i - 1] + 1ll * f[i - 1] * g[i]) % mod;

	while (t --) {
		int n;
		cin >> n;
		cout << (acc[n] - (1 - 1ll * f[n - 1] * g[n])) % mod << '\n';
	}

	return 0;
}
```
