**提示 1：** 把题中的式子理解为一个组合问题的解。

**提示 2：** 把不同情况下组合问题的解的和，重新理解为，对于每一个组合问题的解对应的情况的和。

$\Pi_{i=1}^N\left(\sum\limits_{j=1}^MA_{i,j}\right)$ 可以理解为现在有个矩阵，第 $i$ 行第 $j$ 列有的球数是 $A_{i,j}$ ，问每一行恰好选一个小球的方案数。另一项跟它相乘的是每一列恰好选一个小球的方案数。为了区分两次选择，我们称第一次选择是染成蓝色，第二次选择是染成红色。

对于染成蓝色，不染色的格子标记为 $0$ ，否则标记为选择的小球的编号（不妨设每个格子内的小球按照 $1,2,\dots$ 编号）。染成红色的也这么标记。

则如果一个格子被染成了颜色 $x$ ，则其给对应的 $A_{i,j}$ 提出的要求是 $A_{i,j}\geq x$ 。

这里我们的预先理解就已经完成了。接下来考虑如何计数。

这里我们要求每行有染蓝色的，每列有染红色的。如果一行行考虑，我们要存的状态是当前已经被染成蓝色的集合。这可行吗？

因为 $nm\leq 300$ ，所以 $\min(n,m)\leq\sqrt{300}$ ，不超过 $17$ ，所以可以考虑。

因为要同时考虑行和列，进一步地，我们用轮廓线 DP 。下面我们考虑的问题相当于，对于一组可行的染色结果，看初始方案的数量和。初始方案数量等于每个格子对应的方案数量的乘积。所以下面会提到每个格子对应的方案数。

考虑一行一行顺序遍历每个格子，到第 $i$ 行的第 $j$ 列时，被染过色的列的形成集合 $msk$ ，另外用一个标记 $tag$ 标记这一行是否被染过色。这就是我们需要的所有变量了。

对于一个新的格子，我们考虑其四种情况：

- 不染色，这个格子对 $B_i$ 毫无要求，且染色结果一定是 $0$ ，所以方案数是 $A_i+1$ 。

- 只被染成红色 / 蓝色，此时如果这个格子被染色成 $x$ ，则对应的 $B_i\geq x$ ，因此总方案数是 $\sum\limits_{x=1}^{B_i}(B_i+1-x)=\frac{B_i(B_i)+1}{2}$ 。

- 既被染成红色也被染成蓝色，此时这个格子被染色成红色的 $x$ ，蓝色的 $y$ ，则 $B_i\geq\max(x,y)$ 。所以这一个格子的方案数是 $\sum\limits_{x=1}^{B_i}\sum\limits_{y=1}^{B_i}(B_i+1-\max(x,y))$ ，用下 $x,y$ 的对称性就可以拆掉 $\max$ 进行求和了（当然也有别的理解方式）。

注意已经被列染色过的列没办法再被染色，记得跳过它们。

时间复杂度为 $\mathcal{O}(nm2^{\min(n,m)})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    grid = [LII() for _ in range(n)]
    
    if n < m:
        n, m = m, n
        grid = [list(x) for x in zip(*grid)]
    
    mod = 998244353
    
    dp = [0] * (1 << m)
    dp[0] = 1
    
    rev2 = pow(2, -1, mod)
    rev6 = pow(6, -1, mod)
    
    for i in range(n):
        ndp = [0] * (1 << m)
        
        for j in range(m):
            v = grid[i][j]
            v0 = (v + 1) % mod
            v1 = v * (v + 1) % mod * rev2 % mod
            v2 = v * (v + 1) % mod * (2 * v + 1) % mod * rev6 % mod
            
            for msk in range((1 << m) - 1, -1, -1):
                ndp[msk] = (ndp[msk] * v0 + dp[msk] * v1) % mod
                dp[msk] = dp[msk] * v0 % mod
    
                if msk >> j & 1:
                    nmsk = msk ^ (1 << j)
                    
                    ndp[msk] = (ndp[msk] + dp[nmsk] * v2 + ndp[nmsk] * v1) % mod
                    dp[msk] = (dp[msk] + dp[nmsk] * v1) % mod
        
        dp = ndp
    
    print(dp[-1])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<vector<int>> grid(n, vector<int>(m));
	for (auto &x: grid) for (auto &y: x) cin >> y;

	if (n < m) {
		vector<vector<int>> ngrid(m, vector<int>(n));
		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < m; j ++) {
				ngrid[j][i] = grid[i][j];
			}
		}
		swap(n, m);
		swap(grid, ngrid);
	}

	int mod = 998244353;
	vector<int> dp(1 << m, 0);
	dp[0] = 1;

	int rev2 = quickPow(2, mod - 2, mod), rev6 = quickPow(6, mod - 2, mod);

	for (int i = 0; i < n; i ++) {
		vector<int> ndp(1 << m, 0);

		for (int j = 0; j < m; j ++) {
			int v = grid[i][j];
			int v0 = (v + 1) % mod;
			int v1 = 1ll * v * (v + 1) % mod * rev2 % mod;
			int v2 = 1ll * v * (v + 1) % mod * (2 * v + 1) % mod * rev6 % mod;

			for (int msk = (1 << m) - 1; msk >= 0; msk --) {
				ndp[msk] = (1ll * ndp[msk] * v0 + 1ll * dp[msk] * v1) % mod;
				dp[msk] = 1ll * dp[msk] * v0 % mod;

				if (msk >> j & 1) {
					int nmsk = msk ^ (1 << j);
					ndp[msk] = (ndp[msk] + 1ll * dp[nmsk] * v2 + 1ll * ndp[nmsk] * v1) % mod;
					dp[msk] = (dp[msk] + 1ll * dp[nmsk] * v1) % mod;
				}
			}
		}

		dp.swap(ndp);
	}

	cout << dp.back();

	return 0;
}
```
