**提示 1：** 如果确定当前轮次选哪些牌，我们应该如何排序？

**提示 2：** 前面的轮次和最后轮次分开考虑。

先特判情况——

如果初始 $P=0$ / 没有进攻卡，那么无论如何没法攻击，答案是 `'*'` 。

否则，如果没有增强攻击力的卡片，那么每一个完整轮次的攻击总量是保持不变的，因此只需计算有多少个完整的轮次，再加上最后需要的攻击次数即可。

否则，每一轮结束攻击力都增加。对于完整的轮次，应该怎么操作呢？应该先加后乘，最后攻击，这样可以使得总攻击值最大化。所以这样模拟若干轮，直到某一轮可以打死。

模拟的轮次上界如何呢？事实上，每一轮的伤害至少是上一轮 $+1$ ，所以至多 $\mathcal{O}(\sqrt{H})$ 轮就能结束了。

最后一轮需要多少次呢？我们考虑枚举可能的选卡策略——若干张最大的加法，若干张最大的乘法和若干张攻击卡。而每种方案都是按照先加再乘最后攻击的方式模拟，如果能够杀死怪物，就更新最小操作数。

注意这里很容易出现很大的数，直接和 $10^9$ 取最小值就可以防止爆 `long long` 之列的。

时间复杂度为 $\mathcal{O}(n\sqrt{H}+n^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, p, h = MII()
    
    muls = []
    adds = []
    
    cnt = 0
    
    for _ in range(n):
        tmp = LI()
        
        if tmp[0] == '*':
            if int(tmp[1]) > 1:
                muls.append(int(tmp[1]))
        elif tmp[0] == '+':
            adds.append(int(tmp[1]))
        else:
            cnt += 1
    
    muls.sort(reverse=True)
    adds.sort(reverse=True)
    
    if cnt == 0: print('*')
    elif len(muls) == 0 and len(adds) == 0:
        if p == 0: print('*')
        else:
            h = (h - 1) // p + 1
            rounds = (h - 1) // cnt
            print(rounds * n + h - rounds * cnt)
    else:
        inf = 10 ** 9
        ans = 0
        while True:
            cur = p
            for x in adds:
                cur = fmin(cur + x, inf)
            for x in muls:
                cur = fmin(cur * x, inf)
    
            if cur * cnt < h:
                h -= cur * cnt
                ans += n
                p = cur
            else:
                res = n
                
                cur_add = p
                for i in range(len(adds) + 1):
                    if i: cur_add = fmin(cur_add + adds[i - 1], inf)
                    cur_mul = cur_add
                    
                    for j in range(len(muls) + 1):
                        if j: cur_mul = fmin(cur_mul * muls[j - 1], inf)
                        
                        for k in range(cnt + 1):
                            if cur_mul * k >= h:
                                res = fmin(res, i + j + k)
                
                ans += res
                break
        
        print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	long long p, h;
	cin >> n >> p >> h;

	vector<long long> muls, adds;
	int cnt = 0;

	for (int i = 0; i < n; i ++) {
		char op;
		cin >> op;

		if (op == '*') {
			int x;
			cin >> x;
			if (x > 1) muls.emplace_back(x);
		}
		else if (op == '+') {
			int x;
			cin >> x;
			adds.emplace_back(x);
		}
		else cnt ++;
	}

	sort(muls.rbegin(), muls.rend());
	sort(adds.rbegin(), adds.rend());

	if (cnt == 0) cout << '*';
	else if (muls.size() == 0 && adds.size() == 0) {
		if (p == 0) cout << '*';
		else {
			h = (h - 1) / p + 1;
			long long rounds = (h - 1) / cnt;
			cout << rounds * n + h - rounds * cnt;
		}
	}
	else {
		long long inf = 1e9;
		int ans = 0;

		while (true) {
			long long cur = p;
			for (auto &x: adds) cur = min(cur + x, inf);
			for (auto &x: muls) cur = min(cur * x, inf);

			if (cur * cnt < h) {
				h -= cur * cnt;
				ans += n;
				p = cur;
			}
			else {
				int res = n;
				long long cur_add = p;

				for (int i = 0; i <= adds.size(); i ++) {
					if (i) cur_add = min(cur_add + adds[i - 1], inf);
					long long cur_mul = cur_add;

					for (int j = 0; j <= muls.size(); j ++) {
						if (j) cur_mul = min(cur_mul * muls[j - 1], inf);

						for (int k = 0; k <= cnt; k ++) {
							if (cur_mul * k >= h) {
								res = min(res, i + j + k);
							}
						}
					}
				}

				ans += res;
				break;
			}
		}
		cout << ans;
	}

	return 0;
}
```
