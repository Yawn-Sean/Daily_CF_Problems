**提示 1：** 如果数组不变怎么找答案？

**提示 2：** 如何快速处理插入和删除？

如果数组不变，我们只需看查询数组每个元素的位置。如果其位置在原数组中相邻，则认为合并成一块。我们求最大块长即可。

而这边数组是循环的，所以跨过边界的也需要考虑。为此我们直接复制一遍数组看就可以了。

如果数组复制一遍时得到的答案大于 $K$ ，那么就意味着甚至出现了有重复元素的公共子数组，这就意味着答案其实是 `'*'` 。注意这里还得处理数是否在数组中。

如何在插入元素 / 删除元素时，仍然判断数组中某两个元素是否相邻呢？可以使用链表。这里循环的数组其实更适合用环形链表。这样只需判断是否是链表中下一个元素即可。

时间复杂度为 $\mathcal{O}(n+q+\sum k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, p, h = MII()
    
    muls = []
    adds = []
    
    cnt = 0
    
    for _ in range(n):
        tmp = LI()
        
        if tmp[0] == '*':
            if int(tmp[1]) > 1:
                muls.append(int(tmp[1]))
        elif tmp[0] == '+':
            adds.append(int(tmp[1]))
        else:
            cnt += 1
    
    muls.sort(reverse=True)
    adds.sort(reverse=True)
    
    if cnt == 0: print('*')
    elif len(muls) == 0 and len(adds) == 0:
        if p == 0: print('*')
        else:
            h = (h - 1) // p + 1
            rounds = (h - 1) // cnt
            print(rounds * n + h - rounds * cnt)
    else:
        inf = 10 ** 9
        ans = 0
        while True:
            cur = p
            for x in adds:
                cur = fmin(cur + x, inf)
            for x in muls:
                cur = fmin(cur * x, inf)
    
            if cur * cnt < h:
                h -= cur * cnt
                ans += n
                p = cur
            else:
                res = n
                
                cur_add = p
                for i in range(len(adds) + 1):
                    if i: cur_add = fmin(cur_add + adds[i - 1], inf)
                    cur_mul = cur_add
                    
                    for j in range(len(muls) + 1):
                        if j: cur_mul = fmin(cur_mul * muls[j - 1], inf)
                        
                        for k in range(cnt + 1):
                            if cur_mul * k >= h:
                                res = fmin(res, i + j + k)
                
                ans += res
                break
        
        print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	long long p, h;
	cin >> n >> p >> h;

	vector<long long> muls, adds;
	int cnt = 0;

	for (int i = 0; i < n; i ++) {
		char op;
		cin >> op;

		if (op == '*') {
			int x;
			cin >> x;
			if (x > 1) muls.emplace_back(x);
		}
		else if (op == '+') {
			int x;
			cin >> x;
			adds.emplace_back(x);
		}
		else cnt ++;
	}

	sort(muls.rbegin(), muls.rend());
	sort(adds.rbegin(), adds.rend());

	if (cnt == 0) cout << '*';
	else if (muls.size() == 0 && adds.size() == 0) {
		if (p == 0) cout << '*';
		else {
			h = (h - 1) / p + 1;
			long long rounds = (h - 1) / cnt;
			cout << rounds * n + h - rounds * cnt;
		}
	}
	else {
		long long inf = 1e9;
		int ans = 0;

		while (true) {
			long long cur = p;
			for (auto &x: adds) cur = min(cur + x, inf);
			for (auto &x: muls) cur = min(cur * x, inf);

			if (cur * cnt < h) {
				h -= cur * cnt;
				ans += n;
				p = cur;
			}
			else {
				int res = n;
				long long cur_add = p;

				for (int i = 0; i <= adds.size(); i ++) {
					if (i) cur_add = min(cur_add + adds[i - 1], inf);
					long long cur_mul = cur_add;

					for (int j = 0; j <= muls.size(); j ++) {
						if (j) cur_mul = min(cur_mul * muls[j - 1], inf);

						for (int k = 0; k <= cnt; k ++) {
							if (cur_mul * k >= h) {
								res = min(res, i + j + k);
							}
						}
					}
				}

				ans += res;
				break;
			}
		}
		cout << ans;
	}

	return 0;
}
```
