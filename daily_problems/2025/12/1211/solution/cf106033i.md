**提示 1：** 先把问题变成一维的问题。再尝试理解成方格上的运动。

前两个条件相对容易，第三个比较坏，所以我们重点考虑 $a_i-b_i$ 。

考虑 $a_i-b_i$ 的运动过程，每次只可能相对前者变大 $1$ ，变小 $1$ 或者不变，前两者只有一种方案，最后的有两种方案。

所以可以将其拆分为两步，每一步都是选择 $+0.5$ 或者 $-0.5$ ，这样两步的结果跟前一段的结果是一样的。

于是我们相当于要走 $2(n-1)$ 步，每步 $+0.5$ 或者 $-0.5$ ，使得取值从来不超过 $K+0.5$ 的方案数（注意 $K+0.5$ 是合法的，因为只要下一步继续回到 $K$ 就行）。

我们强行把步长和要求都乘 $2$ 不影响结果，所以理解为每一步选择 $+1$ 或者 $-1$ ，取值从来不超过 $2K+1$ 。

在方格上考虑这个问题，把 $-1$ 操作看成向 $x$ 轴正方向移动一格，把 $+1$ 操作看成向 $y$ 轴正方向移动一格。则相当于折线不能越过 $y=x+2k+1$ ，这件事就很像卡特兰数了。

而如果越过了就相当于走到过 $y=x+2k+2$ 这条直线上，于是把第一次走到 $y=x+2k+2$ 之前的路径关于 $y=x+2k+2$ 进行对称（是卡特兰数计算的经典操作），则可以发现经过 $(0,0)$ 且越过 $y=x+2k+1$ 走到某个点的方案数等于从 $(-2k-2,2k+2)$ 点走到对应点的答案。

于是我们可以枚举最终到达的位置 $(2(n-1),0),(2(n-1)-1,1),\dots$ ，用从 $(0,0)$ 出发的方案总数，减去不合法的方案数，即从 $(-2k-2,2k+2)$ 点走到对应点的方案数，即这部分答案。最终求和即可。注意这里枚举的最终位置也需要满足不越过 $y=x+2k+1$ 的条件。

如果你把组合数列出来，会发现有很多项约掉了。

综上，本题复杂度是 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k = MII()
    n -= 1
    mod = 998244353
    
    f = Factorial(2 * n, mod)
    
    ans = 0
    for i in range(n - k - 1, n + k + 1):
        ans += f.combi(2 * n, i)
        ans %= mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k, mod = 998244353;
	cin >> n >> k, n --;

	vector<int> f(2 * n + 1), g(2 * n + 1);
	f[0] = 1;

	for (int i = 1; i <= 2 * n; i ++) f[i] = 1ll * i * f[i - 1] % mod;
	g[2 * n] = quickPow(f[2 * n], mod - 2, mod);
	for (int i = 2 * n; i >= 1; i --) g[i - 1] = 1ll * i * g[i] % mod;

	auto comb = [&] (int x, int y) -> int {
		if (y < 0 || y > x) return 0;
		return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
	};

	int ans = 0;

	for (int i = n - k - 1; i <= n + k; i ++)
		ans = (ans + comb(2 * n, i)) % mod;

	cout << ans;

	return 0;
}
```
