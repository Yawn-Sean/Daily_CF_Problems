**提示 1：** 一个数取模后要么不变要么变少很多。

**提示 2：** 实际上经历不了多少次减少的操作。

一个数关于另一个取模后，要么减少到严格小于原本的一半，要么不变。

所以真正使得数值减小的取模操作不超过 $\mathcal{O}(\log M)$ 量级。

于是我们只需快速找到这些操作的位置即可。我们只需在还没有进行的操作中找出第一个比当前数小的数就行，这件事我们可以使用一棵维护最小值的线段树，在线段树上二分。每次找到一个有用的操作的时间复杂度为 $\mathcal{O}(\log n)$ 。

综上，本题复杂度是 $\mathcal{O}(n+q\log n\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    inf = 2 * 10 ** 9
    
    for _ in range(t):
        n, q = MII()
        nums = LII()
        
        seg = SegTree(fmin, inf, nums)
        
        for _ in range(q):
            x = II()
            
            pt = 0
            while x:
                pt = seg.max_right(pt, lambda val: val > x)
                if pt == n: break
                x = x % nums[pt]
            
            outs.append(x)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int op(int x, int y) {return min(x, y);}

int e() {return (int)2e9;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, q;
		cin >> n >> q;

		vector<int> nums(n);
		for (auto &x: nums) cin >> x;

		atcoder::segtree<int, op, e> seg(nums);

		while (q --) {
			int x;
			cin >> x;

			int pt = 0;
			while (x) {
				pt = seg.max_right(pt, [&] (int val) {return val > x;});
				if (pt == n) break;
				x %= nums[pt];
			}

			cout << x << '\n';
		}
	}

	return 0;
}
```