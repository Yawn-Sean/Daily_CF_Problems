**提示 1：** 如果数组不变，答案咋算？考虑下哪些元素不得不新开一个子序列。

**提示 2：** 旋转一次后，会产生什么影响？

先看提示 1。

如果一个元素，其前面有个元素和它的最大公约数不等于 $1$ ，可以直接分配到那个元素对应的子序列中；否则，只能自己新开一个子序列了。

所以一个元素产生成本当且仅当它跟前面所有元素都互质，也就是它的质因子之前都从来没出现过。

我们先计算原数组的成本，接下来考虑旋转。

我们相当于给 $nums[r]$ 提到前面去，然后 $[nums[l],nums[l+1],\dots,nums[r-1]]$ 这些元素前面多了一个 $nums[r]$ 。

我们操作产生的好处是，原本在 $[nums[l],nums[l+1],\dots,nums[r-1]]$ 中会被计入答案的部分，因为跟 $nums[r]$ 不互质，所以此时不再被加入答案中。

如果 $nums[r]$ 本身被计入答案中，则前面元素都和它互质，也就是不会产生上面的好处，也就不用考虑。

否则，考虑 $nums[r]$ 尽可能往前移动并且不产生贡献，那么找到其质因子中最早出现的那一个，移动到那个元素对应的 $pos$ 后面。

怎么统计区间里那些跟 $nums[r]$ 不互质的原本产生贡献的数呢？我们只需枚举 $nums[r]$ 的质因子，看其是否是产生贡献的数的因子，且出现位置在 $pos$ 和 $r$ 之间就行。

$nums[r]$ 会移动到更靠前的位置吗？答案是，没必要。因为这样最多会使得 $pos$ 位置的元素少产生一次贡献，而 $nums[r]$ 肯定多产生了一次贡献，是得不偿失的。

所以对于所有这些数模拟下上述过程即可。时间复杂度为 $\mathcal{O}(n\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 3 * 10 ** 5
    
    pr = list(range(M + 1))
    
    for i in range(2, M + 1):
        if pr[i] == i:
            for j in range(i, M + 1, i):
                pr[j] = i
    
    def get_prime_factors(x):
        ans = []
        
        while x > 1:
            p = pr[x]
            ans.append(p)
            
            while x % p == 0:
                x //= p
        
        return ans
    
    t = II()
    outs = []
    
    vis = [-1] * (M + 1)
    vis_target = [-1] * (M + 1)
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        ans = 0
        to_delete = 0
        
        for i, x in enumerate(nums):
            tmp = get_prime_factors(x)
            
            flg = True
            pos = i
            for v in tmp:
                if vis[v] != -1:
                    pos = fmin(pos, vis[v])
                    flg = False
                else:
                    vis[v] = i
    
            if flg:
                ans += 1
                for v in tmp:
                    vis_target[v] = i
            else:
                nvis = set()
                
                for v in tmp:
                    if vis_target[v] > pos:
                        nvis.add(vis_target[v])
    
                to_delete = fmax(to_delete, len(nvis))
        
        outs.append(ans - to_delete)
        
        for x in nums:
            tmp = get_prime_factors(x)
            for v in tmp:
                vis[v] = -1
                vis_target[v] = -1
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int M = 3e5;
    vector<int> prime_factor(M + 1);

    iota(prime_factor.begin(), prime_factor.end(), 0);
    for (int i = 2; i <= M; i ++) {
        if (prime_factor[i] == i) {
            for (int j = i; j <= M; j += i) {
                prime_factor[j] = i;
            }
        }
    }

    auto get_prime_factors = [&] (int x) -> vector<int> {
        vector<int> ans;
        while (x > 1) {
            int p = prime_factor[x];
            ans.emplace_back(p);
            while (x % p == 0) x /= p;
        }
        return ans;
    };

    int t;
    cin >> t;

    vector<int> vis(M + 1, -1), vis_target(M + 1, -1);

    while (t --) {
        int n;
        cin >> n;

        vector<int> nums(n);
        for (auto &v: nums) cin >> v;

        int ans = 0, to_delete = 0;

        for (int i = 0; i < n; i ++) {
            int x = nums[i];
            auto tmp = get_prime_factors(x);

            bool flg = true;
            int pos = i;

            for (auto &v: tmp) {
                if (vis[v] != -1) {
                    pos = min(pos, vis[v]);
                    flg = false;
                }
                else vis[v] = i;
            }

            if (flg) {
                ans ++;
                for (auto &v: tmp) vis_target[v] = i;
            }
            else {
                unordered_set<int> nvis;
                for (auto &v: tmp) {
                    if (vis_target[v] > pos) {
                        nvis.insert(vis_target[v]);
                    }
                }
                to_delete = max(to_delete, (int)nvis.size());
            }
        }

        cout << ans - to_delete << '\n';

        for (auto &x: nums) {
            for (auto &v: get_prime_factors(x)) {
                vis[v] = -1;
                vis_target[v] = -1;
            }
        }
    }

	return 0;
}
```
