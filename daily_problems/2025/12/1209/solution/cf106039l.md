**提示 1：** 这题的递推实质上是线性递推，所以可以用矩阵表示。

每个点一次操作后等于其加上其邻居的和关于 $2$ 取模。而总共的格子数不超过 $n^2$ 。所以如果 $x,y$ 是邻居，在矩阵上的 $A[x][y]$ 位置上标记，则这个矩阵就可以表示转移矩阵。

而 $K$ 次线性递推就是 $K$ 次矩阵乘法，用矩阵快速幂即可。注意这里矩阵快速幂是关于 $2$ 取模的。最后再用这个转移矩阵对初始情况进行转移即可。

时间复杂度为 $\mathcal{O}(n^6\log K)$ ，当然关于 $2$ 取模的矩阵乘法可以用 bitset 优化，可以自己想想咋处理。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, k = MII()
    grid = [I() for _ in range(n)]
    
    def f(i, j): return i * n + j
    
    transition = [[0] * (n * n) for _ in range(n * n)]
    
    for i in range(n):
        for j in range(n):
            if grid[i][j] != '#':
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ni = i + di
                        nj = j + dj
                        if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] != '#':
                            transition[f(i, j)][f(ni, nj)] = 1
    
    kth_transition = matrix_pow(transition, k)
    
    ans = [[0] * n for _ in range(n)]
    for x1 in range(n):
        for y1 in range(n):
            for x2 in range(n):
                for y2 in range(n):
                    if kth_transition[f(x1, y1)][f(x2, y2)] and grid[x1][y1] == '1':
                        ans[x2][y2] ^= 1
    
    print('\n'.join(''.join(str(ans[i][j]) if grid[i][j] != '#' else '#' for j in range(n)) for i in range(n)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, k;
	cin >> n >> k;

	vector<string> grid(n);
	for (auto &s: grid) cin >> s;

	auto f = [&] (int i, int j) -> int {return i * n + j;};

	vector<vector<long long>> transition(n * n, vector<long long>(n * n, 0));

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < n; j ++) {
			if (grid[i][j] != '#') {
				for (int di = -1; di <= 1; di ++) {
					for (int dj = -1; dj <= 1; dj ++) {
						int ni = i + di, nj = j + dj;
						if (ni >= 0 && ni < n && nj >= 0 && nj < n && grid[ni][nj] != '#') {
							transition[f(i, j)][f(ni, nj)] = 1;
						}
					}
				}
			}
		}
	}

	auto kth_transition = matrix_pow(transition, k, 2);
	vector<vector<int>> ans(n, vector<int>(n, 0));

	for (int i1 = 0; i1 < n; i1 ++) {
		for (int j1 = 0; j1 < n; j1 ++) {
			for (int i2 = 0; i2 < n; i2 ++) {
				for (int j2 = 0; j2 < n; j2 ++) {
					if (kth_transition[f(i1, j1)][f(i2, j2)]) {
						ans[i2][j2] ^= grid[i1][j1] - '0';
					}
				}
			}
		}
	}

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < n; j ++) {
			if (grid[i][j] == '#') cout << '#';
			else cout << ans[i][j];
		}
		cout << '\n';
	}

	return 0;
}
```