**提示 1：** 考虑两个点，其实夹角必须比较大。所以选不了多少点。

**提示 2：** 怎么减少检查的数量以进一步优化？

首先，根据余弦定理，我们有 $P_iP_j^2=OP_i^2+OP_j^2-2OP_i\times OP_j\mathrm{cos}\angle P_iOP_j$ ，这个数值不能比 $OP_i^2$ 或 $OP_j^2$ 小，所以 $\mathrm{cos}\angle P_iOP_j\leq \frac{1}{2}$ ，不然直接有矛盾。

所以选取的点之间的极角至少差 $\frac{\pi}{3}$ ，而因为是有理数点不可能刚好是 $\frac{\pi}{3}$ ，所以最多选取 $5$ 个点。

因此我们得到了 $\mathcal{O}(n^5)$ 的做法，即枚举所有可能的点集，看是否满足要求，这能解决前 $30$ 分的问题。

那么怎么优化呢？我们不可能每一组点都判一遍，所以按照极角排序，考虑只判相邻的点，看条件够不够用。答案是肯定的。证明如下——

- 用数学归纳法，中间间隔为 $0$ 个点的因为相邻的点对都判断过，因此已经符合要求了。

- 假设 $i$ 个间隔的满足要求了，看有 $i+1$ 个间隔的情况。

- 则对于一组间隔 $i+1$ 个点的 $A,B$ ，中间有个 $C$ 。则根据归纳假设有 $OA\lt AC,OC\lt AC,OC\lt BC,OB\lt BC$ 。

- 如果 $OABC$ 形成一个凸多边形，则对角线的长度和大于一组对边的长度和（其实就是三角形两边之和大于第三边推出来的）。所以 $AB+OC\gt OA+BC$ ，而 $OC\lt BC$ ，所以 $AB\gt OA$ 。 $AB\gt OB$ 的逻辑也是类似的。

- 否则，是 $B$ 凹进去了。此时 $B$ 对应的 $\angle ACB\gt\angle AOB\gt\frac{2\pi}{3}$ ，所以 $\triangle ABC$ 是钝角三角形，有 $AB\gt\max(AC,BC)$ ，也就一定满足要求了。

综上，我们只需判断相邻的被选择的结点是否满足要求即可。

为此，我们先关于极角排序，枚举初始点。接下来 DP 过程中只需维护最后一个点就可以进行状态转移了，最后判断起点和终点是否也满足要求即可。

我们只需保证我们 DP 转移的过程中永远不跨过 $x$ 轴的正半轴，我们就可以保证每一个点集只被计算一次。

时间复杂度为 $\mathcal{O}(n^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def sign(v):
        return v[1] > 0 or (v[1] == 0 and v[0] > 0)
    
    def cmp(v1, v2):
        x1, y1 = v1
        x2, y2 = v2
        val1 = y1 * x2
        val2 = y2 * x1
        if val1 < val2: return -1
        if val2 < val1: return 1
        return 0
    
    n = II()
    mod = 998244353
    
    pts_pos = []
    pts_neg = []
    
    for _ in range(n):
        pt = tuple(MII())
        if sign(pt): pts_pos.append(pt)
        else: pts_neg.append(pt)
    
    pts_pos.sort(key=cmp_to_key(cmp))
    pts_neg.sort(key=cmp_to_key(cmp))
    
    pts = pts_pos + pts_neg
    
    def check(i, j):
        x1, y1 = pts[i]
        x2, y2 = pts[j]
        
        target = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
        v1 = x1 * x1 + y1 * y1
        v2 = x2 * x2 + y2 * y2
        
        return target > v1 and target > v2
    
    saved = [[check(i, j) for j in range(n)] for i in range(n)]
    ans = n
    
    for i in range(n):
        dp = [0] * n
        dp[i] = 1
        
        for x in range(i, n):
            for y in range(x + 1, n):
                if saved[x][y]:
                    dp[y] += dp[x]
        
        for x in range(n):
            if saved[i][x]:
                ans += dp[x]
    
    print(ans % mod)
```

C++ 做法如下——

```cpp []
typedef pair<int, int> pt;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	auto sign = [&] (pt v) -> bool {
		return v.second > 0 || (v.second == 0 && v.first > 0);
	};

	int n, mod = 998244353;
	cin >> n;

	vector<pt> pts_pos, pts_neg;

	for (int i = 0; i < n; i ++) {
		pt v;
		cin >> v.first >> v.second;
		if (sign(v)) pts_pos.emplace_back(v);
		else pts_neg.emplace_back(v);
	}

	sort(pts_pos.begin(), pts_pos.end(), [&] (pt &x, pt &y) {
		return 1ll * x.second * y.first < 1ll * x.first * y.second;
	});
	sort(pts_neg.begin(), pts_neg.end(), [&] (pt &x, pt &y) {
		return 1ll * x.second * y.first < 1ll * x.first * y.second;
	});

	vector<pt> pts;
	pts.insert(pts.end(), pts_pos.begin(), pts_pos.end());
	pts.insert(pts.end(), pts_neg.begin(), pts_neg.end());

	auto check = [&] (int i, int j) -> bool {
		auto [x1, y1] = pts[i];
		auto [x2, y2] = pts[j];

		long long target = 1ll * (x2 - x1) * (x2 - x1) + 1ll * (y2 - y1) * (y2 - y1);
		long long v1 = 1ll * x1 * x1 + 1ll * y1 * y1;
		long long v2 = 1ll * x2 * x2 + 1ll * y2 * y2;

		return target > v1 && target > v2;
	};

	vector<vector<bool>> saved(n, vector<bool>(n));
	for (int i = 0; i < n; i ++) {
		for (int j = 0; j < n; j ++) {
			saved[i][j] = check(i, j);
		}
	}

	long long ans = n;

	for (int i = 0; i < n; i ++) {
		vector<long long> dp(n, 0);
		dp[i] = 1;

		for (int x = i; x < n; x ++) {
			for (int y = x + 1; y < n; y ++) {
				if (saved[x][y]) dp[y] += dp[x];
			}
		}

		for (int x = i; x < n; x ++)
			if (saved[i][x]) ans += dp[x];
	}

	cout << ans % mod;

	return 0;
}
```
