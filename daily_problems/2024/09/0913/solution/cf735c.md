**提示 1：** 直接将人拆分上下半区讨论复杂度显然不容易控制。考虑反向解决这个问题。

**提示 2：** 如果当前深度为 $x$ ，能容纳的最多叶子节点数是多少？

需要反向思考问题。

如果直接考虑这个问题，相当于需要枚举前后两个子树的大小，再看深度，由于节点数量过多，显然不合理；同时两棵子树很不一样，无法直接得到分割位置。那怎么办呢？

考虑深度为 $h$ 的二叉树最少容纳多少个节点。**一旦超过了我们的要求，则输出对应的深度。**

考虑深度为 $h$ 的二叉树。则其左右两颗子树中必然有一棵深度为 $h-1$ ，根据条件，另一棵的深度至少为 $h-2$ 。于是得到递推关系 $f(h)=f(h-1)+f(h-2)$ 。

这个递推关系是呈指数级增长的，因此至多只需要 $\mathcal{O}(\log n)$ 次即可找到答案。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    d1, d2 = 2, 1
    cur = 0

    while d1 <= n:
        d1, d2 = d1 + d2, d1
        cur += 1

    print(cur)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    long long n, v1 = 2, v2 = 1;
    cin >> n;

    int ans = 0;
    while (v1 <= n) {
        v1 += v2;
        v2 = v1 - v2;
        ans ++;
    }
    cout << ans;

    return 0;
}
```
