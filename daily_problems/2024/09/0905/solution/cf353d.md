**提示 1：** 我们只需要考虑 M / F 怎么移动，不需要同时考虑，因为一个走完了，另一个也到位了。

**提示 2：** 不妨考虑 F，其每次执行交换操作实际上发生了什么？

**提示 3：** 如何处理 “堵车” 的情况。

再次印证了分数和难度不完全正相关这件事。

首先，我们只需考虑 F 什么时候到最前面，因为 F 如果都到了最前面，那 M 也都在最后面了，就已经满足了要求。（只考虑 M 什么时候到最后面逻辑也是一样的）

接下来考虑交换操作做了什么。你会发现，交换操作相当于 F 前面少了个 M 。因此每个 F 要经过几次交换只跟前面有几个 M 有关。

答案是否也是只跟 F 前面有几个 M 有关呢？这件事是否定的。因为可能发生 “堵车” 。看到第二个样例，即使一个 F 前面还有 M ，仍然可能因为两个 F 连续，导致不得不多等一轮。

而如果不堵，两个 F 会同时到达目标，因此在堵的情况下，后面的 F 会需要比前面更多的时间到达目标位置，因此后面的 F 答案应至少为当前的答案 $+1$ 。

于是，只需结合我们上述两个分析即可。考虑前面 M 的数量是 $cnt$ ，当前答案是 $ans$ ，则新的一个 F 对应的结果为 $\max(ans+1,cnt)$ 。

注意，如果当前考虑 F 是在开头连续的一段，则无需移动，即无需进行上述答案的更新。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    s = I()
    ans = 0
    cur = 0
    for c in s:
        if c == 'M':
            cur += 1
        elif cur > 0:
            ans = fmax(ans + 1, cur)

    print(ans)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    string s;
    cin >> s;

    int ans = 0, cur = 0;

    for (auto c: s) {
        if (c == 'M') cur ++;
        else if (cur) ans = max(ans + 1, cur);
    }
    cout << ans;

    return 0;
}
```
