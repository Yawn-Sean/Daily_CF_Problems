**提示 1：** 如果这题是一个二维的选点，找分割线是件不太容易的事情。考虑一维的情况，尝试在一条线段上找点。

**提示 2：** 如果一条线段当前是可以二分类的，接下来我们应该在哪里查询，可以保证下一次产生的染色也能二分类呢？

**提示 3：** 处理清楚前几次查询都同色的情况。

**提示 4：** 如何找到分割的那条直线？可以调整你一开始的线段。

很有趣的一个构造题。

如果本题需要二维的情况，找黑白二染色的分割线并不是容易的事情。于是尝试考虑只用一条线段。结果发现确实是可行的。

我们假设我们现在题目已经做到了一半——目前有一条线段，前面部分是白色，后面部分是黑色，下一次查询应该查哪里呢？

首先，不能在两个白点之间查询，否则万一查到了黑色，我们就无法构造了。

类似地，也不能在两个黑点之间查询，否则万一查到了白色，我们也无法构造了。

综上，应该在 **黑白交界** 的位置进行查询。

而为了保证后续的查询空间，即最坏情况下仍然能够保证剩余的线段足够长，我们应该尽可能平均分配 “黑白交界” 段的线段长度。

至此，本题的核心已经完成了，接下来要处理一些细节。

首先，如何出现 “黑白交界” 的线段呢？我们发现，题目的输出是随机的，所以甚至到最后都有一定概率没有黑白交界的线段，即使出现了也无法确定是第几次。那怎么办呢？

我们假定开始的线段为 $AB$ ，查询完 $B$ 后，我们 **钦定 $A$ 为另一种颜色** ，这并不影响我们后续能二分类的结论。

于是这样，我们查询一次即可得到 “黑白交界的线段” 。

同时，线段上最多有 $10^9+1$ 个格点，因为只有这么多横坐标的种类。因此最后最短的线段内的格点数量为 $\lfloor\frac{10^9+1}{2^{29}}\rfloor-1=0$ ，因此线段内可能没有格点了，那我们怎么找出那条切割的直线呢？

整体思路来看，主要是使用除了线段方向外的另一个方向进行切割。因此我们要让线段两侧有足够的空间使得另一个方向的选择更多。

这里有多种处理方法。我们取 $A=(0,0), B=(10^9,10^9)$ ，这样两侧可选的点就很多了。而如果最后剩下的 “黑白交界” 的线段端点为 $(l,l),(r,r)$ ，则 $(l,r),(r,l)$ 连成的直线一定满足要求。

于是，我们完成了这道构造题。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    def query(x, y):
        print(x, y, flush=True)
        return I()[0] == 'b'

    n = II()

    l, r = 0, 10 ** 9
    flg = query(r, r)

    for _ in range(n - 1):
        m = (l + r) // 2
        if query(m, m) == flg: r = m
        else: l = m

    print(l, r, r, l)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    auto query = [&] (int x, int y) -> bool {
        cout << x << ' ' << y << '\n';
        cout.flush();
        string s;
        cin >> s;
        return s[0] == 'b';
    };

    int n;
    cin >> n;

    int l = 0, r = 1e9;
    bool flg = query(r, r);

    for (int i = 0; i < n - 1; i ++) {
        int m = (l + r) / 2;
        if (query(m, m) == flg) r = m;
        else l = m;
    }

    cout << l << ' ' << r << ' ' << r << ' ' << l;

    return 0;
}
```

