**提示 1：** 首先，我们要全都是 $1$ ，至少得先有一个 $1$ 。

**提示 2：** 有了一个 $1$ 之后，应该如何处理？

首先，我们考虑如何产生第一个 $1$ 。我们如果要最小化操作次数，使用的一定是一段连续区间里面的数。

如果有多段区间的数，则每个区间中的操作互不影响，可以删去不出现第一个 $1$ 的所有区间。

而一个长度为 $len$ 的区间能变成 $1$ 当且仅当其中所有元素的最大公约数为 $1$ （因为一定所有元素算出来了一个最后的公约数），而需要的操作次数为 $len-1$ 。

最后，数组中所有非 $1$ 元素都可以通过 $1$ 向外的 “传染” 变成 $1$ ，在有 $1$ 的情况下，每次操作都可以新增一个 $1$ 。

于是，我们枚举所有区间看是否有最大公约数为 $1$ 的，找到最短的将其生成一个 $1$ ，接下来 $n-1$ 次操作把别的数都变成 $1$ .

**注意：** 如果数组中本来就有 $1$ 应当直接返回数组中非 $1$ 元素的个数。

时间复杂度为 $\mathcal{O}(n^2+n\log M)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()

    if 1 in nums:
        print(n - nums.count(1))
        return

    ans = n
    for i in range(n):
        g = nums[i]
        for j in range(i, n):
            g = math.gcd(g, nums[j])
            if g == 1:
                ans = min(ans, j - i)
                break

    print(ans + n - 1 if ans < n else -1)
```