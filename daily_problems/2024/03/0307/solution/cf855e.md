**提示 1：** 对于单次查询，是经典的数位 DP 问题，你能给出怎样的做法？最优复杂度如何？

**提示 2：** 上述方法能否解答 $10^5$ 次询问？如何优化这一过程？（涉及重复状态）

我们先考虑单次查询这一经典数位 DP 问题，不了解这一类问题的可以先查看 [链接](https://oi-wiki.org/dp/number/) 进行简单学习。

数位 DP 的整体思路是，从高位开始一步步进行填数，填的数保证合法性。接下来，已经填了的数压缩为不同的状态，接下来只需要考虑这些状态向新状态的转移，而非数本身的变动。这样，如果状态的数量足够小，我们就可以以更低的运行时间解决问题。

这里，我们需要设计的状态需要能够判断是否一个数字中每一个字符都出现了偶数次。这如何做到呢？

考虑异或运算，如果一个数对另一个数做了偶数次异或运算，这个数的数值是不改变的。

于是，我们给可能遇到的 $0,1,\dots,9$ 数码分别赋予 $2^0,2^1,\dots,2^9$ 的掩码，接下来每新增一位的数码，就对当前掩码异或这一位数码的对应掩码。最后我们要求掩码的异或和为 $0$ 。

我们考虑这样 DP 的时间复杂度。每个数位有 $2^b$ 种不同的掩码，我们要考虑的数位个数是 $\log_b M$ ，故状态总数是 $\mathcal{O}(2^b\log_b M)$ 的。同时状态转移最多发生 $b$ 次，因此总时间复杂度为 $\mathcal{O}(b2^b\log_b M)$ 。

发现 $b=10$ 代入就达到了 $10^5$ 的复杂度数量级，因此无法解决 $10^5$ 次查询，我们需要进一步进行优化。

单次查询暂时没有找到很好的优化空间。但考虑到这题是多次查询，我们可以看多次查询中遇到的状态中发生的重复计算情况。

首先我们先把区间 $[l,r]$ 的查询变为 $[1,r+1)$ 与 $[1,l)$ 的查询结果作差，这样每次查询都可以分解为形式完全一致的两个问题了。

接下来考虑求解问题 $[1,x)$ 中满足条件的数的个数。

考虑如下情形。假设前面 $k$ 位的数码都已经确定，那么假设接下来的数位完全自由选择，那么剩下数位的需要满足异或和与前面数位的异或和相同。

由于该情形下，我们的 $x$ 给出的上界变得没有意义，因此一旦走到这一状态，每次查询此后给出的结果都是一样的，因此这些是可以提前预处理得到的。而我们可以通过记录长度一定位掩码一定的数码组合个数来快速得到这一结果。

另外，如果前面 $k$ 位的数码中全部都是 $0$ ，即数字还没有开始，那么接下来求的相当于是总位数一定的所有满足条件的数的个数。

因此，每次查询中，唯一需要特别处理的是刚好位于边界的那些状态，即上界仍然提供约束限制的状态。我们只需要枚举第一个小于约束的位置到底是什么数码即可。

预处理的时间复杂度：

对于每一个 $b$ ，我们要预处理没有约束情况下，长度为 $k$ 的后缀产生位掩码 $msk$ 的数字个数。状态总共有 $2^b\log M$ 种，发生转移 $b$ 次，总复杂度为 $\mathcal{O}\left(\sum\limits_{b=2}^{10} b2^b\log M\right)$ .

每次查询的时间复杂度为：

考虑枚举第一个严格小于约束的位，其取值有 $\mathcal{O}(b)$ 种可能，故总共有 $\mathcal{O}(b\log M)$ 种情形需要考虑。每种情形可以通过上述预处理 $\mathcal{O}(1)$ 得到结果。

故总复杂度为 $\mathcal{O}\left(\sum\limits_{b=2}^{10} b2^b\log M +qb\log M\right)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
pre_process = [None] * 11
for b in range(2, 11):
    length = 1
    cur = 1
    while cur <= 10 ** 18:
        length += 1
        cur *= b
    
    length -= 1
    pre_process[b] = [[0] * (1 << b) for _ in range(length)]
    for i in range(b):
        pre_process[b][0][1 << i] = 1
    
    for i in range(length - 1):
        for msk in range(1 << b):
            for new_bit in range(b):
                pre_process[b][i + 1][msk ^ (1 << new_bit)] += pre_process[b][i][msk]

def main():
    b, l, r = MII()
    
    def f(x):
        vals = []
        while x:
            vals.append(x % b)
            x //= b
        k = len(vals)
        
        ans = 0
        # 这里是计数位数严格更小的数的个数，那么剩下的数一定都满足相同位数，方便讨论
        for i in range(k - 1):
            ans += pre_process[b][i][0]
            if i: ans -= pre_process[b][i-1][1]
        
        cur_msk = 0
        for i in range(k - 1, -1, -1):
            for j in range(1 if i == k - 1 else 0, vals[i]):
                # 枚举新的位
                ans += pre_process[b][i - 1][cur_msk ^ (1 << j)] if i else (1 if cur_msk == 1 << j else 0)
            cur_msk ^= 1 << vals[i]
        return ans
    
    print(f(r + 1) - f(l))
    return

t = II()
for _ in range(t):
    main()
```
