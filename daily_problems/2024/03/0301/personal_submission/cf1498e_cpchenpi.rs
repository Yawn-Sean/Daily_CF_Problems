pub use __cargo_equip::prelude::*;

fn main() {
    hcpl_io::prelude!(cin, cout);
    input! { n:usize, a:[i64;n], }
    let mut v: Vec<_> = a.iter().enumerate().map(|(i, &x)| (x, i + 1)).collect();
    v.sort_unstable();
    let mut in_sum = 0;
    let mut ans_len = 0;
    let mut ans = (n + 1, n + 1);
    let mut tv = Vec::new();
    for i in 0..n {
        in_sum += v[i].0;
        tv.push(v[i]);
        if in_sum == (i * (i + 1) / 2) as i64 {
            if tv.len() > 1 {
                let (du, u) = tv[0];
                let (dv, v) = tv[tv.len() - 1];
                if du.abs_diff(dv) >= ans_len {
                    ans_len = du.abs_diff(dv);
                    ans = (u, v);
                }
            }
            tv.clear();
        }
    }
    if ans == (n + 1, n + 1) {
        outln!("! 0 0");
    } else {
        outln!("!", ans.0, ans.1);
    }
}

// The following code was expanded by `cargo-equip`.

///  # Bundled libraries
/// 
///  - `hcpl_integer 0.1.0 (git+https://github.com/cpchenpi/hcpl#81415b83b1b9d23e0a6abc76f5378561558c96fc)` licensed under `MIT` as `crate::__cargo_equip::crates::__hcpl_integer_0_1_0`
///  - `hcpl_io 0.1.0 (git+https://github.com/cpchenpi/hcpl#81415b83b1b9d23e0a6abc76f5378561558c96fc)`      licensed under `MIT` as `crate::__cargo_equip::crates::hcpl_io`
#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod __hcpl_integer_0_1_0 {use std::cmp::Ord;use std::ops::*;pub trait Integer:Copy+Clone+Eq+Ord+Add<Self,Output=Self>+Sub<Self,Output=Self>+AddAssign<Self>+SubAssign<Self>+Shl<Self,Output=Self>+Shr<Self,Output=Self>+Shl<u32,Output=Self>+Shr<u32,Output=Self>+ShlAssign<Self>+ShrAssign<Self>+ShlAssign<u32>+ShrAssign<u32>{type AsUnsigned;type AsSigned;const ZERO:Self;const ONE:Self;const TEN:Self;const BASE_10_MAX_LENGTH:usize;fn leading_ones(self)->u32;fn leading_zeros(self)->u32;fn trailing_ones(self)->u32;fn trailing_zeros(self)->u32;fn unsigned_abs(self)->Self::AsUnsigned;fn is_zero(self)->bool{self==Self::ZERO}}pub trait UnsignedInteger:Integer{}pub trait SignedInteger:Integer{}macro_rules!make_int{($t:ty,$ut:ty,$it:ty,$unsigned_abs:expr,$base_10_max_len:expr)=>{impl Integer for$t{type AsUnsigned=$ut;type AsSigned=$it;const ZERO:$t=0;const ONE:$t=1;const TEN:$t=10;const BASE_10_MAX_LENGTH:usize=$base_10_max_len;fn leading_ones(self)->u32{<$t>::leading_ones(self)}fn leading_zeros(self)->u32{<$t>::leading_zeros(self)}fn trailing_ones(self)->u32{<$t>::trailing_ones(self)}fn trailing_zeros(self)->u32{<$t>::trailing_zeros(self)}fn unsigned_abs(self)->Self::AsUnsigned{$unsigned_abs(self)}}};}macro_rules!base_10_len{($v:expr)=>{{let mut x=$v;let mut ans=0;loop{ans+=1;x/=10;if x==0{break;}}ans}};}macro_rules!make_ints{($ut:ty,$it:ty)=>{make_int!($ut,$ut,$it,|x|x,base_10_len!(<$ut>::MAX));make_int!($it,$ut,$it,Self::unsigned_abs,1+base_10_len!(<$it>::MIN.unsigned_abs()));impl UnsignedInteger for$ut{}impl SignedInteger for$it{}};}make_ints!(u8,i8);make_ints!(u16,i16);make_ints!(u32,i32);make_ints!(u64,i64);make_ints!(u128,i128);make_ints!(usize,isize);}
        pub mod hcpl_io {use crate::__cargo_equip::preludes::hcpl_io::*;pub use crate::__cargo_equip::macros::hcpl_io::*;mod cin{use crate::__cargo_equip::preludes::hcpl_io::*;use std::io::BufRead;use hcpl_integer::Integer;pub struct Cin<'a>{stdin:std::io::StdinLock<'a>,}impl<'a>Cin<'a>{pub fn new(stdin:&'a std::io::Stdin)->Self{Self{stdin:stdin.lock(),}}pub fn buffer(&mut self)->&[u8]{self.stdin.fill_buf().unwrap()}pub fn consume(&mut self,amt:usize){self.stdin.consume(amt)}pub fn read_until<P:FnMut(u8)->bool>(&mut self,mut predicate:P)->Vec<u8>{let mut b=self.buffer();let mut res=Vec::new();loop{match b.iter().copied().position(&mut predicate){Some(i)=>{res.extend_from_slice(&b[..i]);self.consume(i);break;}None=>{res.extend_from_slice(b);let n=b.len();self.consume(n);b=self.buffer();}}}res}pub fn discard_until<P:FnMut(u8)->bool>(&mut self,mut predicate:P){let mut b=self.buffer();loop{match b.iter().copied().position(&mut predicate){Some(i)=>{self.consume(i);break;}None=>{let n=b.len();self.consume(n);b=self.buffer();}}}}pub fn discard_whitespace(&mut self){self.discard_until(|b|!b.is_ascii_whitespace());}pub fn get<T:Cinable>(&mut self)->T{T::read_from(self)}}pub trait Cinable{fn read_from(cin:&mut Cin)->Self;}impl Cinable for char{fn read_from(cin:&mut Cin)->Self{cin.discard_whitespace();let mut ate_one=false;cin.read_until(|_|{if ate_one{true}else{ate_one=true;false}})[0]as char}}impl Cinable for bool{fn read_from(cin:&mut Cin)->Self{let c:char=cin.get();if c=='1'{true}else{assert_eq!(c,'0');false}}}macro_rules!read_integer_inner{($t:ty,$cin:ident)=>{{let mut res=0;let mut b=$cin.buffer();debug_assert!(b.len()!=0);let mut p=0;while{if p==b.len(){$cin.consume(p);p=0;b=$cin.buffer();debug_assert!(b.len()!=0);}!b[p].is_ascii_whitespace()}{res*=10;res+=(b[p]-b'0')as$t;p+=1;}$cin.consume(p);res}};}macro_rules!make_unsigned_cinable{($t:ty)=>{impl Cinable for$t{fn read_from(cin:&mut Cin)->Self{cin.discard_whitespace();read_integer_inner!($t,cin)}}};}macro_rules!make_signed_cinable{($t:ty)=>{impl Cinable for$t{fn read_from(cin:&mut Cin)->Self{cin.discard_whitespace();let b=cin.buffer();debug_assert!(b.len()!=0);let neg=if b[0]==b'-'{cin.consume(1);true}else{false};let res=read_integer_inner!(<$t as Integer>::AsUnsigned,cin);if neg{res.overflowing_neg().0 as$t}else{res as$t}}}};}make_unsigned_cinable!(u8);make_unsigned_cinable!(u16);make_unsigned_cinable!(u32);make_unsigned_cinable!(u64);make_unsigned_cinable!(u128);make_unsigned_cinable!(usize);make_signed_cinable!(i8);make_signed_cinable!(i16);make_signed_cinable!(i32);make_signed_cinable!(i64);make_signed_cinable!(i128);make_signed_cinable!(isize);}mod cout{use crate::__cargo_equip::preludes::hcpl_io::*;use hcpl_integer::Integer;use std::io::Write;pub struct Cout<'a>{buffer:[u8;Cout::BUFFER_SIZE],end:usize,stdout:std::io::StdoutLock<'a>,}impl<'a>Cout<'a>{const BUFFER_SIZE:usize=1<<17;pub fn new(stdout:&'a std::io::Stdout)->Self{Self{buffer:[0;Self::BUFFER_SIZE],end:0,stdout:stdout.lock(),}}pub fn flush(&mut self){self.stdout.write_all(&self.buffer[..self.end]).unwrap();self.end=0;}pub fn real_flush(&mut self){self.flush();self.stdout.flush().unwrap();}pub fn flush_if_too_long(&mut self,n:usize){if self.end+n>Self::BUFFER_SIZE{self.flush()}}pub fn write<T:Coutable>(&mut self,x:T)->&mut Self{x.write_to(self);self}}impl<'a>Drop for Cout<'a>{fn drop(&mut self){self.flush();}}pub trait Coutable{fn write_to(&self,cout:&mut Cout);}impl Coutable for char{fn write_to(&self,cout:&mut Cout){cout.flush_if_too_long(1);cout.buffer[cout.end]=*self as u8;cout.end+=1;}}impl Coutable for&str{fn write_to(&self,cout:&mut Cout){for chunk in self.as_bytes().chunks(Cout::BUFFER_SIZE){cout.flush_if_too_long(chunk.len());cout.buffer[cout.end..cout.end+chunk.len()].copy_from_slice(chunk);cout.end+=chunk.len();}}}macro_rules!write_integer_inner{($cout:ident,$rest:ident,$buf:ident,$end:ident)=>{$cout.flush_if_too_long($buf.len());loop{$end-=1;$buf[$end]=($rest%10)as u8+b'0';$rest/=10;if$rest==0{break;}}};}macro_rules!make_unsigned_coutable{($t:ty)=>{impl Coutable for$t{fn write_to(&self,cout:&mut Cout){let mut rest=*self;let mut buf=[0u8;<$t as Integer>::BASE_10_MAX_LENGTH];let mut end=buf.len();write_integer_inner!(cout,rest,buf,end);cout.buffer[cout.end..cout.end+buf.len()-end].copy_from_slice(&buf[end..]);cout.end+=buf.len()-end;}}};}macro_rules!make_signed_coutable{($t:ty)=>{impl Coutable for$t{fn write_to(&self,cout:&mut Cout){let neg=*self<0;let mut rest=self.overflowing_abs().0 as<$t as Integer>::AsUnsigned;let mut buf=[0u8;<$t as Integer>::BASE_10_MAX_LENGTH];let mut end=buf.len();write_integer_inner!(cout,rest,buf,end);if neg{end-=1;buf[end]=b'-';}cout.buffer[cout.end..cout.end+buf.len()-end].copy_from_slice(&buf[end..]);cout.end+=buf.len()-end;}}};}make_unsigned_coutable!(u8);make_unsigned_coutable!(u16);make_unsigned_coutable!(u32);make_unsigned_coutable!(u64);make_unsigned_coutable!(u128);make_unsigned_coutable!(usize);make_signed_coutable!(i8);make_signed_coutable!(i16);make_signed_coutable!(i32);make_signed_coutable!(i64);make_signed_coutable!(i128);make_signed_coutable!(isize);}pub mod input_macro{use crate::__cargo_equip::preludes::hcpl_io::*;#[macro_export]macro_rules!__cargo_equip_macro_def_hcpl_io__io__input_macro__make{($cin:ident,$dol:tt)=>{#[allow(unused_macros)]macro_rules!input{($dol($dol tail:tt)*)=>{hcpl_io::input_macro::input_from!($cin;$dol($dol tail)*)};}};}macro_rules!_io__input_macro__make{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_hcpl_io__io__input_macro__make!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_hcpl_io__io__input_macro__input_from{($cin:ident;$var:ident:$type:tt$(+$offset:literal)?$(-$noffset:literal)?,$($tail:tt)*)=>{let$var=hcpl_io::input_macro::read_value!($cin;$type$(+$offset)?$(-$noffset)?);hcpl_io::input_macro::input_from!($cin;$($tail)*);};($cin:ident;mut$var:ident:$type:tt$(+$offset:literal)?$(-$noffset:literal)?,$($tail:tt)*)=>{let mut$var=hcpl_io::input_macro::read_value!($cin;$type$(+$offset)?$(-$noffset)?);hcpl_io::input_macro::input_from!($cin;$($tail)*);};($cin:ident;)=>{};}macro_rules!_io__input_macro__input_from{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_hcpl_io__io__input_macro__input_from!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_hcpl_io__io__input_macro__read_value{($cin:ident;($($inner:tt$(+$offset:literal)?$(-$noffset:literal)?),*))=>{($(hcpl_io::input_macro::read_value!($cin;$inner$(+$offset)?$(-$noffset)?)),*)};($cin:ident;[$inner:tt$(+$offset:literal)?$(-$noffset:literal)?;($($ns:expr),*)])=>{hcpl_tensor::Tensor::from_iter_and_dims(std::iter::repeat_with(||hcpl_io::input_macro::read_value!($cin;$inner$(+$offset)?$(-$noffset)?)),[$($ns),*],)};($cin:ident;[$inner:tt$(+$offset:literal)?$(-$noffset:literal)?;$n:expr])=>{(0..$n).map(|_|hcpl_io::input_macro::read_value!($cin;$inner$(+$offset)?$(-$noffset)?)).collect::<Vec<_>>()};($cin:ident;bytes)=>{{$cin.discard_whitespace();$cin.read_until(|b|b.is_ascii_whitespace())}};($cin:ident;digit)=>{{let digit=$cin.get::<char>()as u8;debug_assert!(b'0'<=digit&&digit<=b'9',"digit = {}",digit as char);digit-b'0'}};($cin:ident;$type:tt$(+$offset:literal)?$(-$noffset:literal)?)=>{($cin.get::<$type>()$(-$offset)?$(+$noffset)?)};}macro_rules!_io__input_macro__read_value{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_hcpl_io__io__input_macro__read_value!{$($tt)*})}pub use crate::__cargo_equip::crates::hcpl_io::{_io__input_macro__input_from as input_from,_io__input_macro__make as make,_io__input_macro__read_value as read_value,};}pub mod output_macro{use crate::__cargo_equip::preludes::hcpl_io::*;#[macro_export]macro_rules!__cargo_equip_macro_def_hcpl_io__io__output_macro__make{($cout:ident,$dol:tt)=>{#[allow(unused_macros)]macro_rules!out{($dol($dol tail:tt)*)=>{hcpl_io::output_macro::out_to!($cout;$dol($dol tail)*)};}#[allow(unused_macros)]macro_rules!outln{($dol($dol tail:tt)*)=>{hcpl_io::output_macro::out_to!($cout;$dol($dol tail)*;'\n')};}};}macro_rules!_io__output_macro__make{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_hcpl_io__io__output_macro__make!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_hcpl_io__io__output_macro__out_to{($cout:ident;$head:expr,$($tail:tt)*)=>{$cout.write($head).write(' ');hcpl_io::output_macro::out_to!($cout;$($tail)*);};($cout:ident;$head:expr;$($tail:tt)*)=>{$cout.write($head);hcpl_io::output_macro::out_to!($cout;$($tail)*);};($cout:ident;$head:expr)=>{$cout.write($head);};($cout:ident;)=>{};}macro_rules!_io__output_macro__out_to{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_hcpl_io__io__output_macro__out_to!{$($tt)*})}pub use crate::__cargo_equip::crates::hcpl_io::{_io__output_macro__make as make,_io__output_macro__out_to as out_to};}pub use cin::{Cin,Cinable};pub use cout::{Cout,Coutable};#[macro_export]macro_rules!__cargo_equip_macro_def_hcpl_io__io__prelude{($cin:ident,$cout:ident)=>{let stdin_handle=::std::io::stdin();let stdout_handle=::std::io::stdout();#[allow(unused_variables)]#[allow(unused_mut)]let mut$cin=hcpl_io::Cin::new(&stdin_handle);#[allow(unused_variables)]#[allow(unused_mut)]let mut$cout=hcpl_io::Cout::new(&stdout_handle);hcpl_io::input_macro::make!($cin,$);hcpl_io::output_macro::make!($cout,$);};}macro_rules!_io__prelude{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_hcpl_io__io__prelude!{$($tt)*})}pub use crate::__cargo_equip::crates::hcpl_io::_io__prelude as prelude;}
    }

    pub(crate) mod macros {
        pub mod __hcpl_integer_0_1_0 {}
        pub mod hcpl_io {pub use crate::{__cargo_equip_macro_def_hcpl_io__io__input_macro__input_from as _io__input_macro__input_from,__cargo_equip_macro_def_hcpl_io__io__input_macro__make as _io__input_macro__make,__cargo_equip_macro_def_hcpl_io__io__input_macro__read_value as _io__input_macro__read_value,__cargo_equip_macro_def_hcpl_io__io__output_macro__make as _io__output_macro__make,__cargo_equip_macro_def_hcpl_io__io__output_macro__out_to as _io__output_macro__out_to,__cargo_equip_macro_def_hcpl_io__io__prelude as _io__prelude};}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}

    mod preludes {
        pub mod __hcpl_integer_0_1_0 {}
        pub mod hcpl_io {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::__hcpl_integer_0_1_0 as hcpl_integer;}
    }
}
