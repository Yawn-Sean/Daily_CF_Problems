我们先看这题要我们干啥，总结下来是这样：

- 现有一个有向图，在任意两个顶点之间均有且只有一条边。

- 我们已知这个图里面每个节点的入度（即指向该节点的边）。

- 查询两个节点 $u, v$ 是否有一条路径使得 $u$ 可达 $v$ ，即 $u \to v$ 。

- 找到使得 $u\to v$ 且 $v\to u$ 的 $(u, v)$ ，且使其 $|k_u-k_v|$ 最大化。

- 同时，只允许有一次查询的结果输出为“可达”。

如果这个图只是个普通的有向图，那么我们永远无法做到判断两个点之间是否相互可达，因为我们只能知道一次 $u\to v$ 的信息。所以，我们要进一步挖掘这个图的性质。

这个图其实也常常被成为竞赛图。

试想现在有一场有 $n$ 个选手的比赛，其中选手需要两两对战，每场对战分出胜负，在图中以 $u\to v$ 表示 $u$ 战胜过 $v$ ，那么这个图就跟我们这题遇到的图一模一样了。

接下来的讨论也可以理解为竞赛图的性质，可以简单进行记忆。以下可能出现部分 [图论相关概念](https://oi-wiki.org/graph/concept/)，也会简单涉及 [强连通分量](https://oi-wiki.org/graph/scc/)，如有疑问可以到这里给出的链接里查看。

先展示竞赛图的形态：其有若干个强连通分量，强连通分量缩点后（看成一个点），这些点有唯一拓扑序。强连通分量间的边根据该拓扑序确定方向。

简要说明：

- 有拓扑序——如果缩点后仍然存在环，那么环内点两两可达，应当形成更大的强连通分量，矛盾。

- 拓扑序唯一——不存在环且点之间两两连边，一定可以判断任意两个点的拓扑序列中位置先后关系，因此导出唯一拓扑序。

由此，对于每一个点 $u$ ，我们考虑其所在的强连通分量 $A_u$ ，对于拓扑序在 $A_u$ 前的所有强连通分量中的点 $v$ ，一定有 $u,v$ 之间的边是从 $v$ 到 $u$ 的。因此其入度一定不小于这些强连通分量的总点数（设为 $M$），同时不大于 $M+|A_u|-1$ （最多多出强连通分量中指向其的边），因为拓扑序在其后的联通分中的点一定不形成指向 $u$ 的边。

于是，我们可以发现，按照拓扑序考虑强连通分量，其入度范围是不重合的，且入度是单调递增的。

因此我们得到了重要结论：在竞赛图中，用数组 $k$ 表示入度，则如果 $k_u\leq k_v$ ，则 $u\to v$ 。

证明：

- 如果 $u, v$ 在同一强连通分量内，显然相互可达。

- 否则 $u$ 所在的强连通分量的拓扑序一定比 $v$ 所在的强连通分量更小，因此边 $(u,v)$ 是从 $u$ 指向 $v$ 的。

于是，我们可以预先根据入度情况，得到每一对点 $(u,v)$ 的其中一组可达性，因此可以根据 $|k_u-k_v|$ 减小的顺序遍历 $(u,v)$ ，直到其反向的可达关系成立，即可输出答案。这种方式的复杂度可以到达 $\mathcal{O}(n^2)$ ，因为最坏情况下需要全部查询一次。

**拓展内容：** 那么有无更好的方法呢？事实上，我们可以通过入度 **直接找到强连通分量** 。

怎么完成呢？我们考虑根据入度从小到大排序的序列 $a_1, a_2,\dots, a_n$ ，考虑其前缀 $a_1, a_2,\dots, a_k$ ，看其是否包含拓扑序中前若干个联通分量中所有的点。

如果其包含前若干个联通分量中所有的点，那么剩下的点对其不形成入度，于是得到入度应为 $\frac{k(k-1)}{2}$ 。

否则，若其不能包含前若干个强连通分量中的所有的点，那么我们考虑这 $k$ 个点构成的分量有多少入度和出度，若两者之差非 $0$ ，则其总入度不为 $\frac{k(k-1)}{2}$ . 事实上，我们相当于只考虑 $a_k$ 所在强连通分量产生的贡献。而我们选取的是其中入度最小的几个点，在该强连通分量内部也满足这一性质，因此总是入度小于出度（可自行尝试推导）。

于是我们得到了 $a_1, a_2,\dots, a_k$ 构成前若干个强连通分量的充要条件，我们可以找到相邻两个强连通分量的前缀之差，从而确定中间对应的强连通分量。最后每个强连通分量寻找答案，取最大值即可。

时间复杂度为 $\mathcal{O}(n)$ ，且无需查询，因为使用的是桶排序。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    degs = LII()
    
    # 桶排序
    stats = [[] for _ in range(n)]
    for i in range(n):
        stats[degs[i]].append(i)
    
    cnt = 0
    cur = 0
    idx = -1
    
    res = -1
    a = b = -1
    for i in range(n):
        for x in stats[i]:
            cur += degs[x]
            cnt += 1
            if idx == -1:
                idx = x
            if cur == cnt * (cnt - 1) // 2:
                if idx != x and degs[x] - degs[idx] > res:
                    res = degs[x] - degs[idx]
                    a, b = idx, x
                idx = -1
    
    print('!', a + 1, b + 1)
    return 
```
