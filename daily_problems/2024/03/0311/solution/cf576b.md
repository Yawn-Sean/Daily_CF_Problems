**提示 1：** 这是一个给定排列的图论问题。一个排列能转换为什么图？

**提示 2：** 尝试先选取一条边，看这条边能产生哪些边。哪些是一定不能连的？你能借此得出必要条件吗？

**提示 3：** 对于满足必要条件的排列，给出你构造的图。

对于一个排列，如果与图需要结合，我们常常使用如下方式构建有向图：

对于每个位置 $i$ 的对应数值 $p_i$ ，我们连边 $i\to p_i$ ，由此可以得到一个 $n$ 个顶点， $n$ 条边的有向图。

注意，这个图是由一系列环组成的。（可以自己举几个例子理解这一个结论）

如果有一个环大小为 $1$ ，相当于有一个点 $i$ 满足 $p_i=i$ ，此时，从这个点出发连接其他所有点即可，容易验证满足条件。下面认为所有环大小都不小于 $2$ .

于是，我们考虑边 $(u, v)$ 如果存在，应当存在哪些新的边。

首先考虑 $(u, v)$ 都在同一个环内。那么这个环的大小。

设环的大小为 $k$ 。称边 $(u, v)$ 到边 $(p_u, p_v)$ 的映射为一次变换，则 $k$ 次变换后， $u$ 才能变回 $u$ 。

- 如果环的长度是奇数，变换过程中不会同时出现 $(u, v)$ 与 $(v, u)$ （可以考虑 $(u, v)$ 和 $(v, u)$ 在环中下标差的奇偶性是不同的，但是变换不改变这个奇偶性）。

    - 因此遇到的 $k$ 条边都是不同的。总共 $k$ 个点画 $k$ 条边，一定成环，矛盾。

    - 于是，此时一定不能有环内的点构成边。

- 如果环的长度是偶数，则上述过程中， $(u,v),(v,u)$ 可能同时出现，因此可能连出 $k /\frac{k}{2}$ 条边。前一种情况一定成环，故排除。因此，这里可能成 $\frac{k}{2}$ 条边，我们保留这种可能。

接下来考虑环间连边。设两个环的大小分别为 $size_u, size_v$ ，不妨设 $size_u\geq size_v\geq 2$。假设这里先连边 $(u, v)$ 。

在 $(u, v)$ 经过变换的过程中， $u$ 循环周期是 $size_u$ ，$v$ 循环周期是 $size_v$ ，故 $(u, v)$ 的循环周期是 $\mathrm{lcm}(size_u, size_v)$ ，也就产生了这么多新的边。

如果 $size_u$ 不能被 $size_v$ 整除，产生的新边数量 $\mathrm{lcm}(size_u, size_v)\geq 2size_u\geq size_u+size_v$ ，因此边数大于点数，一定成环，矛盾。

于是有边相连的两个环，一定满足一个环的大小是另一个环的倍数。

于是，为了所有环之间连通，**一定有所有环的大小都是最小环的倍数** 。

而同时，所有直接相连的环间连的边的个数为较大环的大小。

为了使环之间两两连通，我们考虑环的大小从小到大为 $size_1,size_2,\dots,size_m$ 。

则环间连边最小值为 $n-size_1$ ，可以考虑完全图的最小生成树。完全图的边权为 $\max(size_i,size_j)$ .

而如果不取最小值，连边数量至少增加一个 $size_1$ ，因为边数总是 $size_1$ 的倍数，因此至少为 $n-size_1+size_1=n$ ，与不成环矛盾。

于是环间边一定大小为 $n-size_1$ ，接下来考虑环内边。

一定有一个环内成边，否则目前边数不为 $n-1$ ，形成的不是树。如果这个环的大小大于 $size_1$ ，则其大小至少为 $2size_1$ ，根据之前的推导，形成至少 $size_1$ 条边，总边数至少为 $size_1$ ，矛盾。

于是只能选取大小为 $size_1$ 的环其中连边，这样，假设有 $k$ 个这样的环连边，总边数为 $n-size_1+k\frac{size_1}{2}=n+
\frac{k-2}{2}size_1$ 。

若 $k\geq 2$ ，则边数不小于 $n$ 矛盾。

故 $k=1$ ，解方程 $n-\frac{1}{2}size_1=n-1$ 得到 $size_1=2$ .

综上这一段推导，仅当以下条件之一成立时，才可能可以构造图：

- 存在 $i$ 使得 $p_i=i$ 。

- 存在二元环，且剩下的环大小均是 $2$ 的倍数。

前一种情况我们已经给出构造。

对于后者，我们对每个环进行二染色。先连接二元环，再根据二染色结果，选取二元环中与其同色的节点进行相连。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    perm = LGMI()
    for i in range(n):
        if perm[i] == i:
            print('YES')
            for j in range(n):
                if j != i:
                    print(i + 1, j + 1)
            return
    
    for i in range(n):
        if perm[perm[i]] == i:
            vis = [-1] * n
            vis[i] = vis[perm[i]] = 2
            for j in range(n):
                if vis[j] == -1:
                    vis[j] = 0
                    while vis[perm[j]] == -1:
                        vis[perm[j]] = vis[j] ^ 1
                        j = perm[j]
                    if vis[perm[j]] == vis[j]:
                        print('NO')
                        return
            print('YES')
            print(i + 1, perm[i] + 1)
            for j in range(n):
                if vis[j] == 0:
                    print(i + 1, j + 1)
                elif vis[j] == 1:
                    print(perm[i] + 1, j + 1)
            return
    print('NO')
    return
```
