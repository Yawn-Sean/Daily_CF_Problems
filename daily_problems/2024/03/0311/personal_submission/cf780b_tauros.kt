import kotlin.math.abs
import kotlin.math.sqrt

typealias string = String
inline fun <T> ternarySearch(reps: Int, l: Double, r: Double, chooseLeft: (left: Pair<Double, T>, right: Pair<Double, T>) -> Boolean, calc: (Double) -> T): Pair<Double, T> {
    val ratio = (sqrt(5.0) + 1.0) / 2
    var (st, ed) = l to r
    var cur = (ed + ratio * st) / (ratio + 1); var res = calc(cur)
    repeat(reps) {
        val (low, high) =
            if (cur - st < ed - cur) {
                val next = (ed * ratio + st) / (ratio + 1); val judge = calc(next)
                (cur to res) to (next to judge)
            } else {
                val next = (ed + ratio * st) / (ratio + 1); val judge = calc(next)
                (next to judge) to (cur to res)
            }
        if (chooseLeft(low, high)) {
            cur = low.first; res = low.second; ed = high.first
        } else {
            cur = high.first; res = high.second; st = low.first
        }
    }
    return cur to res
}
inline fun <T> ternarySearch(l: Double, r: Double, chooseLeft: (left: Pair<Double, T>, right: Pair<Double, T>) -> Boolean, calc: (Double) -> T) = ternarySearch(40, l, r, chooseLeft, calc)

/**
 * generated by kotlincputil@tauros
 */
fun main(args: Array<String>) {
    // https://codeforces.com/problemset/problem/780/B
    // 练习下黄金分割三分法
    val n = readln().toInt()
    val positions = readln().split(" ").map(string::toInt).toIntArray()
    val velocities = readln().split(" ").map(string::toInt).toIntArray()

    val (l, r) = positions.min().toDouble() to positions.max().toDouble()
    val (_, ans) = ternarySearch(l, r, { a, b -> a.second < b.second }) { location ->
        (0 until n).maxOf { abs(positions[it] - location) / velocities[it] }
    }
    println(string.format("%.8f", ans))
}