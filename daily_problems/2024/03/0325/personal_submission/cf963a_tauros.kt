class MOD {
    companion object {
        private val INV_MAP = mutableMapOf<Int, MutableMap<Int, Int>>()
        private val INV_LONG_MAP = mutableMapOf<Int, MutableMap<Long, Int>>()
        var globalMod: Int = 0
        fun inv(num: Int): Int = INV_MAP.computeIfAbsent(globalMod) { mutableMapOf() }.computeIfAbsent(num) { inv(num, globalMod) }
        fun inv(num: Long): Int = INV_LONG_MAP.computeIfAbsent(globalMod) { mutableMapOf() }.computeIfAbsent(num) { inv(num, globalMod.toLong()).toInt() }
        fun pow(num: Long, p: Long): Int {
            var (pow, a) = p to num
            if (a >= globalMod) a %= globalMod.toLong()
            var res: Long = 1
            while (pow > 0) {
                if (pow and 1 == 1L) res = res * a % globalMod
                a = a * a % globalMod
                pow = pow shr 1
            }
            return res.toInt()
        }
        fun regular(num: Int): Int = if (num in 0 until globalMod) num else {
            val r = num % globalMod
            if (r < 0) r + globalMod else r
        }
        fun regular(num: Long): Int = if (num in 0 until globalMod) num.toInt() else {
            val r = (num % globalMod).toInt()
            if (r < 0) r + globalMod else r
        }
        fun add(a: Int, b: Int) = regular(a + b)
        fun sub(a: Int, b: Int) = regular(a - b)
        fun mul(a: Int, b: Int) = regular(a.toLong() * b)
        fun div(a: Int, b: Int) = regular(a.toLong() * inv(regular(b)))
        inline fun <T> decorate(mod: Int, process: Companion.() -> T): T {
            val preGlobal = globalMod
            globalMod = mod
            val res = process(Companion)
            globalMod = preGlobal
            return res
        }
    }
}
fun exgcd(a: Int, b: Int): IntArray {
    // gcd, x, y
    if (b == 0) return intArrayOf(a, 1, 0)
    // x = y0; y = x0 - (a / b) * y0;
    val (gcd, x0, y0) = exgcd(b, a % b)
    return intArrayOf(gcd, y0, x0 - a / b * y0)
}
fun exgcd(a: Long, b: Long): LongArray {
    // gcd, x, y
    if (b == 0L) return longArrayOf(a, 1, 0)
    // x = y0; y = x0 - (a / b) * y0;
    val (gcd, x0, y0) = exgcd(b, a % b)
    return longArrayOf(gcd, y0, x0 - a / b * y0)
}
fun inv(a: Long, p: Long): Long {
    val (gcd, inv, _) = exgcd(a, p)
    return if (gcd != 1L) -1 else (inv + p) % p
}
fun inv(a: Int, p: Int): Int {
    val (gcd, inv, _) = exgcd(a, p)
    return if (gcd != 1) -1 else (inv + p) % p
}
infix fun Int.ma(other: Int): Int = MOD.add(this, other)
infix fun Int.md(other: Int): Int = MOD.div(this, other)
infix fun Int.mm(other: Int): Int = MOD.mul(this, other)
infix fun Int.ms(other: Int): Int = MOD.sub(this, other)
inline fun <T> withMod(mod: Int, process: MOD.Companion.() -> T) = MOD.decorate(mod, process)

/**
 * generated by kotlincputil@tauros
 */
fun main(args: Array<String>) {
    // https://codeforces.com/problemset/problem/963/A
    // 以为是二项式定理啥的，想了N久发现直接求就好
    // 服了，等比数列求和公式是：a1*(1-q^n)/(1-q)
    // 注意判断下公比是不是1
    val (n, a, b, k) = readln().split(" ").map { it.toInt() }
    val seq = readln().toCharArray()

    withMod(1e9.toInt() + 9) {
        var ans = 0
        val q = pow(b.toLong(), k.toLong()) md pow(a.toLong(), k.toLong())
        for (i in 0 until k) {
            val first = pow(a.toLong(), n - i.toLong()) mm pow(b.toLong(), i.toLong())
            val cnt = (n + 1) / k
            val sum = if (q == 1) first mm cnt
                else first mm (pow(q.toLong(), cnt.toLong()) ms 1) md (q ms 1)
            ans = sum mm (if (seq[i] == '-') -1 else 1) ma ans
        }
        println(ans)
    }
}