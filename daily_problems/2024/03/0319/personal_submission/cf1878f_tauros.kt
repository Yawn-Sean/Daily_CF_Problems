import java.util.function.BiConsumer
import java.util.function.Function
import java.util.function.BiFunction

typealias int = Int
fun sqrt(n: Long): Long {
    if (n == 0L) return 0
    var x: Long = 1
    var decreased = false
    while (true) {
        val nx = x + n / x shr 1
        if (x == nx || nx > x && decreased) break
        decreased = nx < x
        x = nx
    }
    return x
}
fun sqrt(n: Int) = sqrt(n.toLong()).toInt()
typealias string = String
inline fun <reified K, reified V> mmo(vararg pairs: Pair<K, V>) = mutableMapOf(*pairs)
class DefaultMap<K, V, D : Map<K, V>>(protected val delegate: D, protected val default: (K) -> V) : Map<K, V> {
    override val entries: Set<Map.Entry<K, V>>
        get() = delegate.entries
    override val keys: Set<K>
        get() = delegate.keys
    override val size: Int
        get() = delegate.size
    override val values: Collection<V>
        get() = delegate.values

    override fun containsKey(key: K) = delegate.containsKey(key)
    override fun containsValue(value: V) = delegate.containsValue(value)
    override fun forEach(action: BiConsumer<in K, in V>) = delegate.forEach(action)
    override fun getOrDefault(key: K, defaultValue: V) = delegate.getOrDefault(key, defaultValue)
    override fun isEmpty() = delegate.isEmpty()
    override operator fun get(key: K) = delegate[key] ?: default(key)
}
open class DefaultMutableMap<K, V, D : MutableMap<K, V>>(protected val delegate: D, protected val default: (K) -> V) : MutableMap<K, V> {
    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>
        get() = delegate.entries
    override val keys: MutableSet<K>
        get() = delegate.keys
    override val size: Int
        get() = delegate.size
    override val values: MutableCollection<V>
        get() = delegate.values

    override fun clear() = delegate.clear()
    override fun compute(key: K, remappingFunction: BiFunction<in K, in V?, out V?>) = delegate.compute(key, remappingFunction)
    override fun computeIfAbsent(key: K, mappingFunction: Function<in K, out V>) = delegate.computeIfAbsent(key, mappingFunction)
    override fun computeIfPresent(key: K, remappingFunction: BiFunction<in K, in V & Any, out V?>) = delegate.computeIfPresent(key, remappingFunction)
    override fun merge(key: K, value: V & Any, remappingFunction: BiFunction<in V & Any, in V & Any, out V?>) = delegate.merge(key, value, remappingFunction)
    override fun put(key: K, value: V) = delegate.put(key, value)
    override fun putAll(from: Map<out K, V>) = delegate.putAll(from)
    override fun putIfAbsent(key: K, value: V) = delegate.putIfAbsent(key, value)
    override fun remove(key: K) = delegate.remove(key)
    override fun remove(key: K, value: V) = delegate.remove(key, value)
    override fun replace(key: K, oldValue: V, newValue: V) = delegate.replace(key, oldValue, newValue)
    override fun replace(key: K, value: V) = delegate.replace(key, value)
    override fun replaceAll(function: BiFunction<in K, in V, out V>) = delegate.replaceAll(function)
    override fun containsKey(key: K) = delegate.containsKey(key)
    override fun containsValue(value: V) = delegate.containsValue(value)
    override fun forEach(action: BiConsumer<in K, in V>) = delegate.forEach(action)
    override fun getOrDefault(key: K, defaultValue: V) = delegate.getOrDefault(key, defaultValue)
    override fun isEmpty() = delegate.isEmpty()
    override operator fun get(key: K) = delegate[key] ?: default(key)
}
fun <K, V> Map<K, V>.default(default: (K) -> V) = DefaultMap(this, default)
fun <K, V> MutableMap<K, V>.default(default: (K) -> V) = DefaultMutableMap(this, default)

/**
 * generated by kotlincputil@tauros
 */
fun main(args: Array<String>) {
    // https://codeforces.com/problemset/problem/1878/F
    // d()是积性函数，当gcd(n, a)=1s时，d(n*a)=d(n)*d(a)
    // 然后d(n)*d(a)=n，那么d(n)一定是n的约数
    // d可以用质因数分解后求下组合数，很好做
    fun frac(num: int) = buildMap {
        var iter = num
        for (i in 2 .. sqrt(num)) {
            if (iter % i == 0) {
                var cnt = 0
                while (iter % i == 0) {
                    iter /= i; cnt += 1
                }
                put(i, cnt)
            }
        }
        if (iter > 1) put(iter, 1)
    }.default { 0 }
    val cases = readln().toInt()
    repeat(cases) {
        val (n, q) = readln().split(" ").map(string::toInt)

        val initFrac = frac(n)
        val curFrac = mmo<int, int>().default { 0 }.apply { putAll(initFrac) }
        println(buildString {
            repeat(q) {
                val line = readln().split(" ").map(string::toInt)
                if (line.size == 1) {
                    curFrac.clear()
                    curFrac.putAll(initFrac)
                } else {
                    val x = line[1]
                    val xFrac = frac(x)
                    for ((p, cnt) in xFrac) curFrac[p] += cnt

                    val d = curFrac.map { (_, cnt) -> cnt + 1 }.fold(1, int::times)
                    val dFrac = frac(d)
                    val ans = dFrac.all { (p, cnt) -> cnt <= curFrac[p] }
                    append(if (ans) "YES" else "NO")
                    append("\n")
                }
            }
        })
    }
}