import java.io.InputStream
import java.io.Writer
import java.io.OutputStreamWriter
import java.io.BufferedWriter
import java.io.OutputStream
import java.io.PrintWriter
import java.io.Closeable

open class FastReader(private val input: InputStream, bufCap: Int = 8192) {
    companion object {
        private const val NC = 0.toChar()
    }

    private val buf = ByteArray(bufCap)
    private var bId = 0
    private var size = 0
    private var c = NC
    private val char: Char
        get() {
            while (bId == size) {
                size = input.read(buf) // no need for checked exceptions
                if (size == -1) return NC
                bId = 0
            }
            return buf[bId++].toInt().toChar()
        }

    private fun isWhitespace(c: Char) = c.code !in 33..126

    private fun skip(): Char {
        var b: Char
        while (char.also { b = it } != NC && isWhitespace(b));
        return b
    }

    fun ns() = buildString {
        while (true) {
            c = char
            if (!isWhitespace(c)) {
                break
            }
        }
        append(c)
        while (true) {
            c = char
            if (isWhitespace(c)) {
                break
            }
            append(c)
        }
    }

    fun ns(n: Int): CharArray {
        val buf = CharArray(n)
        var b = skip()
        var p = 0
        while (p < n && !isWhitespace(b)) {
            buf[p++] = b
            b = char
        }
        return if (n == p) buf else buf.copyOf(p)
    }

    fun ni(): Int {
        var neg = false
        if (c == NC) c = char
        while (c < '0' || c > '9') {
            if (c == '-') neg = true
            c = char
        }
        var res = 0
        while (c in '0'..'9') {
            res = (res shl 3) + (res shl 1) + (c - '0')
            c = char
        }
        return if (neg) -res else res
    }

    fun nl(): Long {
        var neg = false
        if (c == NC) c = char
        while (c < '0' || c > '9') {
            if (c == '-') neg = true
            c = char
        }
        var res = 0L
        while (c in '0'..'9') {
            res = (res shl 3) + (res shl 1) + (c - '0')
            c = char
        }
        return if (neg) -res else res
    }

    fun na(n: Int) = IntArray(n) { ni() }
    fun nal(n: Int) = LongArray(n) { nl() }
    fun nad(n: Int) = DoubleArray(n) { nd() }
    fun nm(n: Int, m: Int) = Array(n) { ns(m) }
    fun nmi(n: Int, m: Int) = Array(n) { na(m) }
    fun nd() = ns().toDouble()
    fun nc() = skip()
}
open class FastWriter : Closeable {
    private val writer: PrintWriter

    constructor(output: OutputStream, bufCap: Int = 8192) {
        this.writer = PrintWriter(BufferedWriter(OutputStreamWriter(output), bufCap))
    }

    constructor(writer: Writer, bufCap: Int = 8192) {
        this.writer = PrintWriter(BufferedWriter(writer, bufCap))
    }

    override fun close() {
        writer.flush()
        try {
            writer.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun print(b: Boolean) = writer.print(b)
    fun print(c: Char) = writer.print(c)
    fun print(i: Int) = writer.print(i)
    fun print(l: Long) = writer.print(l)
    fun print(f: Float) = writer.print(f)
    fun print(d: Double) = writer.print(d)
    fun print(s: CharArray) = writer.print(s)
    fun print(s: String?) = writer.print(s)
    fun print(obj: Any?) = writer.print(obj)
    fun println() = writer.println()
    fun println(x: Boolean) = writer.println(x)
    fun println(x: Char) = writer.println(x)
    fun println(x: Int) = writer.println(x)
    fun println(x: Long) = writer.println(x)
    fun println(x: Float) = writer.println(x)
    fun println(x: Double) = writer.println(x)
    fun println(x: CharArray) = writer.println(x)
    fun println(x: String) = writer.println(x)
    fun println(x: Any) = writer.println(x)
    fun printf(format: String, vararg args: Any?) = writer.format(format, *args)
    fun flush() = writer.flush()
}
inline fun <reified T> ar(size: Int, init: (Int) -> T) = Array(size) { init(it) }
inline fun findFirst(n: Int, judge: (Int) -> Boolean): Int {
    var l = 0
    var r = n
    while (l < r) {
        val mid = l + (r - l) / 2
        if (judge(mid)) r = mid
        else l = mid + 1
    }
    return l
}
typealias int = Int
inline fun iar(size: Int, init: (Int) -> Int = { 0 }) = IntArray(size) { init(it) }
inline fun <R> IntArray.bitQuery(pos: Int, initial: R, operation: (R, Int) -> R): R {
    var iter = pos
    var ans = initial
    while (iter > 0) {
        ans = operation(ans, this[iter])
        iter -= iter.takeLowestOneBit()
    }
    return ans
}
inline fun IntArray.bitUpdateWithIndex(pos: Int, calc: IntArray.(Int) -> Unit) {
    if (pos <= 0) return
    var iter = pos
    while (iter < size) {
        calc(iter)
        iter += iter.takeLowestOneBit()
    }
}

/**
 * generated by kotlincputil@tauros
 */
private val bufCap = 65536
private val rd = FastReader(System.`in`, bufCap)
private val wt = FastWriter(System.out, bufCap)
private fun solve() {
    // https://codeforces.com/problemset/problem/1190/D
    // 不难，当成网格图来算就好了，注意避免重复计算
    val n = rd.ni()
    val points = ar(n) { rd.na(2) }

    val sortedX = points.map { it[0] }.sorted().distinct()
    fun IntArray.query(pos: int) = this.bitQuery(pos, 0, int::plus)
    fun IntArray.update(pos: int) {
        if (query(pos) - query(pos - 1) == 0) this.bitUpdateWithIndex(pos) { this[it] += 1 }
    }
    val cap = sortedX.size
    val bit = iar(cap + 1)

    val sorted = points.sortedWith { a, b -> if (a[1] == b[1]) a[0].compareTo(b[0]) else -a[1].compareTo(b[1]) }
    var (i, ans) = 0 to 0L
    while (i < sorted.size) {
        var j = i
        val line = buildList {
            while (j < sorted.size && sorted[j][1] == sorted[i][1]) {
                val x = findFirst(cap) { sortedX[it] >= sorted[j][0] } + 1
                add(x); bit.update(x)
                j += 1
            }
        }
        var res = 0L
        for (k in line.indices) {
            val x = line[k]
            val next = if (k + 1 < line.size) line[k + 1] else cap + 1
            res += bit.query(x) * (bit.query(next - 1) - bit.query(x) + 1L)
        }
        ans += res; i = j
    }
    wt.println(ans)
}
fun main(args: Array<String>) {
    solve()
    wt.flush()
}