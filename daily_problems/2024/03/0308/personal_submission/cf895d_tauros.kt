class MOD {
    companion object {
        private val INV_MAP = mutableMapOf<Int, MutableMap<Int, Int>>()
        private val INV_LONG_MAP = mutableMapOf<Int, MutableMap<Long, Int>>()
        var globalMod: Int = 0
        fun inv(num: Int): Int = INV_MAP.computeIfAbsent(globalMod) { mutableMapOf() }.computeIfAbsent(num) { inv(num, globalMod) }
        fun inv(num: Long): Int = INV_LONG_MAP.computeIfAbsent(globalMod) { mutableMapOf() }.computeIfAbsent(num) { inv(num, globalMod.toLong()).toInt() }
        fun pow(num: Long, p: Long): Int {
            var (pow, a) = p to num
            if (a >= globalMod) a %= globalMod.toLong()
            var res: Long = 1
            while (pow > 0) {
                if (pow and 1 == 1L) res = res * a % globalMod
                a = a * a % globalMod
                pow = pow shr 1
            }
            return res.toInt()
        }
        fun regular(num: Int): Int = if (num in 0 until globalMod) num else {
            val r = num % globalMod
            if (r < 0) r + globalMod else r
        }
        fun regular(num: Long): Int = if (num in 0 until globalMod) num.toInt() else {
            val r = (num % globalMod).toInt()
            if (r < 0) r + globalMod else r
        }
        fun add(a: Int, b: Int) = regular(a + b)
        fun sub(a: Int, b: Int) = regular(a - b)
        fun mul(a: Int, b: Int) = regular(a.toLong() * b)
        fun div(a: Int, b: Int) = regular(a.toLong() * inv(regular(b)))
        inline fun <T> decorate(mod: Int, process: Companion.() -> T): T {
            val preGlobal = globalMod
            globalMod = mod
            val res = process(Companion)
            globalMod = preGlobal
            return res
        }
    }
}
fun exgcd(a: Int, b: Int): IntArray {
    // gcd, x, y
    if (b == 0) return intArrayOf(a, 1, 0)
    // x = y0; y = x0 - (a / b) * y0;
    val (gcd, x0, y0) = exgcd(b, a % b)
    return intArrayOf(gcd, y0, x0 - a / b * y0)
}
fun exgcd(a: Long, b: Long): LongArray {
    // gcd, x, y
    if (b == 0L) return longArrayOf(a, 1, 0)
    // x = y0; y = x0 - (a / b) * y0;
    val (gcd, x0, y0) = exgcd(b, a % b)
    return longArrayOf(gcd, y0, x0 - a / b * y0)
}
fun inv(a: Long, p: Long, invPModA: Long): Long {
    val ans = -p / a * invPModA % p
    return if (ans < 0) ans + p else ans
}
fun inv(a: Int, p: Int): Int {
    val (gcd, inv, _) = exgcd(a, p)
    return if (gcd != 1) -1 else (inv + p) % p
}
fun inv(a: Long, p: Long): Long {
    val (gcd, inv, _) = exgcd(a, p)
    return if (gcd != 1L) -1 else (inv + p) % p
}
fun inv(a: Int, p: Int, invPModA: Int) = inv(a.toLong(), p.toLong(), invPModA.toLong()).toInt()
infix fun Int.ma(other: Int): Int = MOD.add(this, other)
infix fun Int.mm(other: Int): Int = MOD.mul(this, other)
inline fun <T> withMod(mod: Int, process: MOD.Companion.() -> T) = MOD.decorate(mod, process)
inline fun iar(size: Int, init: (Int) -> Int = { 0 }) = IntArray(size) { init(it) }
open class Comb(val cap: Int, val mod: Int) {
    val fac = IntArray(cap + 1)
    val inv = IntArray(cap + 1)
    val facInv = IntArray(cap + 1)
    init {
        fac[0] = 1; facInv[0] = 1
        for (i in 1..cap) {
            inv[i] = if (i == 1) 1 else inv(i, mod, inv[mod % i])
            fac[i] = (fac[i - 1].toLong() * i % mod).toInt()
            facInv[i] = (facInv[i - 1].toLong() * inv[i] % mod).toInt()
        }
    }
    fun c(n: Int, m: Int): Int {
        return if (n == m) 1 else if (n !in 0..cap || m !in 0..n) 0 else {
            // C(n, m) = n! / m! / (n - m)!
            (fac[n].toLong() * facInv[m] % mod * facInv[n - m] % mod).toInt()
        }
    }
    fun a(n: Int, m: Int): Int {
        return if (n !in 0..cap || m !in 0..n) 0 else {
            // A(n, m) = n! / (n - m)!
            (fac[n].toLong() * facInv[n - m] % mod).toInt()
        }
    }
}

/**
 * generated by kotlincputil@tauros
 */
fun main(args: Array<String>) {
    // https://codeforces.com/problemset/problem/895/D
    // 设从位置i开始的后缀总长度为len
    // 且从位置i开始的后缀字符x的总个数为cnt[x]
    // 那么位置i可选的字符集为{l, l+1, ..., r-1, r}的情况下的排列数为：
    // (len-1)! / (cnt[0]! * cnt[1]! * ... * cnt[25]!) * (cnt[l] + cnt[l+1] + ... + cnt[r])
    // 这个值里的 (len-1)! 和 1/(cnt[0]! * cnt[1]! * ... * cnt[25]!) 可以O(1)维护
    // 后者就是inv((cnt[0]! * cnt[1]! * ... * cnt[25]!)) = inv(cnt[0]!) * inv(cnt[1]!) * ... * inv(cnt[25]!)
    // 然后(cnt[l] + cnt[l+1] + ... + cnt[r])可以O(26)求
    // 接下来看怎么算合法排列，分为以下情况，从左往右考虑每个位置：
    // - a还未修改过，当前a[i]为第一个比b[i]小的位置，只考虑当前位置比b[i]小，产生贡献是 { a[i]+1, ..., b[i]-1 }
    // - a还未修改过，前面已经比b[i]小了，产生贡献是 { a[i]+1, ..., 25 }
    // - a已经修改了，前面和b的前缀完全相等，只考虑当前位置比b[i]小，产生贡献是 { 0, ..., b[i]-1 }
    // 可以看到，有两种状态，修改了a和未修改a
    // 对修改和未修改的分别维护前面提到的逆元累乘积和字符个数即可
    val a = readln().toCharArray()
    val b = readln().toCharArray()

    withMod(1e9.toInt() + 7) {
        val n = a.size
        val comb = Comb(n, globalMod)

        val cnt = iar(26)
        var perm = 1
        for (i in n - 1 downTo 0) {
            val c = a[i] - 'a'
            cnt[c] += 1
            perm = perm mm comb.inv[cnt[c]]
        }
        val eqCnt = cnt.clone()
        var eqPerm = perm

        var (notModifiedLess, modifiedPreEqGreat) = false to false
        var ans = 0
        for (i in 0 until n) {
            val (ac, bc) = a[i] - 'a' to b[i] - 'a'
            val len = n - i
            val part = comb.fac[len - 1] mm perm
            val eqPart = comb.fac[len - 1] mm eqPerm
            perm = perm mm cnt[ac]
            cnt[ac] -= 1
            if (!notModifiedLess && ac < bc) {
                val sum = (ac + 1 until bc).sumOf { cnt[it] }
                val res = part mm sum
                ans = ans ma res
                if (eqCnt[bc] > 0) {
                    modifiedPreEqGreat = true
                    eqPerm = eqPerm mm eqCnt[bc]
                    eqCnt[bc] -= 1
                } else {
                    eqPerm = eqPerm mm eqCnt[ac]
                    eqCnt[ac] -= 1
                }
                notModifiedLess = true
                continue
            }
            if (notModifiedLess) {
                val sum = (ac + 1 until 26).sumOf { cnt[it] }
                val res = part mm sum
                ans = ans ma res
            } else {
                eqPerm = eqPerm mm eqCnt[ac]
                eqCnt[ac] -= 1
            }
            if (modifiedPreEqGreat) {
                val sum = (0 until bc).sumOf { eqCnt[it] }
                val res = eqPart mm sum
                ans = ans ma res
                if (eqCnt[bc] > 0) {
                    eqPerm = eqPerm mm eqCnt[bc]
                    eqCnt[bc] -= 1
                } else {
                    modifiedPreEqGreat = false
                }
            }
        }
        println(ans)
    }
}