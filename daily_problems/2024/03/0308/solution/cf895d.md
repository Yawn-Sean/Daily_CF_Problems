**提示 1：** 有点像数位 DP，因为考虑的都是某两个数 / 字符串之间满足条件的数 / 字符串的个数。于是也应该从前面往后填。

**提示 2：** 从前往后填字母的过程中，左右两个字符串的限制会变得一个有用一个没用，这比较需要分类讨论。怎么处理可以规避这一点呢？

题意：给定两个字符串 $s_1$ 和 $s_2$ ，求 $s_1$ 字符串打乱顺序后，有多少字符串在 $s_1$ 和 $s_2$ 之间（不允许相等）。

两个长度相等的字符串比较大小，只要两个字符串不相等，否则只需要看第一个不同的字符在哪里就行了，接下来的字符串可以随便选择。

我们可以利用这个特点，从头开始构造我们的结果字符串。

假设从某个位置开始，构造的前缀字符串已经严格大于 $s_1$ 的前缀，严格小于 $s_2$ 的后缀，那么剩下的位置都可以任意选择任意的排序。

假设剩下的各个字母的出现次数为 $c_1, c_2, \dots, c_{26}$ ，那方案数为 $\frac{(c_1+c_2+\dots+c_{26})!}{c_1!c_2!\dots c_{26}!}$ 种。为什么呢？首先假设字符之间两两不同，则有 $(c_1+c_2+\dots+c_{26})!$ 种排列；再考虑其中重复的次数，由于有 $c_1$ 个第一个字符 `'a'`，因此这 $c_1$ 个 `'a'` 打乱顺序不影响排列，以此类推，每个字母形成了 $c_i!$ 个重复的排列；于是，每个排列重复了 $c_1!c_2!\dots c_{26}!$ 次，于是用不考虑字母重复的结果除以之即可。

---

**对上述组合式子的计算**

上述用到了 $n!$ 的取模与 $\frac{1}{n!}$ 的取模。我们应当如何计算呢？

我们首先知道了 $1!=1$ ，于是 $(n+1)!=(n+1)\times n!$ 即可计算所有阶乘的取模值。

而我们可以通过模质数 $p$ 意义下的逆元 $\frac{1}{n!}=(n!)^{p-2}$ 得到第一个数值。

剩下的阶乘逆元可以通过 $\frac{1}{(n-1)!}=n\times\frac{1}{n!}$ 向前推一个个得到。

---

于是我们得到了一个比较直接的解 —— 

- 从头开始考虑字符串，枚举新的位置是什么字符，考虑其是否满足 $s_1$ 和 $s_2$ 的限制。

- 如果此前的前缀字符串就已经严格大于 $s_1$ 或严格小于 $s_2$ ，则这个限制无需考虑，否则需要考虑。

- 如果两侧限制都已经被严格满足，我们直接使用上述的组合式得到剩下字符的可行结果。

但上述讨论不够优雅，因为两侧的限制是不对称的，需要查看两种不同前缀，不容易完成代码的书写。

但事实上，这个问题很像我们的数位 DP，因此我们考虑用类似 $f(r)-f(l-1)$ 的方式进行处理。

我们只需要考虑 $f(s)$ 表示小于 $s$ 的所有字符串的个数，那么我们的问题实际上变为 $f(s_2)-f(s_1)-1$ ，最后去掉的 $1$ 表示 $s_1$ 字符串本身。

接下来我们可以设定一个函数，以得到小于某个字符串的排序个数。

我们需要考虑第一个与限制不同的位置（共 $n$ 个），以及其对应的字符（可能有 $26$ 个）。这样，我们需要考虑的情况包括 $26n$ 个。如果此时我们使用上述公式直接计算，则每次计算也是 $\mathcal{O}(26)$ 的，于是，总复杂度达到了 $\mathcal{O}(26^2n)$ ，在 $n=10^6$ 时是无法完成任务的（至少 Python 应该显然不行？），于是考虑优化。

我们发现有一个特点，我们考虑到同一个位置时，其 $c_1+c_2+\dots+c_{26}$ 是固定的，而分母也只有一个位置相较于原位置减去了 $1$ 。我们可以利用这个特点。

假设，到前一个位置，各个字符分别有 $c_1,c_2,\dots,c_{26}$ 个。则假设为了新的位置严格小于限制，新的位置可以取 $1$ 到 $k$ 中的任何一个字符，那么新需要计数的方案是：

$\sum\limits_{i=1}^k\frac{(c_1+c_2+\dots+c_{26})!}{(c_i-1)!\prod\limits_{j\not=i}c_j!}=\frac{(c_1+c_2+\dots+c_{26})!}{\prod\limits_{j=1}^k c_j!}\sum\limits_{i=1}^kc_i$

这个式子的计算就使得同一个位置是可以 $\mathcal{O}(26)$ 完成的了，于是我们便完成了这一题。

时间复杂度为 $\mathcal{O}(n|Σ|)$ ，其中 $|Σ|$ 表示字符集的大小。

同时，我们发现我们实际求的是前缀和，并且每次维护只需要把某个位置 $-1$ 即可，因此可以通过树状数组进行维护。

同时 $\frac{(c_1+c_2+\dots+c_{26})!}{\prod\limits_{j=1}^k c_j!}$ 在位置移动的过程中可以 $\mathcal{O}(1)$ 维护。

这样做，时间复杂度进一步下降为 $\mathcal{O}(n\log|Σ|)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
mod = 10 ** 9 + 7
fact = Factorial(10 ** 6, mod)
 
def main():
    s1 = [ord(c) - ord('a') for c in I()]
    s2 = [ord(c) - ord('a') for c in I()]
    n = len(s1)
    
    cnt = [0] * 26
    for c in s1:
        cnt[c] += 1
    
    def f(s):
        tmp_cnt = cnt[:]
        cur = fact.fac(n)
        for c in tmp_cnt:
            cur *= fact.fac_inv(c)
            cur %= mod
        
        ans = 0
        for i in range(n):
            cur *= fact.inv(n - i)
            cur %= mod
            
            for j in range(s[i]):
                ans += cur * tmp_cnt[j]
                ans %= mod
            
            if tmp_cnt[s[i]] == 0: break
            
            cur *= tmp_cnt[s[i]]
            cur %= mod
            tmp_cnt[s[i]] -= 1
        
        return ans
    
    print((f(s2) - f(s1) - 1) % mod)
    return
```
