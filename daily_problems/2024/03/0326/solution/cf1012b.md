**提示 1：** 手玩几组样例，你有什么发现吗？

**提示 2：** 新增一个点，可以使得原有区域发生什么变化？

在经过手动探索后，我们可以发现如下结论——

- 每一次操作后，对行 / 列进行恰当排列后，构成的图形是一些矩形。（在原图形中就是一些行 / 列的交点，说矩形只是为了方便提出下一个点）

- 对于一个矩形，新增一个节点可以扩大它当且仅当这个节点与其有公共行 / 公共列。且新增节点后会变成一个更大的 “矩形” （重排行 / 列后）。

上面的结论比较容易用题目给出的条件推出来

最后我们要让我们画的矩形是全集。

那么，我们直接的想法是，先把已有的矩形（设有 $k$ 个），经过 $k-1$ 次操作合并为一个大矩形。接下来每次新增一个点新增一行 / 一列，这样的操作次数最小。

证明最小性也很容易，因为新覆盖的行数和列数是必须操作的，同时当前的 “矩形” 需要一次操作才能合并，这两个操作不相交。

于是，我们只需计算有多少个 “矩形” 。

怎么找到这些 “矩形” 呢？

从上面的探索可以发现，“矩形” 的刻画只需要看构造其的行 / 列，于是我们只需要知道哪些行和列是相互作用的。显然，有标记的位置就是行列相互作用的位置。

**因此，我们构造图，并在对应的行 / 列之间连边，这样，一个连通块内行 / 列构成的 “矩形” 即为所求。**

于是，我们可以通过并查集进行上述连通情况的确定。

而当前 “矩形” 的个数，等于目前出现过的行 / 列的点形成的连通块的个数 $num$ ，需要 $num-1$ 次合并，假设这里出现了共计 $cnt$ 个行 / 列。

而没遍历过的行 / 列共计 $n+m-cnt$ 个，各需要一次操作。

于是总操作数量等于 $n+m-cnt+num-1=n+m-1-(cnt-num)$ ，发现 $cnt-num$ 刚好为并查集的有效合并次数，以下代码就是对应逻辑。

时间复杂度是 $q$ 次并查集的复杂度，加上开始构造并查集的 $\mathcal{O}(n+m)$ 。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, m, q = MII()
    union = UnionFind(n + m)

    ans = n + m - 1
    for _ in range(q):
        u, v = GMI()
        # 如果发生合并，答案 -1
        ans -= union.merge(u, v + n)

    print(ans)
```