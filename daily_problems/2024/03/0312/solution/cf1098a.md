**提示：** 如何贪心使得树的和尽可能小？

很简单的一个树的小问题！大家植树节快乐！

这题告诉我们这棵树中，奇数深度（认为根节点深度为 $1$ ）的节点到根节点的路径上所有数字的和，要使得树本身每个节点的数值和尽可能小。

我们暂称节点到根节点路径上所有节点的和为路径和。

我们考虑所有未知路径和的节点。

如果其没有任何子节点，其赋值为 $0$ 即可。

否则，其父节点和所有子节点都知道路径和。那么这个节点的数值应当尽可能大，因为其增大 $1$ ，其所有子节点可以减少 $1$ （为了维持子节点的路径和不变）。而其能取的最大值如何呢？需要保证其路径和不超过子节点的路径和。

注意，如果这个最大的路径和也无法比其父节点更大，那么就产生了矛盾，返回 `-1` 即可。

于是我们贪心完成这件事情即可。注意 $1\leq p_i\lt i$ ，所以逆序遍历可以保证先遍历子节点再遍历父节点，顺序遍历反之，可以利用这一点简化代码。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    parent = [-1] + LGMI()
    nums = LII()
    for i in range(1, n):
        if nums[i] >= 0 and (nums[parent[i]] == -1 or nums[parent[i]] >= nums[i]):
            nums[parent[i]] = nums[i]
    
    ans = 0
    for i in range(n - 1, 0, -1):
        if nums[i] != -1:
            if nums[parent[i]] > nums[i]:
                print(-1)
                return
            ans += nums[i] - nums[parent[i]]
    print(ans + nums[0])
    return
```