**提示 1：** 注意题目中的奇怪限制：该序列必包含字符 $1,6,8,9$ ，这也就使得我们的构造有了很高的自由度。

**提示 2：** 尝试将一定有的数码放到最后考虑。

欸，好像上面的提示差不多把做法说出来了噢！

由于原来给的数码中一定有 $1,6,8,9$ ，因此我们先将这四个数码提前拿出来。

于是我们将数码分为了两类，一类里面只有一组 $1,6,8,9$ ，另一类是其他的数码。

第二类是不好处理的，因为其中有几种数码，分别有多少个不能确定。

但第一类可以任意排列，也只包含了 $24$ 种不同情况。且通过计算，我们知道，这 $24$ 种情况遍历了 $\bmod 7$ 的所有情况。

于是我们考虑如下做法——

- 对于第二类的数码，我们任意组合其中非 $0$ 字符。

- 接下来用一组 $1,6,8,9$ 使得 $\bmod 7$ 的余数凑成 $0$ .

- 最后补齐所有的数码 $0$ .

上述过程一定可以完成，时间复杂度为 $\mathcal{O}(n)$ .

当然，这里涉及到一个大数取模的问题。这里我们假设前缀取模 $p$ 的结果为 $x$ ，而新数码为 $y$ ，则新数取模结果为 $(10x+y)\bmod p$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
saved = [''] * 7
for p in permutations('1689'):
    s_p = ''.join(p)
    saved[int(s_p) % 7] = s_p

def main():
    s = I()
    cnt = Counter(s)
    cnt['1'] -= 1
    cnt['6'] -= 1
    cnt['8'] -= 1
    cnt['9'] -= 1
    
    ans = []
    for x in cnt:
        if x != '0':
            ans.append(x * cnt[x])
    
    ans = ''.join(ans)
    mod = 0
    for x in ans:
        mod = (mod * 10 + int(x)) % 7
    
    print(ans + saved[(-mod * 10000) % 7] + '0' * cnt['0'])
```
