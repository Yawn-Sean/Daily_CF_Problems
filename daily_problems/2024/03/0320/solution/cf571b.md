**提示 1：** 所有进行作差运算的元素进行连线，你发现了什么？

**提示 2：** 同一组的数应该怎么排列？应当怎样出现在原数组？

**提示 3：** 如何使用 DP 解决上述贪心化后的最小值问题。

根据提示 1 进行连线，大家可以发现，所有数根据 $\bmod k$ 的结果分为了若干条链，每条链上的数的下标为 $i,i+k,\dots$

每两条链之间相互不影响。

同一条链上，我们求的是相邻两项的差的绝对值的和。而在选取的数不变时，我们应当使得数组升序 / 降序排列，才能使相邻两项差的绝对值的和最小。

而该最小值只受到组内最大值和最小值的影响，是两者之差。

接下来，在使得目标最小化的情况下，每一条链一定对应于原数组排序后的一段连续的区间。（很符合直觉）证明如下——

- 我们设每一组最小值、最大值在排序后的数组中分别为 $l_i, r_i$ ，则需要证明 $[l_i, r_i]$ 两两不交。

- 如果有两者相交，可以通过交换元素，使得左侧区间右端点左移，右侧区间左端点右移。这使得和变小。

于是，我们只需要从排序数组中找到 $k$ 个子数组，使得其极差的和最小即可。

注意这 $k$ 个子数组在长度上有要求。其有 $n\mod k$ 个长度为 $\lfloor\frac{n}{k}\rfloor+1$ ，其余长度为 $\lfloor\frac{n}{k}\rfloor$ 。

于是我们的问题变为，总共选取 $k$ 个子数组，其中有 $n\mod k$ 个长度为 $\lfloor\frac{n}{k}\rfloor+1$ ，其余长度为 $\lfloor\frac{n}{k}\rfloor$ ，使极差之和尽可能小。

这件事情可以通过背包实现，计算前面 $i$ 个子数组中有 $j$ 个长度为 $\lfloor\frac{n}{k}\rfloor+1$  的子数组时，结果最小值为 $dp[i][j]$ ，即可得到答案。

而注意 DP 有 $\mathcal{O}(k^2)$ 种状态，且转移是 $\mathcal{O}(1)$ 的。

故时间复杂度为 $\mathcal{O}(n\log n+k^2)$ ，算上排序和 DP 。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, k = MII()
    nums = LII()
    nums.sort()
    
    a, b = divmod(n, k)
    
    dp = [inf] * (b + 1)
    dp[0] = 0
    for i in range(k):
        for j in range(b, -1, -1):
            if j < b:
                dp[j+1] = min(dp[j+1], dp[j] + nums[(i + 1) * a + j] - nums[i * a + j])
            dp[j] += nums[(i + 1) * a + j - 1] - nums[i * a + j]
    
    print(dp[b])
```
