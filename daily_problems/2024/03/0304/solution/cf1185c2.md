**提示：** 要求前 $i-1$ 项中，如何删去最少的项，使得和足够小。怎么贪心做到这件事？如何维护这个贪心？

显然我们应当删去前缀中数值最大的若干个数，也就是要保留前缀中最小的若干个数。

接下来我们要做的是，维护序关系，同时维护好这个序关系下的前缀和。这样我们可以根据这个前缀和找到最靠前的不超过某个数的位置（即排序后数组前缀有多少个小于等于我们的目标），也就得到了结论。

接下来是两种可能的做法。

### 方法一：不认真读题版 —— 树状数组 / 线段树

我们首先预处理所有出现过的数字，则我们提前处理了所有的序关系。

接下来，我们要设计一个数据结构，使得其前缀和能够被维护。这样，但凡出现一个数，我们可以在其整体的序关系中对应的位置进行更新，就实现了最小若干个数的维护。

举个例子：假设 $a_1,a_2,\dots,a_n$ 在排序后的数组中分别位于 $p_1,p_2,\dots,p_n$ ，那么新增数字 $a_i$ 时，在 $p_i$ 位置进行加 $a_i$ 的操作，那么这个数据结构维护的前缀和就是最小的若干个数的前缀和。

很容易想到树状数组 / 线段树之类的结构。使用另一个树状数组统计在这个位置前，新增的数的个数即可（也就是比这个数更小的数）。（即在 $p_i$ 位置进行增加 $1$ 的操作）

最后，我们使用数据结构上的二分，可以快速得到最大的使得有序情况下的前缀和小于目标值的位置。注意，如果你在值域上进行了去重，需要在下一个位置贪心地取 $\lfloor\frac{M}{x}\rfloor$ 个数。

时间复杂度为 $\mathcal{O}(n\log n)$ .

### 方法二：认真读题版 —— 值域数组

注意，这题的数据范围很小： $1\leq t_i\leq 100$

这样我们可以开一个长度为 $100$ 的数组，记录每个数字出现了多少次。

这样，我们只需要倒序遍历数组，就可以实现从大到小的数字的删去。我们不断减去大数，直至当前和小于目标值。注意，需要对于同样大小的数，一次减去足够多的个数，这样每个数的处理才是 $\mathcal{O}(1)$ 的。

时间复杂度为 $\mathcal{O}(nM)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, m = MII()
    nums = LII()
    
    ans = [0] * n
    cnt = [0] * 101
    
    cur = 0
    for i in range(n):
        cur += nums[i]
        tmp = cur
        res = 0
        for j in range(100, 0, -1):
            if tmp <= m: break
            v = min(cnt[j], (tmp - m - 1) // j + 1)
            res += v
            tmp -= v * j
        cnt[nums[i]] += 1
        ans[i] = res
    
    print(' '.join(map(str, ans)))
    return 
```
