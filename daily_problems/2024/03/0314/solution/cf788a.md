**提示 1：** 给的函数中 $|a_i-a_{i+1}|$ 没有意义，去掉它看看你求的东西到底是啥。

**提示 2：** 把求和式展开。

这里，我们先设 $b_i=|a_i-a_{i+1}|$ ，那么我们所求变为 $\sum\limits_{i=l}^{r-1}(-1)^{i-l}b_i$ ，与 $a_i$ 无关，接下来我们只考虑数组 $\{b_i\}$ ，看这个变量如何求出最值。

我们将求和式展开，为了方便观察。

$\sum\limits_{i=l}^{r-1}(-1)^{i-l}b_i=b_l-b_{l+1}+b_{l+2}-\dots+(-1)^{r-1-l}b_{r-1}$

于是相当于取一个子数组，进行加一项减一项的操作，使计算结果最大。

我们使用 DP 解决对应的问题。

考虑在第 $i$ 个位置结束的长度为奇数 / 偶数的子数组，对应的最大和为 $dp_1[i], dp_2[i]$ 。

那么，我们考虑 $i+1$ 号位置，那么有如下可能：

- 数组从 $i+1$ 开始，那么 $dp_1[i+1]$ 可能直接取 $b_{i+1}$ 。

- 否则一定是之前开始的数组添加一项。

    - 如果之前的数组长度为奇数，那么加上这个元素之后长度是偶数。故 $dp_2[i+1]$ 用 $dp_1[i]-b_{i+1}$ 更新。

    - 如果之前的数组长度为偶数，那么加上这个元素之后长度是奇数。故 $dp_1[i+1]$ 用 $dp_2[i]+b_{i+1}$ 更新。

最后我们统计这里所有结果的最大值即可。又由于 $dp_2[i]$ 计算过程的最后一项一定是负数，故不可能构成答案，可以不予考虑。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()
    ans = -inf
    dp1, dp2 = -inf, -inf
    for i in range(1, n):
        dp1, dp2 = max(dp2, 0) + abs(nums[i-1] - nums[i]), dp1 - abs(nums[i-1] - nums[i])
        ans = max(ans, dp1)
    print(ans)
    return
```
