**提示 1：** 字符串重排后能形成回文串的条件是什么？

**提示 2：** 如果我知道其中一个字符串，另一个字符串应该满足什么性质？

**提示 3：** 上述信息如何快速存储和查询？

首先，对于提示 1 的问题，答案比较显然，因为回文串两边对称，出去中间元素（如有）是两两配对的，因此是如下两种情况之一——

- 所有字符出现次数均为偶数。

- 一个字符出现的次数为奇数，其余字符出现的次数为偶数。

而由此，我们如果确定了其中一个字符串中，各个字符出现频率的奇偶性，则另一个跟它配对的字符串中，**各个字符出现频率奇偶性要么与前者完全一致，要么只有一个字符不同** 。

而我们可以怎么记录这里出现的奇偶性信息呢？一种很常见的方式是使用 **数的异或** 。 

我们用一个二进制长度为 $26$ 的整数表示每个字符串各个字符出现的奇偶性，第 $i$ 位为 $1$ 当且仅当第 $i$ 个字符出现奇数次。

则上述条件变为对于每个整数，寻找与其二进制表示只有零位 / 一位不同的元素，即 **异或运算后结果为 $0$ 或 $2^i$ 的元素** 。

这件事很容易通过哈希表进行实现。我们试图把每个字符串和之前出现的字符串进行配对。设当前字符对应整数为 $msk$ ，我们可以找到所有 $27$ 中可能匹配的整数（包括本身和与 $2^i$ 的异或结果）。对结果进行加总即可。

时间复杂度为 $\mathcal{O}(n|Σ|)$ .

**Bonus：** 如果这题数对改为子数组 / 子序列，你能给出够快的做法吗？

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    cnt = Counter()
    ans = 0

    for _ in range(n):
        
        msk = 0
        s = I()
        for c in s:
            msk ^= 1 << ord(c) - ord('a')
        
        ans += cnt[msk]
        for i in range(26):
            ans += cnt[msk ^ (1 << i)]

        cnt[msk] += 1

    print(ans)
```