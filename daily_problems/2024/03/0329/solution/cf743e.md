**提示 1：** 现在我们需要找子序列之所以遇到困难，是因为我们不知道先取什么数字，又要取多少个，同时要避免重复取数字。所以，如果我们知道了取数字的顺序，也知道要取 $k$ 个，我们应该如何取？

**提示 2：** 我们接下来尝试一步步固定上述两个不确定的信息。由于出现次数最小值一旦确定，每个元素出现次数都大致确定（ $x$ 或者 $x+1$ ），所以我们通过枚举元素出现的最小次数固定其中一个变量。

**提示 3：** 在出现最小次数固定的情况下，给出一个可行的 DP 解法，找到可行的序列。注意可以有 $cnt$ 个元素出现次数为 $x+1$ 。

提示最长的一集。

建议先简单阅读上述逻辑。简要概括而言，大致如下：

- 我们如果出现次数和顺序都固定了，我们可以贪心地取从当前位置开始出现的最早的数字。

- 因此我们要尝试固定其中一个变量，我们这里选择固定最小出现次数。

- 接下来使用 DP 查看可行性。

考虑固定所有元素的最小出现次数 $x$ ，则每个元素的出现次数为 $x$ 或者 $x+1$ ，接下来我们需要检查是否可能构造对应序列，对应序列的最大长度又是多少。

对应序列的最大长度此时只和有多少元素出现了 $x+1$ 次有关，设有 $cnt$ 个这样的元素，则这个 $cnt$ 应当作为状态变量。

而为了记录出现过的数字，我们使用一个 $8$ 位整数（ $[0,255]$ ），将 $1,2,\dots,8$ 中每个元素对应于整数的某一位，称呼这个状态为 $msk$ 。

我们现在定义了状态 $(cnt, msk)$ ，而我们进行的动态规划变量应为： $msk$ 中所有元素得到使用，且其中 $cnt$ 个使用了 $x+1$ 次的情况下，使用的原序列的最小前缀长度。这个长度不超过 $n$ ，则该状态可行。

最后我们需要查看是否存在一个 $cnt$ 使得 $msk=2^8-1=255$ 时是可构造的，如果可行找到最大的 $cnt$ 即可。

那么如何进行状态转移呢？

我们找到所有不出现在 $msk$ 中的数字，其中必须有一个是下一个出现的数字。

其要么出现 $x$ 次，要么出现 $x+1$ 次，而我们应该贪心地取尽可能早出现的 $x / x+1$ 个，取完后， $cnt$ 可能维持 $cnt$ ，也可能增加为 $cnt+1$ 。

因此只要中间我们找到某位置后第 $x / x+1$ 次出现数字 $i$ 的速度尽可能快，就可以快速实现状态转移。

当然，我们可以使用二分，但我们也可以通过预处理从每个位置开始后第一次出现 $i$ 的位置，并借助这个数组预处理，即可 $\mathcal{O}(1)$ 得到对应的位置。

具体而言，假设某个位置后第 $k$ 次出现 $i$ 的位置为 $p$ ，则第 $k+1$ 次出现 $i$ 的位置等于 $p$ 后第一次出现 $i$ 的位置。

因此，我们枚举出现最小次数的过程中，不断根据上述逻辑更新第 $k$ 次出现 $i$ 的位置即可。

时间复杂度为 $\mathcal{O}(n^2|Σ|+n|Σ|^22^{|Σ|})$ ，其中 $|Σ|=8$ 。

因为预处理需要更新一个大小为 $n|Σ|$ 的数组，而需要进行 $n$ 次 DP，每次 DP 有 $|Σ|2^{|Σ|}$ 种状态，且发生 $|Σ|$ 次转移，转移复杂度为 $\mathcal{O}(1)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LGMI()

    saved = [[n] * (n + 1) for _ in range(8)]

    for i in range(n - 1, -1, -1):
        if i < n - 1:
            for j in range(8):
                saved[j][i] = saved[j][i+1]
        saved[nums[i]][i] = i

    def process():
        for i in range(8):
            for j in range(n):
                if next_pos[i][j] < n:
                    next_pos[i][j] = saved[i][next_pos[i][j] + 1]

    next_pos = [saved[i][:] for i in range(8)]

    ans = len(set(nums))

    for cnt in range(1, n + 1):
        dp = [[n] * (1 << 8) for _ in range(9)]
        dp[0][0] = -1
        
        for cur_cnt in range(9):
            for msk in range(1 << 8):
                
                if dp[cur_cnt][msk] < n:
                    for i in range(8):
                        
                        if msk >> i & 1 == 0:
                            p = next_pos[i][dp[cur_cnt][msk] + 1]
                            if p < dp[cur_cnt][msk | (1 << i)]:
                                dp[cur_cnt][msk | (1 << i)] = p
                            
                            if p < n:
                                np = saved[i][p+1]
                                if np < dp[cur_cnt + 1][msk | (1 << i)]:
                                    dp[cur_cnt + 1][msk | (1 << i)] = np
                    
                    if msk == 255:
                        ans = max(ans, cnt * 8 + cur_cnt)
        
        process()

    print(ans)
```