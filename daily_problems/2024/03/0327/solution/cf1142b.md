**提示 1：** 第一个排列意义不大，先把其中信息剥离。

**提示 2：** 如果固定了子序列的第一个位置，怎么确定子数组接下来的每一个位置？如何加速这一步？

**提示 3：** 如何处理区间查询？

首先，第一个排列本身不重要，重要的只有第二个序列中的元素在第一个序列中的位置，因此我们预处理得到第二个序列的对应结果。

接下来我们要在第二个序列中找出这种结构的子序列： $[i+1, \dots, n, 1, 2, \dots, i]$ 。

而一旦我们固定了这个子序列的第一个数值，那么接下来要寻找的每一个数值也都确定了，我们只需要 **贪心** 寻找下一个字符第一次出现的位置，直到找到对应的子序列 / 走到序列最末端，这样一定能找到最早的结束位置。

于是， **对于每一个子序列的起点 $i$ 我们可以根据上述逻辑找到对应的子序列。**

但上述过程如果直接进行模拟将会达到平方复杂度，我们接下来考虑如何简化上述过程。

由于对于每个位置，后一项数值完全确定，只需找到该数值的最早出现位置（在该位置后）。

因此，我们倒序遍历数组，记录每个元素最近一次出现的位置，就可以直接预处理 “后一项数组” 。

接下来我们相当于 **要找到 “后 $n-1$ 项数组”，就能找到每个位置开始的子序列的最早结束位置** 。相当于一个点走 $n-1$ 步的位置。

而这件事可以通过倍增 $\mathcal{O}(m\log n)$ 实现。倍增算法具体可见 [倍增算法的 OI-wiki 说明](https://oi-wiki.org/basic/binary-lifting/) .

后面的解答代码给出的实现如下——

- 利用一个协助数组，计算走 $2^i$ 步到达的位置。走 $2^i$ 等于先走 $2^{i-1}$ 步再走 $2^{i-1}$ 步，因此相当于 $target[2^i][u]=target[2^{i-1}][target[2^{i-1}][u]]$ ，等于一个复合函数。

- 而总共走 $n-1$ 步，可以把 $n-1$ 进行二进制分解，得到其可以用 $2^{i_1}+2^{i_2}+\dots+2^{i_a}$ 步表示。而我们先走 $2^{i_1}$ 步，再走 $2^{i_2}$ 步，……，最后走完 $2^{i_a}$ 步，而这些结果都可以利用前面的预处理结果。

最后，为了查询区间 $[l,r]$ 内是否存在对应的子序列，我们只需查看这个范围内 “子序列的最早结束位置” 是否不超过 $r$ .

这件事可以通过线段树实现，也可以通过预处理使用后缀最小值达到线性复杂度。

这是因为 $[r+1,n]$ 中的计算结果一定大于 $r$ 不满足要求，所以 $[l,r]$ 的查询结果和 $r$ 的大小关系与 $[l,n]$ 的查询结果一致。

最后的时间复杂度为 $\mathcal{O}(n+m\log n+q)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():

    n, m, q = MII()

    perm = LGMI()
    pos = [-1] * n
    for i in range(n):
        pos[perm[i]] = i

    to_check = [pos[i] for i in GMI()]

    pos = [m] * n
    next_pos = [m] * m
    for i in range(m - 1, -1, -1):
        next_pos[i] = pos[(to_check[i] + 1) % n]
        pos[to_check[i]] = i

    to_search = list(range(m))
    n -= 1
    for i in range(n.bit_length()):
        if n >> i & 1:
            # 用 2^i 的步长走 n-1 步
            to_search = [next_pos[x] if x < m else m for x in to_search]
        # 维护走 2^(i+1) 步时的位置
        next_pos = [next_pos[x] if x < m else m for x in next_pos]

    for i in range(m - 1, 0, -1):
        if to_search[i-1] > to_search[i]:
            to_search[i-1] = to_search[i]

    ans = []
    for _ in range(q):
        l, r = GMI()
        ans.append(1 if to_search[l] <= r else 0)

    print(''.join(map(str, ans)))
```
