**提示 1：** 当你完全意识到这个题的成本如何计算时，构造就变得很容易了。

**提示 2：** 考虑每对相同字符的贡献。

**提示 3：** 注意细节。

这题的成本计算方式很怪异，相当于要我们不断拼接字符串，但真的需要吗？

我们直接考虑成本计算并不容易，尤其还说是最小成本。那么我们考虑每一对相同的字符对结果的贡献。

我们发现，对于每一对相同的字符，只有在拼接的时刻才会新增成本，且成本为 $1$ 。而最后总是拼成一个大字符串，因此最终每一对相同字符也都会被拼接上。

于是本题的成本计算方法呼之欲出了：就是算字符串中相同字符对的数量。

接下来构造就很容易了。如果一个字符出现了 $k$ 次，其对结果的贡献就是 $\frac{k(k-1)}{2}$ ，因为产生了这么多对相同字符。

因此可能的贡献为 $0,1,1,3,6,\dots$ ，我们只需将这个序列从后往前，贪心地找小于当前 $k$ 的最大数即可。最后因为有 $1$ 总能填满。

为什么用的字符类别不会超过字符集呢？因为假设 $a$ 是最大的满足 $\frac{a(a-1)}{2}\leq k$ 的元素，则 $\frac{a(a+1)}{2}\gt k$ ，于是 $k-\frac{a(a-1)}{2}\lt a$ ，于是每选一个字符， $k$ 大致开了个根号，会很快收敛到 $0$ 。

需要注意 $k=0$ 时不允许输出空字符串。

时间复杂度为 $\mathcal{O}(\sqrt{k})$ ，因为你输出的字符串也一定至少这么长。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    k = II()
    ans = []

    for i in range(1000, 1, -1):
        while i * (i - 1) // 2 <= k:
            k -= i * (i - 1) // 2
            ans.append(i)

    print(''.join(chr(ord('a') + i) * ans[i] for i in range(len(ans))) if ans else 'a')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> ans;
    for (int i = 1000; i > 1; i --) {
        while (n >= i * (i - 1) / 2) {
            n -= i * (i - 1) / 2;
            ans.emplace_back(i);
        }
    }

    if (ans.size()) {
        for (int i = 0; i < ans.size(); i ++) {
            while (ans[i] --) {
                cout << (char)('a' + i);
            }
        }
    }
    else cout << 'a';

    return 0;
}
```
