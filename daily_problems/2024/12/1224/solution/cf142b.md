**提示 1：** 我们可以尝试将矩形中的格子尽可能两两配对，最后每一对都只能剩下一个元素。在这个基础上计算 / 证明答案。

**提示 2：** 从上面的角度来看，在矩阵变大时候，由于配对的自由度很高，所以很可能可以组成最多的不交的对，此时答案接近整体面积的 $\frac{1}{2}$ 。

首先，判断 $\min(n,m)$ 较小的情况。为啥想到这个需要判断呢？实际上也是因为一条边较窄时，一个点能走到的位置限制很大，此时容易出现不同于一般情况的结果。

$\min(n,m)=1$ 时，显然怎么走都行。

$\min(n,m)=2$ 时，我们考虑一个 $2\times 4$ 的矩形，我们可以将互相可达的位置两两配对，因此总共形成了 $4$ 对，至多可以有 $4$ 个点被取。同时直接选取最左侧的 $4$ 个点符合要求。

于是，此时我们将矩形切割为尽可能多的 $2\times 4$ 的矩形，最后剩下一个 $2\times i$ （其中 $0\leq i\lt 4$） 的矩形。这个矩形取的个数显然不超过 $4$ （因为即使 $2\times 4$ 的矩形也只能取 $4$ 个），将其面积与 $4$ 取最小值即可。

那么，能构造出对应的结果吗？答案是肯定的，因为我们还是可以挑选每一组中最左边的两列放入棋子。

更大的情况下，棋子有更多的自由度，事实上，此时答案就是 $\left\lceil\frac{nm}{2}\right\rceil$ 。

从构造上来看，我们将棋盘进行黑白间隔染色，则黑色位置走一步到达白色位置，白色位置走一步到达黑色位置，因此如果所有棋子都放在黑色 / 白色的位置，则两两不可攻击，满足要求。因此只需要挑选黑白两种颜色中更多的即可。

怎么证明呢？大家如果有啥好一点的想法也可以提一下。

事实上，可以用到一个结论：除了 $3\times 3,3\times 5,3\times 6,4\times 4$ 外，其他的任意棋盘都可以找到哈密顿路径，即遍历每个点恰好一次的路径。

这件事可以自行尝试构造进行解决，而此时，由于路径上的相邻两点至多只取一个，因此，答案不超过 $\left\lceil\frac{nm}{2}\right\rceil$ 。而对于上述特殊情况，可以手动暴力解决，发现仍满足对应规律。

其他可能的证明方法：尝试对于某个小矩形，找到一种将格子两两配对的方法，就证明了小矩形。最后说明每个大矩形都可以由我们基础的小矩形拼出来。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    if min(n, m) == 1: print(n * m)
    elif min(n, m) == 2:
        v = max(n, m)
        print(v // 4 * 4 + min(v % 4, 2) * 2)
    else:
        print((n * m + 1) // 2)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    if (min(n, m) == 1) cout << n * m;
    else if (min(n, m) == 2) {
        int v = max(n, m);
        cout << v / 4 * 4 + min(v % 4, 2) * 2;
    }
    else cout << (n * m + 1) / 2;

    return 0;
}
```
