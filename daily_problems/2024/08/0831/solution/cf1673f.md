**提示 1：** 考虑这个网格图中的一个环，环上异或和可以非 $0$ 吗？

**提示 2：** 于是，要求两点之间路径异或和只跟起点终点有关。

**提示 3：** 尝试构造 $1\times n$ 的情况，尽可能减小你给出的路径权值之和。

**提示 4：** 尝试用 $1\times n$ 的构造拼凑 $n\times n$ 的构造。

首先，如果图中存在异或和非 $0$ 的环，那么总可以 “多绕这个环走一圈” ，使得两点间路径的异或和发生改变，这就导致从一点 $u$ 到另一个点 $v$ 可能的异或和情况增加。

而我们为了区分 $u$ 到达的是哪一个 $v$ ，需要每一个 $v$ 对应的异或和情况都不相同。因此总的异或和情况会因此过多增加，不利于判断，构造时容易重复。因此我们应当尽可能使得环上异或和为 $0$ 。

而如果任意一个环的异或和都为 $0$ ，就意味着 $u$ 按照任意一条路径走到 $v$ 再按任意路径走回来的异或和都是 $0$ ，因此 $u$ 无论按照什么路径走到 $v$ ，异或和都是一致的。

考虑从 $0$ 开始，走到 $u$ 的异或和为 $f(u)$ ，则任意两点 $u,v$ 之间的路径异或和等于 $u$ 走到 $0$ 再走到 $v$ 的异或和，是 $f(u)\mathrm{xor}f(v)$ 。于是，只要我们构造出 $f(u)$ ，接下来每条边的权重用边两端的点的函数数值进行异或即可。

同时，只要我们构造的 $f(x)$ 两两不同，我们从 $u$ 出发，走了权值为 $x$ 的路径，到达的点的 $f$ 函数数值等于 $f(u)\mathrm{xor}x$ ，一定能找到唯一解。

接下来，我们的目标就是找到合适的 $f(x)$ ，使得我们的边权和足够小，后续的查询上面已经给出了方法。（有点像一个势函数）

二维情况不太容易考虑，考虑一维的 $1\times n$ ，相当于要相邻两项的异或和之和足够小。

而 $n$ 刚好是 $32$ ，因此考虑一维的 $1\times 2^k$ 。

假设 $2^{k-1}$ 的情况已经完成了一个较优的构造，那么 $2^k$ 呢？

我们为了充分利用 $2^{k-1}$ 的结果，我们可以将其反转设为新数组 $ar'$ ，对 $ar'$ 的所有元素异或一个 $2^{k-1}$ ，再拼到原数组后面。

这样做可以充分利用 $2^{k-1}$ 情况，两侧的数组的权值都已经最小化，而中间只是增加了不得不出现的不小于 $2^{k-1}$ 的异或值。边权变成原来的两倍加上 $2^{k-1}$ ，是一个比较优的构造。

也相信有朋友已经发现了，这里给出的构造就是格雷编码。

接下来考虑 $n\times n$ 的情况。

一种非常直接的想法是，我们把每个位置的权重分为行权和列权，两者分别用前面的构造得到 $r_i,c_i$ ，我们令 $f(i)=r_i\times 32+c_i$ ，这样显然两两不重复，且保持了在行 / 列选择的数字集不变的情况下相对的较优结果。

但是计算后发现，这种方式的边权和超出了限制，我们如何减小之呢？

可以发现，上述构造的问题是，在跨行时，总是会遇到很大的异或结果。我们应该让行和列 “更均衡一些” 。

于是，由于构造的数字范围是小于 $2^n\times 2^n=2^{2n}$ ，是一个 $2n$ 位的二进制的数，因此，我们可以将其奇数位分给行，偶数位分给列，这样两者交错就避免了不均衡情况的发生。计算后发现，这样构造的权值和为 $47616$ ，卡进了构造限制。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    def find_array(k):
        if k == -1: return [0]
        v = find_array(k-1)
        return v + [x ^ (1 << 2 * k) for x in reversed(v)]

    ar = find_array(4)

    n, k = MII()
    pos = [None] * 1024

    for i in range(n):
        for j in range(n):
            pos[ar[i] ^ (ar[j] * 2)] = (i + 1, j + 1)

    for _ in range(n):
        print(*((ar[i] ^ ar[i+1]) * 2 for i in range(n - 1)))

    for i in range(n - 1):
        print(*(ar[i] ^ ar[i+1] for _ in range(n)))

    sys.stdout.flush()

    msk = 0
    for _ in range(k):
        msk ^= II()
        print(*pos[msk], flush=True)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    vector<int> ar = {0};
    for (int i = 0; i < 5; i ++)
        for (int j = (1 << i) - 1; j >= 0; j --)
            ar.emplace_back(ar[j] | (1 << 2 * i));
    
    vector<pair<int, int>> pos(1024);
    for (int i = 0; i < 32; i ++)
        for (int j = 0; j < 32; j ++)
            pos[ar[i] ^ (ar[j] * 2)] = {i + 1, j + 1};
    
    int n, q;
    cin >> n >> q;

    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n - 1; j ++)
            cout << (ar[j] ^ ar[j+1]) * 2 << ' ';
        cout << '\n';
        }
    
    for (int i = 0; i < n - 1; i ++) {
        for (int j = 0; j < n; j ++)
            cout << (ar[i] ^ ar[i+1]) << ' ';
        cout << '\n';
        }
    
    cout.flush();

    int msk = 0;
    while (q --) {
        int v;
        cin >> v;
        msk ^= v;
        cout << pos[msk].first << ' ' << pos[msk].second << '\n';
        cout.flush();
    }

    return 0;
}
```
