**提示 1：** 先确认你理解了题目——我们在叶子数量固定的情况下，要让构造的树的直径尽可能小。

**提示 2：** 考虑反向问题。树共有 $k$ 个叶子时， $n$ 个节点的树直径最长，对偶问题是，直径为 $d$ 的树节点个数最多。

**提示 3：** 对于后面一个问题，先构造一根直径，剩下的叶子节点怎么加？

我们考虑通过反向问题进行探索，因为直径长度一旦确定，我们是更容易有一个构造的基准的，而不容易从节点个数出发。

我们要最小化总结点个数为 $n$ 时树的直径，也就等价于最大化直径长度为 $d$ 时树的节点个数。

因此我们先构造一条长度为 $d$ 的直径（也就是刚刚提到的构造的基准）。
接下来我们能继续挂上 $k-2$ 个叶子节点。怎么挂可以使得节点个数最多呢？

显然，假设这个节点挂在了距离直径端点为 $i$ 的位置上，则挂上的链的长度不能超过 $i$ ，因此最优位置是选择在直径的中点上，挂上 $\lfloor\frac{d}{2}\rfloor$ 长度的链。

而重新考虑这棵树的结构，相当于从直径中点出发，挂了几条长度接近的链。因此，实际构造时，也只需要设定一个根节点，再往外延伸出 $k$ 条长度接近的链即可，而直径等于其中最长的两条链的长度和。

时间复杂度为 $\mathcal{O}(n)$ .

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()

    x, y = divmod(n - 1, k)
    print(2 * x + min(y, 2))

    outs = []
    for i in range(1, k + 1):
        outs.append(f'{n} {i}')
    for i in range(k + 1, n):
        outs.append(f'{i - k} {i}')

    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;
    cout << (n - 1) / k * 2 + min((n - 1) % k, 2) << '\n';
    for (int i = 1; i <= k; i ++)
        cout << n << ' ' << i << '\n';
    for (int i = k + 1; i < n; i ++)
        cout << i - k << ' ' << i << '\n';

    return 0;
}
```
