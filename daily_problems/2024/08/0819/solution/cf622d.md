**提示 1：** 首先，尝试找到最小值。注意 $d_n$ 项前的系数为 $0$ ，不影响答案。

**提示 2：** 假设两个元素距离为 $i$ ，构造另两个元素距离为 $i+2$ .

脑筋急转弯的构造题。

本题要最小化一个求和式，但注意， $i\eq n$ 的一项总是 $0$ ，因此只需要考虑剩余 $n-1$ 个式子。

而剩余 $n-1$ 个式子均非负，因此总是不小于 $0$ 。如果都取到 $0$ ，则一定是最小值。而就算它们都取到 $0$ ，实际上也只对构造的序列增加了 $n-1$ 个限制，因此直觉上来看还有较大的灵活度。

于是，我们要求 $1$ 的距离为 $n-1$ ， $2$ 的距离为 $n-2$ ，……， $n-1$ 的距离为 $1$ 。

乍一看构造思路并不明确，但我们可以尝试找到 “小组件” （一些构造题的探索方法）。

比方说 $yx\dots xy$ ，这里， $x$ 之间的距离加 $2$ 等于 $y$ 之间的距离。利用这件事情，我们可以把距离相差 $2$ 的数对放在一起构造，这样也就相当于奇偶分类了。

因此，我们可以把距离为奇数的和距离为偶数的分开构造。

距离为奇数的形成 $a_0,a_1,\dots,a_k,a_k,\dots,a_1,a_0$ ，距离为偶数的形成 $b_0,b_1,\dots,b_m,x,b_m,\dots,b_1,b_0$ ，其中 $x$ 为任意数字。

而这样中间最多只有一个空格（ $x$ ），而我们放置了 $1\dots n-1$ 中所有的数，因此最多占据了 $2(n-1)+1$ 的长度，剩余两个位置填入 $n$ 即可完成构造。

时间复杂度为 $\mathcal{O}(n)$.

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    ans = [0] * (n * 2)

    for i in range(n // 2):
        ans[i] = i * 2 + 1
        ans[n-i-1] = i * 2 + 1
        ans[n+i] = (i + 1) * 2
        ans[2*n-2-i] = (i + 1) * 2

    for i in range(n * 2):
        if ans[i] == 0:
            ans[i] = n

    print(' ' .join(map(str, ans)))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;
    vector<int> ans(n * 2);
    for (int i = 0; i < n / 2; i ++) {
        ans[i] = i * 2 + 1;
        ans[n-1-i] = i * 2 + 1;
        ans[n+i] = (i + 1) * 2;
        ans[2*n-2-i] = (i + 1) * 2;
    }
    for (auto &x: ans) cout << (x ? x : n) << ' ';

    return 0;
}
```
