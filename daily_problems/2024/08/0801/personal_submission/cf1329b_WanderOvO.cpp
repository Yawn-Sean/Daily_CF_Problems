/*
先随便设置一个 a[1] 和 b[1]，然后考虑 a[2] 和 b[2]
b[2] = b[1] ^ a[2] = a[1] ^ a[2] > b[1] = a[1]
b[3] = b[2] ^ a[3] = a[1] ^ a[2] ^ a[3] > b[2] = a[1] ^ a[2]
本质上是需要 a 单调递增，且 a 的前缀异或和单调递增，这个限制下 n 的量级感觉不会很大
a[2] 的最高位和 a[1] 的最高位不能是同一个二进制位，不然就异或没了，且 a[2] > a[1]
所以 a[2] 的最高 1 一定比 a[1] 的最高 1 高，所以感觉上 n 至多是 log(d) 级别的
怎么计数？
羊神提示：根据上述分析，a[i] 一定比 a[i - 1] 的二进制表示下的位数多
我们看 [1, d] 范围内，不同二进制长度下的数有多少个
每个长度的数选至多一个，得到的就是一个合法的 a，记得去掉全不选的情况
*/

int T;

void solve1() {
    LL d, m;
    cin >> d >> m;
    vector<LL> cnt(64, 0);
    for (int i = 0; i < 32; i++) {
        if ((1LL << i) <= d) {
            if ((1LL << (i + 1)) <= d) {
                cnt[i + 1] = (1LL << i);
            } else {
                // 最高位了
                cnt[i + 1] = d - (1LL << i) + 1;
            }
        } 
    }
    LL res = 1;
    for (int i = 1; i <= 32; i++) {
        res *= (cnt[i] + 1);
        res %= m;
    }
    cout << ((res - 1 + m) % m) << "\n";
}       
