**提示 1：** 首先，假设我们目前选出了 $a_1$ ，那么 $a_2$ 应该满足什么条件？

**提示 2：** 类似提示 1 的逻辑往后推，你发现了什么？

**提示 3：** 如何对上述条件进行计数？

首先，我们假设已经知道了 $a_1$ 和 $b_1$ 的数值。

那么，首先 $b_2$ 不能小于 $b_1$ 。同时，为了使得其与 $a_1$ 的异或和结果不小于 $a_1$ ，**其不能跟 $a_1$ 二进制表示位数相同** ，而 $a_1$ 和 $b_1$ 的二进制表示位数相同。因此，我们发现，**$b_2$ 的二进制表示位数大于 $b_1$，同时 $b_2$ 的二进制表示位数等于 $a_2$ 的二进制表示位数** 。

类似的逻辑，我们可以推出， $a, b$ 两个数组的第 $k$ 项二进制表示位数相同，且两个数组的二进制表示位数都是严格递增的，推导逻辑与上一段一致，可以使用数学归纳法严格说明。

接下来的问题就是计数。

在 $1\sim d$ 的范围内，假设分别由二进制表示位数为 $1,2,\dots, k$ 的数字 $x_1, x_2, \dots, x_k$ 个，则每一个二进制表示的位数只能至多选择一次，因此有 $x_i+1$ 种选数的方法（选一个或者不选），最后将选择出的数按大小排列即可。

因此数列方案数量为 $(x_1+1)(x_2+1)\dots(x_k+1)-1$ （最后去掉空序列即可）。

时间复杂度为 $\mathcal{\log d}$ .

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    d, mod = MII()
    ans = 1
    tmp = 1
    while tmp <= d:
        ans *= fmin(tmp, d - tmp + 1) + 1
        ans %= mod
        tmp *= 2
    return (ans - 1) % mod
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int d, mod, tmp = 1;
        cin >> d >> mod;
        long long ans = 1;
        while (tmp <= d) {
            ans = ans * (min(tmp, d - tmp + 1) + 1) % mod;
            tmp <<= 1;
        }
        cout << (ans - 1 + mod) % mod << '\n';
    }

    return 0;
}
```
