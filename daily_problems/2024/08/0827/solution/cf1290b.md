**提示 1：** 想想怎么样的字符串比较容易构造出对应的答案？什么情况又是显然不行的？

**提示 2：** 对于剩下的情况，尝试用已知的部分推测条件。

我们称一个字符串的所有字符构成的可重集合为 “字符构成” 。

首先，如果字符串中字符种类很多，从直觉上来看，打乱字符串后，前缀的字符构成很可能改变。

接下来先探索几种比较容易的情况：

- 如果字符串全部由一个字符构成：除非字符串长度为 $1$ ，否则总能进行拆分。

- 如果字符串首尾不同：设 $s[l]=x,s[r]=y$ ，则把所有 $y$ 字符移动到开头， $x$ 字符移动到结尾就行。

- 接下来剩下的情况是首尾相同。这种情况直觉上来看难以阻挡。可以如此构造：

    - 考虑每个字符第一次出现的位置，取最后一个，记作 $c$ ，将所有 $c$ 都放在开头。
    
    - 在拼接所有的与 $s[l]$ 相同的字符。

    - 剩余字符任意排列在后面。

    - 可以思考下这种情况下为何无法实现拆分。只需讨论前缀是否是重排与后缀是否是重排。

    - 实际上，此时前缀如果包含了所有的 $s[l]$ ，则只能取全字符串（因为 $s[r]=s[l]$ ，要取完所有的 $s[l]$ 只能把最后一位也算上）；如果不包含所有的 $s[l]$ ，那么此时原字符串中既取了 $s[l]$ 又取了 $c$ ，因此该子字符串包含了原字符串中所有不同的字符，因此不可能与新的只包含两种字符的字符串是重排关系。

    - 考虑后缀。此时，为了取到一个 $s[r]$ 字符，需要把所有除 $c$ 的字符都取一遍，因此也一定把所有的 $c$ 都取完（因为 $c$ 是最晚出现的字符），因此满足重排的后缀也只有全字符串。

接下来剩下的唯一情况是：两个字符且首尾相同。我们接下来证明这种情况下一定能进行拆分。

我们不妨设两种字符是 $x,y$ 。

根据长度为 $k$ 的字符串 $s$ 构造函数 $f$ 。 $f(0)=0$ ，且 $f(i+1)=f(i)+[s[i]=x]$ 。

则排列后的字符串 $f(k)$ 数值仍然不变。

设排列前后的函数分别为 $f_1,f_2$ ，考虑新函数 $g=f_1-f_2$ ，那么这两个函数开头和结尾都是一样的，即 $g(0)=g(k)=0$ 。

而由于原字符串 $s$ 的开头和结尾相同，不妨设都为 $x$ ，则新字符串开头和结尾只能选择 $y$ （否则已经可以找到拆分）。因此 $g(1)=1,g(k-1)=-1$ 。因此中间一定存在一点 $j$ 使得 $g(j)=0$ ，那一点可以实现拆分。

于是，我们只需判断子字符串中出现的不同字符个数及字符串首尾是否相同即可。可以对每个字符使用前缀和。时间复杂度为 $\mathcal{O}((n+q)|\Sigma|)$ ，其中 $|\Sigma|$ 为字符集大小。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    s = I()
    n = len(s)

    pref = [[0] * (n + 1) for _ in range(26)]

    for i in range(n):
        for j in range(26):
            pref[j][i+1] = pref[j][i]
        pref[ord(s[i]) - ord('a')][i+1] += 1

    q = II()
    outs = []

    for _ in range(q):
        l, r = GMI()
        c = 0
        for i in range(26):
            if pref[i][r+1] - pref[i][l]:
                c += 1
        outs.append('No' if l != r and c <= 2 and s[l] == s[r] else 'Yes')

    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    string s;
    cin >> s;

    int n = s.size();
    vector<vector<int>> pref(26, vector<int>(n + 1, 0));

    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < 26; j ++)
            pref[j][i+1] = pref[j][i];
        pref[s[i] - 'a'][i+1] ++;
    }

    int q;
    cin >> q;

    while (q --) {
        int l, r;
        cin >> l >> r;
        l --, r --;
        int c = 0;
        for (int i = 0; i < 26; i ++)
            c += (pref[i][r+1] - pref[i][l] > 0);
        cout << (l != r && c <= 2 && s[l] == s[r] ? "No\n" : "Yes\n");
    }

    return 0;
}
```
