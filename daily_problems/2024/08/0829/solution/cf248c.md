**提示 1：** 反射不是很好处理，怎么办？想想初中学的平面镜成像，怎么通过镜子照到另一个地方。

**提示 2：** 经过提示 1 的转换，我们只需考虑一个无需反射的问题。此时，我们该往哪里踢？怎样确认我们这样踢是合法的？

**提示 3：** 在上述极限情况下计算要求的下标。

首先，我们解决反射的问题。

这里球的反射方法和我们初中学的平面镜很类似，因此考虑通过平面镜照另一个物体的类似做法，即可以找到物体成的像，再往对应方向突破。

这里，我们也只需要找到球门关于墙壁所成的 “像”。需要注意的是，我们这里球是有半径的，实际在 $y_w-r$ 的位置就已经发生了反射，因此，我们应当把 $y_w-r$ 作为镜面，找到 $y_1,y_2$ 所成的像。

接下来就是无需考虑反射的踢球了。我们应该瞄准哪边才能使得球尽可能地不被阻挡呢？

设我们此时踢球的目标区间是 $[y_l,y_r]$ ，则我们应该尽可能让球的中心踢向 $y_r-r$ ，因为这样我们的线路跟 $y_l$ 最远，不容易被 $y_l$ 阻挡。

因此我们可以找到过 $(0,y_r-r)$ 和 $(x_b,y_b)$ 的直线，这条线就是我们想要的球的路线。

我们要求 $(0,y_l)$ 到这条直线的距离至少为 $r$ ，这样我们的球才不会被阻挡，只需判断这件事即可。而如果不被阻挡，要求的便是直线和 $y=y_w-r$ 的交点的横坐标。

设该直线为 $y=kx+y_r-r$ ，则距离为 $d=\frac{y_r-y_l-r}{\sqrt{k^2+1}}$ ，而 $k=\frac{y_b-(y_r-r)}{x_b}$ ，因此距离为：

$d=\frac{(y_r-y_l-r)x_b}{\sqrt{(y_b-(y_r-r))^2+x_b^2}}$

要判断其和 $r$ 的大小关系，只需平方后，就可以无精度误差解决问题。注意将达到四次方，数字可达 $10^24$ ，需要用合适的数据类型。

时间复杂度显然是 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    y1, y2, yw, xb, yb, r = MII()
    y1, y2 = 2 * yw - y2 - 2 * r, 2 * yw - y1 - 2 * r

    if r * r * ((yb - y2 + r) ** 2 + xb ** 2) > (y2 - y1 - r) ** 2 * xb ** 2:
        print(-1)
    else:
        print((y2 - yw) * xb / (y2 - r - yb))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    long long y1, y2, yw, xb, yb, r;
    cin >> y1 >> y2 >> yw >> xb >> yb >> r;

    y1 = 2 * yw - 2 * r - y1;
    y2 = 2 * yw - 2 * r - y2;
    swap(y1, y2);

    __int128_t left = r * r, right = (y2 - y1 - r) * (y2 - y1 - r);
    left *= (yb - y2 + r) * (yb - y2 + r) + xb * xb;
    right *= xb * xb;

    if (left > right)
        cout << -1;
    else
        cout << setprecision(15) << 1.0 * (y2 - yw) * xb / (y2 - r - yb);

    return 0;
}
```
