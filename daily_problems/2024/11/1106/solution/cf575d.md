**提示 1：** 主要的方式是将小偷逼到一个角落再一网打尽。先设计一个能有驱赶效果的简单策略。是否有情况会被遗漏？

**提示 2：** 填补你设计的策略的空缺。

这题要抓到小偷，我们就应该直接把小偷逼到角落里再抓，不然的话小偷的行动自由度就太大了（毕竟可以向左也可以向右）。

那么很自然的想法就是，选取 $(x,1),(x,2)$ ，从左往右扫一遍。

此时，小偷唯一的逃脱方法就是，在某两轮我们选择 $(x,1),(x,2)$ 和 $(x+1,1),(x+1,2)$ 时，他选择从第 $x+1$ 列转移到第 $x$ 列。

怎么抓住这种小偷呢？我们先考虑他们此时的位置满足什么性质。

我们发现这种小偷所在的列数的奇偶性，总是和我们选取的列的奇偶性不同。首先，在小偷 “穿过” 我们的封锁的时刻，两者奇偶性不同。而此前和之后，小偷和我们选取的列也每次都改变奇偶性，因此也总是不同。

而上面那件事换句话说，就是只有奇偶性不同的没被抓到，也就是，所有所在列和我们选取列奇偶性相同的小偷都已经被抓到了。

于是总结上面的结论：我们可以通过 $n$ 次操作，抓到所有初始列数是奇数的小偷。（也就是跟我们选取的列奇偶性相同的）

此时，我们只需用一次操作转变一下此时小偷所在位置的奇偶性，小偷所在的列数又变成奇数了，此时再进行一遍上述操作就行了。

（也有另一种观点，从前往后是奇数等价于从后往前是偶数，所以直接从最后一列往前再来一遍就行，后面代码写的是这个逻辑）

时间复杂度就不用说了，就是输出的长度 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    print(2000)

    for i in range(1, 1001):
        print(i, 1, i, 2)

    for i in range(1000, 0, -1):
        print(i, 1, i, 2)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cout << "2000\n";

    for (int i = 1; i <= 1000; i ++)
        cout << i << ' ' << 1 << ' ' << i << ' ' << 2 << '\n';
    
    for (int i = 1000; i >= 1; i --)
        cout << i << ' ' << 1 << ' ' << i << ' ' << 2 << '\n';

    return 0;
}
```