**提示 1：** 比较纯粹的构造题。可以先尝试较小的 $k$ 。

**提示 2：** 从 $k$ 到 $k+1$ ，整体相当于是四个 $2^k\times 2^k$ 的正方形，有没有办法利用前一次的构造结果构造下一个？

本题的一种发现答案的方法是直接手动构造 $k=1,2,3,\dots$ 的情况，找规律以生成最终矩阵，但这个有时候得看做题的状态和灵性。

我们考虑用递推构造的方法。

我们发现从 $k$ 到 $k+1$ 时，相当于从 $2^k\times 2^k$ 的矩阵变成了 $2^{k+1}\times 2^{k+1}$ 的矩阵，我们把后者上下左右拆开，可以拆成 $2\times 2$ 个 $2^k\times 2^k$ 的矩阵。

假设我们已经完成了 $2^k\times 2^k$ 的矩阵 $A$ ，怎么进一步构造新的大矩阵呢？

首先四个小块我们先都安排成 $A$ ，即写成分块矩阵的形式：

$A_{k+1}=\begin{pmatrix}
  A_k & A_k \\
  A_k & A_k
\end{pmatrix}$

发现前 $2^k$ 行内和后 $2^k$ 行内任选两行都满足要求，但各自选一行不满足要求，其中前 $2^k$ 个元素和后 $2^k$ 个元素的内积是相等的，都为 $x$ 。

此时为了使得和为 $2^k$ ，应当让一个 $x$ 变成 $2^k-x$ ，发现只需将其中一个向量的后半部分反转即可。

我们把后 $2^k$ 行的向量都设置为被反转的向量，这样前 $2^k$ 行和后 $2^k$ 行的组合都恰有一个向量发生反转，即可使得这些组合内积为 $0$ ，且组内内积保持不变，于是完成构造，即：

$A_{k+1}=\begin{pmatrix}
  A_k & A_k \\
  A_k & -A_k
\end{pmatrix}$

可以使用递归实现。

时间复杂度为 $\mathcal{O}(2^{2k})$ 。

事实上这个矩阵跟 Hadamard 矩阵保持一致，感兴趣的朋友可以看一看。

下面给出的实现比较奇妙，但确实是 Hadamard 矩阵的构造方法之一，大家可以尝试理解下面代码的正确性（这里不作过多说明，因为不是很符合分析这题的逻辑），也可以自己根据上面的逻辑写一个自己的答案。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    print('\n'.join(''.join('+' if (i | j).bit_count() % 2 else '*' for j in range(1 << n)) for i in range(1 << n)))
```

C++ 做法如下——

```cpp []
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    for (int i = 0; i < 1 << n; i ++) {
        for (int j = 0; j < 1 << n; j ++) {
            cout << (__popcount(i | j) & 1 ? '+' : '*');
        }
        cout << '\n';
    }

    return 0;
}
```