**提示 1：** 贪心。这题直接的得分数量一样，因此我们要最小化翻倍的影响。

**提示 2：** 如何最小化翻倍次数？翻倍越靠前越好还是越靠后越好？

做对一题得一分是无法改变的，因此只能尽可能减小翻倍的影响。

而翻倍次数和翻倍的位置是我们可以控制的。我们尝试使得这两件事最优即可。

关于翻倍次数，我们可以尽可能构造一个不翻倍的情况。

我们先做对 $k-1$ 题，再做错一题，按照这个模式直到结尾，这样可以使得我们的分数从不翻倍。此时，多做一题一定新增一次翻倍次数。于是总翻倍次数等于 $\max(0, m-(n-\left\lfloor\frac{n}{k}\right\rfloor))$ 。

上述说明实质上不够严谨，因为前面的步骤最优不等价于后几次不得不翻倍时结果也最优，也可以换个方法考虑。如果做 $n$ 次操作，要翻倍的次数是 $\left\lfloor\frac{n}{k}\right\rfloor$ ，而每少一个操作，翻倍次数最多减少 $1$ 次，于是也可以得到类似的结论。

而翻倍越靠前越好，因为后面再翻倍数值更大，于是我们把翻倍全部放在最靠前的位置。假设不得不翻倍 $x$ 次，则前 $xk$ 道题全部得分，而后面部分每题都只拿一分。

对于这前面的 $xk$ 道题，假设第 $i$ 组 $k$ 道题结束后，得分为 $a_i$ ，则：

$a_{i+1}=2\times(a_i+k)$

于是： $a_{i+1}+2k=2\times(a_i+2k)$

而 $a_0=0$ ，于是 $a_n+2k=2^n\times(a_0+2k)=2^{n+1}k$ ，即 $a_n=(2^{n+1}-2)k$ 。

后续再加上后面只得一分的题的得分即可。

需要注意的是，上面两步贪心之所以能够得到满足，是因为两次贪心的结果是不冲突的，都对应于前面 $xk$ 道题都做对，而后面按照 $k-1$ 次做对 $1$ 次做错进行循环。

时间复杂度为 $\mathcal{O}(\log M)$ ，来源于上面求得序列计算的快速幂。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m, k = MII()
    mod = 1000000009

    v1 = fmin(m, n - n // k)
    v2 = m - v1

    v1 -= (k - 1) * v2
    print((k * (pow(2, v2 + 1, mod) - 2) + v1) % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, k, mod = 1e9 + 9;
    cin >> n >> m >> k;

    int v1 = min(m, n - n / k), v2 = m - v1;
    v1 -= (k - 1) * v2;

    cout << (1ll * k * (quickPow(2, v2 + 1, mod) - 2) + v1 + mod) % mod;

    return 0;
}
```