**提示 1：** 如果只看 $x$ 对应的几位，数字改变的程度很小，因为加法操作很少。

**提示 2：** 于是发现，用来配凑后缀 $0$ 的 $+1$ 操作的次数是比较少的，利用这点设计状态进行 DP 。

首先，需要注意，这题的操作次数相当少，所以我们数字的前缀变动很小。如果我们只考虑 $x$ 所在的位，其变动幅度不超过 $k$ 。

（这里 $x$ 所在的位并不是很严格的表述，一开始 $x$ 的最低位在 $bit$ ，则 $+1$ 不改变最低位， $\times 2$ 使得最低位左移，最低位左侧所有的数字构成 $x$ 所在的位）

由于直接维护当前后缀进行考虑，尝试换个思路。

我们发现，当前后缀并不是所有信息我们都关心，我们只关系最后这个后缀会凑成多少个 $0$ ，以及凑成这些 $0$ 需要多少次 $+1$ 操作。

因此，我们更在意后缀最后能凑成的那些数，而这些数只能是 $x,x+1,\dots,x+k$ 。不妨设是 $x+i$ ，则我们可以迅速得到 $x+i$ 后缀 $0$ 的个数。

于是为了得到这些 $x+i$ ，考虑我们先 “欠着” 一些 $+1$ 操作，后面慢慢还。

设 $dp[i][j]$ 表示第 $i$ 次操作时，我们欠了 $j$ 次 $+1$ 操作情况下，期望的后缀 $0$ 个数。

则 $dp[0][j]$ 表示 $x+j$ 后缀 $0$ 的个数。

那么操作一次，上面的数值如何改变呢？

如果这次操作是 $+1$ ，则我们还清了一个 $j$ ，使得 $j$ 变成 $j-1$ 。即对 $dp[i+1][j-1]$ 更新上 $(1-p)dp[i][j]$ 。

如果这次操作是 $\times 2$ ，则我们还清 $+1$ 所需的操作次数翻倍，即 $j$ 变成 $j\times 2$ 。同时需要注意的是，此时相当于会多一个结尾的 $0$ ，转移时需要加上它，即对 $dp[i+1][j\times 2]$ 更新上 $p(dp[i][j]+1)$。

上述过程貌似漏掉了最低位的 $1$ 不在 $x$ 中的情形，但假设最低位的 $1$ 相当于是第 $j$ 轮的时候进行了 $+1$ 操作，则此时相当于欠了一个 $+1$ 操作，我们应该对 $dp[j][1]$ 进行调整。但由于 $1$ 的后缀 $0$ 个数恰好等于 $0$ ，乘以概率仍然等于 $0$ ，所以无需进行实际调整。

利用上述关系进行状态转移。

而我们要求的是 $k$ 次操作后还清所有 $+1$ ，因此，输出 $dp[k][0]$ 即可。

时间复杂度为 $\mathcal{O}(k^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    x, k, p = MII()

    p1 = p / 100
    p2 = 1 - p1

    dp = [[0] * (k + 1) for _ in range(k + 1)]
    for i in range(k + 1):
        v = x + i
        dp[0][i] = (v & -v).bit_length() - 1

    for i in range(k):
        for j in range(k + 1):
            if j * 2 <= k: dp[i + 1][j * 2] += p1 * (dp[i][j] + 1)
            if j > 0: dp[i + 1][j - 1] += p2 * dp[i][j]

    print(dp[k][0])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int x, k, p;
    cin >> x >> k >> p;

    long double p1 = (long double)1.0 * p / 100, p2 = 1 - p1;

    vector<vector<long double>> dp(k + 1, vector<long double>(k + 1, 0));

    for (int i = 0; i <= k; i ++) {
        int v = x + i;
        v = v & -v;
        dp[0][i] = 31 - __builtin_clz(v);
    }

    for (int i = 0; i < k; i ++) {
        for (int j = 0; j <= k; j ++) {
            if (j * 2 <= k) dp[i + 1][j * 2] += p1 * (dp[i][j] + 1);
            if (j > 0) dp[i + 1][j - 1] += p2 * dp[i][j];
        }
    }

    cout << fixed << setprecision(25) << dp[k][0];

    return 0;
}
```