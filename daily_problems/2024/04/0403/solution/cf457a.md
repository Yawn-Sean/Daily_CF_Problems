**提示 1：** 这里要比较两个浮点数大小，但浮点数大小面临精度误差问题。希望你的代码中只包含整数的计算。

**提示 2：** 两个 $q$ 进制的数并不能直接像二进制一样比较大小，即不能只从最高位开始一位位比较，因为最高位不够大。既然其不够大，就把它放到更低位再尝试比较。

**提示 3：** 两个数的比较不容易进行，因为难以化成一致的形式。怎么用一个数考虑问题？

题目中给出的数一定是如下形式——

$q^{i_1}+q^{i_2}+\dots+q^{i_k}, i_1\gt i_2\gt\dots\gt i_k$

我们要比较的是两个如此形式的数的大小。

注意到 $q$ 满足 $q^2=q+1$ ，于是，显然有 $q^{k+2}=q^{k+1}+q^k$ ，因此我们可以把每一个高位的 $1$ 拆成两个更低位的 $1$ 。

我们可以应用上述规则进行数的变换，但我们难以找到统一的形式表示两个数，于是，我们需要找到一个数帮助我们解决问题。

事实上，比较大小可以使用 **作差法** ， 即查看两个数的差和 $0$ 的大小关系。

作差后，每一位的系数只可能是 $1, 0, -1$ 三种情况。接下来，我们从最高位开始遍历，如果这一位有非零数值，则使用前面的 $q^{k+2}=q^{k+1}+q^k$ 将其变为更小的位。这样我们可以把开始的比较逐渐降次数，变为 $kq+b$ 的形式。

但是这里 $a, b$ 可能会变成很大的数，我们如何解决这个问题呢？

事实上，**只要遍历到某一位的时刻，某一次数的系数绝对值不小于 $2$ ，则可以直接得到比较结果** 。说明如下——

如果此时最高次系数为正，由于其当前系数不小于 $2$ ，其初始情况为 $-1,0,1$ ，两次高次带来的转移带来的该变量均为 $-1,0,1$ ，发现一旦其中出现 $-1$ ，最大和仅为 $-1+1+1=1<2$ ，不可能完成。因此，更高一次的转移不可能为负。

于是此时更低一次的系数不可能经过减的操作，其系数数值是 $-1,0,1$ 之一，而其他更低次项也没有经过转移，因此系数数值也为 $-1,0,1$ 之一，于是有作差结果不小于：

$2q^k-q^{k-1}-q^{k-2}-\dots-q^2-q-1>0$

可以比较大小。

类似地，如果最高次系数为负，则也可以确定大小关系。

于是，我们通过提前判断，解决了计算数值过大的问题，最后我们剩下了 $kq+b$ 和 $0$ 的大小比较，其中 $k, b$ 数值均不大。

显然，只有 $k=b=0$ 时，两数相等。

对于其他情况，这里可以简单使用浮点数，因为 $k, b$ 取值很有限且区别大。如果不想涉及浮点数运算，可以继续往下降次直至出现绝对值不小于 $2$ 的数值。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    a = I()
    b = I()

    n = max(len(a), len(b))
    a = '0' * (n - len(a)) + a
    b = '0' * (n - len(b)) + b

    x, y = 0, 0
    for i in range(n):
        x, y = x + y, x + int(a[i]) - int(b[i])
        if x > 1: exit(print('>'))
        if x < -1: exit(print('<'))

    if x == y == 0: print('=')
    else:
        while abs(x) < 2:
            x, y = x + y, x
        print('>' if x > 0 else '<')
```
