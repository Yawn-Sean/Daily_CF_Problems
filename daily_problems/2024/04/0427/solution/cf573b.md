**提示 1：** 考虑某一列的方块，有几种消除方式？

**提示 2：** 根据上面的消除方式，每个位置的消除时间应当满足什么条件？

一句话题意：现在有一排方块，每次消除边缘的所有方块（除下边缘），问几次消完？

那么每一列有几种可能的删除方式呢？有如下三种——

- 自己的事情自己做：自己从上往下一个个消除。

- 左边的一列帮忙：左边的一列消除完后，下一秒自己这一列也被消除了。

- 右边的一列帮忙：右边的一列消除完后，下一秒自己这一列也被消除了。

接下来我们考虑如上的删除方式如何操作。

第一种方式所需的时间是数组原来的数值 $nums[i]$ 。

第二种方式所需的时间是左边一列的时间加一，即 $ans[i-1]+1$ 。

第三种方式所需的时间是右边一列的时间加一，即 $ans[i+1]+1$ 。

我们对上述三种方式取最小值即可。

但其实我们一开始是不知道 $ans$ 数组的。怎么办呢？

我们先假设只有前两种方式，而我们知道 $ans[0]=1$ ，因此开头位置的答案已经确定，因此我们可以顺序用 $ans[i-1]+1$ 更新完答案。

引入第三种方式后，只需要从后往前用 $ans[i+1]+1$ 逆序更新一次即可。并且更新后的结果不会与前两种方式得到的结果发生冲突，因为这样更新下来，不会使得某一个 $i$ 有 $ans[i]>ans[i-1]+1$ 或 $ans[i]>nums[i]$ 。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()

    nums[0] = nums[-1] = 1
    for i in range(1, n):
        nums[i] = min(nums[i], nums[i-1] + 1)

    for i in range(n - 1, 0, -1):
        nums[i-1] = min(nums[i-1], nums[i] + 1)

    print(max(nums))
```