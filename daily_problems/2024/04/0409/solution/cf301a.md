**提示 1：** 两次操作你可以最少修改多少个元素？

**提示 2：** 如何利用上面的操作对元素做操作？

**提示 3：** 如何确定你给出的答案是最大的？

首先，如果你两次选的 $n$ 个元素中，有 $n-1$ 个元素是完全相同的，那么你这两次操作合起来，总共 **使得 $2$ 个元素变成了其相反数** 。

于是，如果一开始有偶数个元素是负数，我们总能使得最后每个元素均非负。

那么如果有奇数个元素是负数呢？

如果我们刚好 $n$ 也是奇数，那么我们做一次操作就可以使得元素个数变为偶数，即可使得所有元素均为非负。

否则，无论如何， **修改符号的元素的个数都是偶数，因为每次操作都操作偶数个元素** 。

因此，**所有数乘积的正负性不改变** 。如果开始是负数，那么结尾也是负数，至少需要把一个数设置为负数，不妨使其绝对值最小。

特殊的情况是乘积为 $0$ ，但这时可以跟 $0$ 进行两两操作，使得每个数都非负，因此也符合上面的规律。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()

    cnt = 0
    for num in nums:
        if num < 0:
            cnt += 1

    print(sum(map(abs, nums)) - cnt % 2 * ~n % 2 * 2 * min(map(abs, nums)))
```