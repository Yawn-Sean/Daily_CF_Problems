**提示 1：** 考虑每个数的二进制表示在乘法和除法的过程中会如何变化。

**提示 2：** 基于你对于提示 1 的观察，相当于使得数字的二进制表示（去掉后缀 $0$ ）一致。完成这件事的最小成本是多少？

**提示 3：** 最后，相当于尝试位置的对齐需要的最小成本，每次可以将位数改变 $1$ 。

这里对数字的操作是乘 $2$ 和除以 $2$ ，因此考虑数字的二进制表示是很合理的事情。

乘 $2$ 相当于在数字的末尾加上了一个 $0$ ，除以 $2$ 相当于去掉了数字的最后一位。其实其维持了数字的 **前缀** 不变。

而我们在除法操作之前进行乘法操作是没有意义的，因此我们先进行除法，再进行乘法。

除法的目标是，使得数字二进制表示去掉后缀 $0$ 后完全一致，而每次除以二相当于进行了一次取前缀操作，因此我们要找到这样的一个公共前缀。而每个数的二进制表示只有 $\mathcal{O}(\log M)$ 种前缀，可以通过不断除以 $2$ 得到。因此统计每个前缀出现的次数，取其中最大的，也就是二进制表示最长的。

找到这么一个公共前缀后，我们即可通过尽可能少的次数，使得我们的数字满足以之为前缀且后缀数字均为 $0$ ，做完这些操作即可。

接下来，我们得到了一个数列，其中差别只在于尾随 $0$ 的个数，我们要尝试通过乘 $2$ 和除以 $2$ 的操作使其完全相等。而这件事等价于使得这些数 **二进制表示的位数相等** ，因为其去掉尾随 $0$ 的前缀已经一致。

而每次操作相当于让二进制表示位数增加 $1$ 或者减少 $1$ ，因此该问题进一步等价于对于一个数组种元素进行尽可能少的 $+1$ 或 $-1$ 操作，使得数组中元素两两相等。

这个问题是常规的，选择数组中的中位数作为目标即可。具体而言，可以考虑最大值和最小值配对计算绝对值距离时，最小值是两者之差。如此不断往中间进行操作即可。

最终，时间复杂度为 $\mathcal{O}(n\log M + n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()

    cnt = [0] * (10 ** 5 + 1)
    for num in nums:
        while num:
            cnt[num] += 1
            num //= 2

    ma = max(cnt)
    for i in range(10 ** 5, 0, -1):
        if cnt[i] == ma:
            prefix = i
            break

    ans = 0

    for i in range(n):
        v = nums[i] // prefix
        while True:
            v, resid = divmod(nums[i], prefix)
            if v & -v != v or nums[i] % prefix:
                nums[i] //= 2
                ans += 1
            else: break
        nums[i] = nums[i].bit_length()

    nums.sort()
    print(ans + sum(abs(num - nums[n // 2]) for num in nums))
```
