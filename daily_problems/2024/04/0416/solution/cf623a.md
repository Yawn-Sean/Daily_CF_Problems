**提示 1：** 考虑给出的限制，有边对应的条件有极多的情况，但是没有边只能对应于 `'a'` 和 `'c'` 字符的排列。从这里入手。

**提示 2：** 假设一个位置的字符已经确定，则与其没有连边的位置的字符也已经确定。

**提示 3：** 如果一个点完全没有连边，其应当怎么填写字母？

先看提示 1，考虑不连的所有边，这个问题对应于更少的字母填写情况，是更好做的。因此我们用这些边考虑一个新图。

那么在这个新图中，两个相连的点一定是一个 `'a'`，一个 `'c'` 。于是，一旦一个连通块中一个位置填入了一个 `'a'` ，则其剩余的字符也都完全确定了。

而对于那些在新图中没有连边的点，相当于那个点是跟所有其他点相连的，选择填入 `'b'` 即可。

如果有多个大小大于 $1$ 的连通块呢？如何确定初始位置填 `'a'` 还是 `'c'` 呢？

事实上，如果有多个连通块，一定无法形成合法构造，因为两个连通块之间本应在新图中没有任何边，但两个连通块一定都填过 `'a'` 和 `'c'` ，因此发生矛盾。

综上所述，我们给出了构造，且得到了可以构造的条件：反图中至多只有一个大小大于 $1$ 的连通块，且若存在，该连通块可二染色。

当然，上述思路也可以换一个实现方法，即先尽可能满足条件，最后再检查，相对而言更容易完成代码。

二染色问题可以通过 BFS / DFS / 并查集解决，时间复杂度为 $\mathcal{O}(n^2)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, m = MII()
    graph = [[1] * n for _ in range(n)]
    for i in range(n):
        graph[i][i] = 0

    for _ in range(m):
        u, v = GMI()
        graph[u][v] = graph[v][u] = 0

    # 直接染色：0 表示 a，1 表示 b，2 表示 c
    # 这里没有直接判断对应的连通块个数，选择了直接染色，事后排查
    # 逻辑是一致的
    ans = [1] * n

    for i in range(n):
        if ans[i] == 1 and sum(graph[i]) > 0:
            stack = [i]
            ans[i] = 0
            while stack:
                u = stack.pop()
                for v in range(n):
                    if graph[u][v] and ans[v] == 1:
                        ans[v] = ans[u] ^ 2
                        stack.append(v)

    for i in range(n):
        for j in range(i):
            if (ans[i] ^ ans[j] == 2) != graph[i][j]:
                print('No')
                return

    print('Yes')
    print(''.join(chr(ord('a') + x) for x in ans))
```
