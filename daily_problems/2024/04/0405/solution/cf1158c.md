**提示 1：** 根据题目给出的条件，你能得到哪些下标之间的大小比较关系？

**提示 2：** 上面的关系过多，你能否使得大小关系的数量在不影响构造可行性的情况下得到缩减？

假设原排列为 $p$ ，且某个位置 $i$ 的 $next$ 数值是 $next_i$ ，则我们可以得到的大小关系比较是：

$\forall i\lt j\lt next_i, p_j\lt p_i$ 且 $p_{next_i}\gt p_i$ .

这些关系如果同时满足，那么构造出的排列也一定满足要求。

但是上述关系可能有 $\mathcal{O}(n^2)$ 种，如果我们直接根据其构造图得到拓扑序，会使得时间复杂度达到 $\mathcal{O}(n^2)$ ，无法通过本题。

一种想法是使用线段树建图，把中间区间小于左端点的拓扑关系用线段树中区间的节点进行刻画，这里不作过多介绍。

那么还有什么别的处理方法呢？我们考虑这些 $j$ 对应的 $p_j$ 应当满足什么要求。事实上，我们只需要要求 $p_j\leq p_i$ 即可。理由如下——

- 若 $p_j\lt p_i$ ，则比 $p_j$ 大的数先出现，所以 $p_j$ 显然更小。

- 若 $p_j=p_i$ ，则我们总可以钦定 $p_i\gt p_j$ 达成要求，否则两个位置交换即可。

- 若 $p_j\gt p_i$ ，说明 $p_{next_i}\lt p_j$ ，于是 $p_j\gt p_i$ ，矛盾。

**于是对于所有尚未取值的 $next_i$ ，直接钦定其为 $i+1$ 将最有利于上述条件的满足。**

接下来，对于一个完全确定的 $next$ ，我们要尝试构造一个满足之的数组 $p$ 。

我们发现，可以按照 $next$ 数组从小到大的顺序从小到大填入数字进行构造。因为这样构造， **前面填入的结果不会影响后面** 。为什么呢？

- 假设我们填入了所有 $next_i\lt k$ 的 $i$ ，接下来我们填入所有 $next_i=k$ 的 $i$ .

- 首先，此时填入的数不会造成前面填入的数的更多冲突，因为此时每个剩下的位置填入的数字都比之前填入的更大，因此，不影响已经填入的位置的 $next$ 数值。

- 同时，对于 $next_i=k$ 的 $i$ ，为了避免与 $next$ 数值更大的位置发生冲突，最优选择也是填入尽可能小的数字。

而为何这样能尽可能满足条件呢？理由如下——

- 考虑所有 $next_i=k$ 的 $i$ ，由于这些位置对应的 $next_i$ 都一致，因此从右边往左填入从小到大的数字，则可以在保证最右侧 $next_i$ 等于 $k$ 的情况下，尽可能保证左侧每一个对应位置 $next_i$ 均能等于 $k$，即尽可能避免内部冲突。

- 对于 $next_i\gt k$ 和 $next_i\lt k$ 的所有位置，这样填入也能尽可能满足上面 $p_i$ 的不等式关系。

于是，我们只需要按照 $next$ 数组从小到大的顺序依次填入 $1,2,\dots, n$ 即可，最后验证答案是否满足要求。

时间复杂度为 $\mathcal{O}(n)$ ，因为排序部分可以用基数排序解决。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    next_pos = LGMI()
    for i in range(n):
        if next_pos[i] == -2:
            next_pos[i] = i + 1
    
    pos = [[] for _ in range(n + 1)]
    for i in range(n):
        pos[next_pos[i]].append(i)
    
    ans = [0] * n
    cur = 1
    for i in range(n + 1):
        for j in reversed(pos[i]):
            ans[j] = cur
            cur += 1
    
    stack = [n]
    for i in range(n - 1, -1, -1):
        while stack[-1] != n and ans[i] > ans[stack[-1]]:
            stack.pop()
        if next_pos[i] != stack[-1]:
            return [-1]
        stack.append(i)
    return ans
```
