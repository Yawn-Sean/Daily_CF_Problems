/*
点权尽可能大，边权尽可能小，则密度就尽可能大
选的子图需要连通
考虑直接选边
每个边被选时，说明它的两个端点也被选了
似乎选一棵树比较好，因为不是树的话只要断掉一些边变成树就会使得密度更大
选一个点权尽可能大，边权尽可能小的生成树
但是生成树未必包含图中所有的点
选一个点 root 作为生成树的起点
之后每考虑加入一个点 u，假如这条边的边权为 e，u 的点权为 v，则希望 v / e 尽可能大
在求生成树的过程中，边求边记录点权和边权和，并且记录比值的最大值

羊：实际上，我们只要看两个点，它们的点权之和 / 边权之和最大即可，因为新加其他点和边必然会拖累这个答案（糖水浓度不等式）
*/

int T;
int n, m;
LL x[N];
LL w[N][N];

// 只看一条边
void solve2() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> x[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            w[i][j] = INF;
        }
    }
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    double res = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (w[i][j] != INF) {
                res = max(res, (x[i] + x[j]) / (1.0 * w[i][j]));
            }
        }
    }
    printf("%.15lf\n", res);
}                                                                                                                            