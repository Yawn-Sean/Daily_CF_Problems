**提示 1：** 如果所有堆均只有一个石子，你应该怎么操作？

**提示 2：** 尝试用一棵树表示你的合并过程，你的答案如何用这棵树表示？

**提示 3：** 如果每一堆的数量不是 $1$ ，应当怎么处理？

在利用提示 1 进行尝试时，请对于一个固定的 $k$ ，一个一个增加 $n$ 查看结果，相信你能有所发现。

接下来正式叙述本题的具体做法。

我们将合并的过程刻画为一个图，每一次 $x$ 到 $y$ 的合并对应一次从 $x$ 引向其父节点 $y$ 的边。那么所有的合并过程（共计 $n-1$ 次）将让整个图连通，因此形成 **一棵树** 。

而我们所求的答案等于 **每个子树的权值之和** ，从每个点的贡献来看，每个点在各个子树中出现的次数仅与其深度有关，因此，所求的答案等于 **每个节点的权值和深度的乘积之和** （根节点认为深度为 $0$ ）。

于是，我们需要构造一棵尽可能 “浅而宽” 的树。

而题目中有何限制呢？每一个节点的子节点数量不超过 $k$ .

因此我们可以得到，深度为 $0$ 的节点至多有 $1$ 个，深度为 $1$ 的节点至多有 $k$ 个，……，深度为 $i$ 的节点至多有 $k^{i}$ 个。我们可以根据这个逻辑构造一棵满足条件的树。

而在节点有权值的情况下，我们应当将大权值放在尽可能浅的地方，因此开始进行倒序排序即可。

对于每一个 $k$ ，可以使用 $\log_k n$ 次找到每一层节点对应的区间，而使用前缀和可以将其求和变为 $\mathcal{O}(1)$ 的，因此对于每一个 $k$ ，求解用时为 $\mathcal{O}(\log_k n)$ .

对于 $k=1$ ，可以直接预处理数值，其余的 $k$ 时间复杂度不超过 $\mathcal{O}(\log_2 n)$ ，因此本题总时间复杂度为 $\mathcal{O}(n+q\log_2n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()
    nums.sort(reverse=True)
    acc = list(accumulate(nums, initial=0))

    # 这里是通过预处理所有 k 有意义对应的结果数值进行任务完成的
    ans = [0] * (n + 1)
    for i in range(1, n + 1):
        pt = 1
        cur = i
        weight = 1
        while pt < n:
            ans[i] += (acc[min(pt + cur, n)] - acc[pt]) * weight
            pt += cur
            cur *= i
            weight += 1

    q = II()
    print(' '.join(str(ans[min(x, n)]) for x in MII()))
```