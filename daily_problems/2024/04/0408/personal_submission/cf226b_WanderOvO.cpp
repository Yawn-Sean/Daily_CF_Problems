/*
如果没有合并次数限制，只需要把其他的堆合并到最大的堆上即可，答案是所有堆的和 - 初始最大的堆
如果有合并次数限制，则考虑如何让初始比较大的堆的贡献次数尽可能小
假如合并次数限制为 n - 2 次，则把最小的合并到第二小的上面，然后剩下的再都合并到最大的上边即可
假如有 4 堆，每堆可以被合并 1 次，则每堆可能不止贡献 1 次，甚至不止贡献 2 次
感觉像哈夫曼树
i 合并到 j 上，则认为 i 是 j 的儿子
限制至多往每个上面合并 k 次，则说明每个结点的直接儿子至多有 k 个
最终代价就是每个子树的权值和的和
贪心，尽量让树深度小一些，让权值大的结点靠近根部
至多有 1 个点等待被别人合并，至多有 k 个点只合并一次，至多 k^2 个点合并 2 次...
复杂度：k >= 2 的时候，每次可以使用预处理的值算一段区间，至多有 log_k(n) 个区间
k = 1 的时候，是一条链，预处理出来直接返回即可
*/

int T;
LL n, a[N], q, sum[N];

void solve1() {
    cin >> n;
    LL s = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    reverse(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++) {
        s += a[i] * (i - 1);
        sum[i] = sum[i - 1] + a[i];
    }
    cin >> q;
    LL k;
    while (q--) {
        cin >> k;
        if (k == 1) {
            cout << s << " ";
        } else {
            LL len = 1, l = 1, r;
            LL cnt = 0;
            LL res = 0;
            while (l <= n) {
                r = min(n, l + len - 1);
                res += (sum[r] - sum[l - 1]) * cnt;
                cnt++;
                len *= k;
                l = r + 1;
            }
            cout << res << " ";
        }
    }
}                