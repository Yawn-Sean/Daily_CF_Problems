**提示 1：** 题目中给出的大小关系实际上可以分为二元组间和二元组内的，先考虑组内限制。

**提示 2：** 组间性质尝试贪心满足。

我们要求最后构造的数组是增减交替的，而这里的增减一部分来自拼接的部分，一部分来自于数对本身的增减。

我们看题目中给出的两种变化模式：

- $x_1\lt x_2\gt x_3\lt x_4\gt\dots\gt x_{2k-1}\lt x_{2k}$

- $x_1\gt x_2\lt x_3\gt x_4\lt\dots\lt x_{2k-1}\gt x_{2k}$

我们先看选取的对内部应该满足的大小关系，发现 **在第一种情况下，组内满足前一项小于后一项；第二种情况下，组内满足前一项大于后一项** 。

于是我们把题中给出的数对分为两类，一类 $a\lt b$ ，一类 $b\lt a$ ，接下来考虑两种情况下应当如何组合这些数对。

在第一种情况下，我们组合的过程中应当使得前一项的 $b$ 大于后一项的 $a$ 。

为了使这个条件更容易满足，我们应使得前一项的 $b$ 尽可能大，以增加后一项的选择空间，因此关于 $b$ 降序排列。（选择关于 $a$ 降序排列也可以，考虑成从后往前构造中留出足够空间）

这样排序后是否满足要求呢？假设排序后，相邻两项为 $i, j$ ，则 $b_i\gt b_j\gt a_j$ ，恰好满足排成序列的条件。

于是序列中的每个数对均可以构造进答案。

第二种情况类似，选择关于 $a$ 升序排列 / 关于 $b$ 降序排列。

于是，两种情况我们都可以使用所有元素进行结果的构造，我们只需取其长度最大值即可。

时间复杂度为 $\mathcal{O}(n\log n)$ ，复杂度来源于排序。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    a = []
    b = []
    cnt = 0
    for _ in range(n):
        x, y = MII()
        a.append(x)
        b.append(y)
        if x > y: cnt += 1

    if cnt * 2 >= n:
        chosen = [i for i in range(n) if a[i] > b[i]]
        chosen.sort(key=lambda x: a[x])
    else:
        chosen = [i for i in range(n) if a[i] < b[i]]
        chosen.sort(key=lambda x: -b[x])

    print(len(chosen))
    print(' '.join(str(x + 1) for x in chosen))
```