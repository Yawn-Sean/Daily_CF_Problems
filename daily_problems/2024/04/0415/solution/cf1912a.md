**提示 1：** 考虑每一个数组，其中有哪些前缀是可能被取到的？

**提示 2：** 这些前缀应该能要就要。如何刻画一个数组从一个前缀变成另一个前缀的调整？

我们考虑每一个数组，其前缀可取的条件是当前数加上此前 **前缀和最小值** 的和非负。

而怎样的前缀是我们应该考虑的呢？这个前缀和应当比 **之前的前缀和都大** ，不然我们还不如取前面的那个。

因此我们可以把数组用一系列的数对刻画，数对描述了某个位置的 **之前的前缀和的最小值** （为了保证可取性质）与 **前缀和** ，其中后者是递增的。

而这些前缀具有依赖关系，即只有取了前一个前缀才能取后一个前缀，于是不能让两个前缀对于 $x$ 增加的贡献被重复计算。因此我们考虑将后面的前缀和减去前面的作为新的贡献，即取的前缀如果长度增加，我们只计算新增的一部分的和，而这一部分和需要是正的。

对于这样的每一个经过调整的数对，如果我们当前的数加上这个最小值非负，此时就可以进行操作，那么我们就可以使用后面正的贡献，一定得到更大的数值。因此我们能操作就操作。

最后，只需要将前缀和的最小值进行降序排列。这样可以保证我们操作得最多。我们只要 $x$ 加上最小值能维持非负，我们就可以要这个前缀。如此直到不可操作，贪心一定能使得最后 $x$ 最大。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    x, k = MII()
    ops = []

    for _ in range(k):
        n, *nums = MII()
        v = 0
        mi = 0
        ma = 0
        lma = ma
        for num in nums:
            v += num
            mi = min(mi, v)
            ma = max(ma, v)
            if ma > lma:
                ops.append((-mi, ma - lma))
                lma = ma

    ops.sort()
    for mi, ma in ops:
        if x < mi: break
        x += ma

    print(x)
```
