**提示 1：** 如果原来的非递减序列进行了一次反转操作，其会变成什么形式？

**提示 2：** 如何统计对应的形式的最长的子序列？

事实上，最后的非递减序列一定是 $1,1,\dots,1,2,\dots,2,2$ 的形式，而如果在前面的 $1,1,\dots,1$ / $2,2,\dots,2$ 中反转，则完全不影响；否则会变成一段 $1$ ，一段 $2$ ，一段 $1$ ，一段 $2$ 的形式。

如果我们使得其中每一段的长度可以为 $0$ ，那么最后子序列在反转前总可以表示为一段 $1$ ，一段 $2$ ，一段 $1$ ，一段 $2$ 。

因此可以直接使用这个性质进行 DP，四种状态是选取到了第几段子序列，分别对应于 $dp_1, dp_{12}, dp_{121}, dp_{1212}$ ，则由于每段子序列可以非空，每一个状态可以直接转移为后一个状态。而如果当前数字是 $1$ ，则第一种和第三种状态长度可以 $+1$ ；否则，第二种和第四种状态长度可以 $+1$ 。

这样我们就用 $\mathcal{O}(n)$ 的动态规划解决了这个问题。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()
    dp1, dp12, dp121, dp1212 = 0, 0, 0, 0

    for num in nums:
        if num == 1:
            dp1 += 1
            dp121 += 1
        else:
            dp12 += 1
            dp1212 += 1
        dp12 = max(dp1, dp12)
        dp121 = max(dp12, dp121)
        dp1212 = max(dp121, dp1212)

    print(dp1212)
```