这里主要讲述只需要进行排序和遍历的做法。

**提示 1：** 我们选取的区间需要满足什么条件？

**提示 2：** 如何尽可能让我们在考虑一个区间前考虑所有可能覆盖掉它的区间？

首先，一个区间可以去掉当且仅当这个区间覆盖的每个点都可以被其他区间覆盖。

如果我们考虑区间 $[l,r]$ ，我们如果是从左到右考虑区间，我们至少应该先把所有左端点不超过 $l$ 的区间全部考虑进来。这样，如果这些区间构成的右端点已经大于了 $r$ ，那么这个区间已经得到了覆盖。此时，**只需要判断右端点** 。

在如上情况下，如果两个区间有包含关系，则已经确认找到了答案，因此接下来无需考虑区间包含。

但事实上，还有可能 $[l,r]$ 是左端点不超过 $l$ 的区间，以及左端点更大的某些区间一起覆盖的。

而由于此时 **区间之间互不包含**，因此这些左端点更大的区间，右端点一定已经大于 $r$ 了，因此 **只需要考虑这些区间中左端点最小的即可** 。只需这个区间可以跟前面的区间组右端点搭配一起覆盖 $[l,r]$ 即可。

接下来我们整合上面的两个逻辑。第一个逻辑要求我们找到所有左端点更小的区间，第二个逻辑要求我们找到左端点更大的区间。因此我们可以将区间 **关于左端点从小到大排序** ，再执行上面的两种判断。

而为了得到左端点不超过 $l$ 的区间的右端点的最大值，我们应当在上述排序的基础上，**以右端点为第二关键字降序排序** 。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    ls = []
    rs = []
    for _ in range(n):
        l, r = MII()
        ls.append(l)
        rs.append(r)
    
    st_range = sorted(range(n), key=lambda x: ls[x] * 2 * 10 ** 9 - rs[x])
    i1, i2 = -1, -1
    for i in st_range:
        if i1 >= 0 and rs[i1] >= rs[i]:
            print(i + 1)
            break
        if i2 >= 0 and ls[i] <= rs[i2] + 1:
            print(i1 + 1)
            break
        i1, i2 = i, i1
    else:
        print(-1)
```