**提示 1：** 我们要最小化操作次数，并且尽可能降低操作成本，才能最终降低总成本。

**提示 2：** 从小到大考虑到某数为止的最小操作成本。

我们接下来的做法基于题目转义的表述：将一个数组进行单项的加一操作，使得数组之中的数字两两不同，每个位置中数字增加的成本给出。

首先，以更少的操作次数完成任务一定是更优的。假设某一个状态，对应的操作不是最少的，则一定可以挑选一个操作不进行，少付出一次成本，因此得到的结果一定可以更小。

于是，总操作次数一定是最少的。

由于数字是单调增加的，因此我们从小到大考虑数字应当如何进行操作。

我们假设到 $x$ 数字时，小于等于 $x$ 的数已经完全确定，而剩下有一批数字是重复的，即经过此前的所有操作后都为 $x$ ，那么我们考虑 $x+1$ 的时候我们又会多一批新的数字。

这些数字中，只有一个可以选择不继续加一而留在 $x+1$ 的地方，那么我们一定 **留下成本最高的** ，这样我们剩余数字加一的成本会最低，接下来对剩下的数字继续进行加一操作即可。

由于我们需要不断添加新数并提取最大数，故我们需要用堆来实现这件事。

而我们的数字范围很大，因此在中间堆里没有元素时，需要跳过中间无需操作的数。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()
    time = LII()

    hpq = []
    tot = 0
    last_t = 0

    ans = 0
    for i in sorted(range(n), key=lambda x: nums[x]):
        # 尝试用两个数中间的空来填数
        for _ in range(nums[i] - last_t):
            if len(hpq) == 0: break
            tot += heappop(hpq)
            ans += tot
        
        heappush(hpq, -time[i])
        tot += time[i]
        last_t = nums[i]

    # 最后剩下的数得填完
    while hpq:
        tot += heappop(hpq)
        ans += tot

    print(ans)
```