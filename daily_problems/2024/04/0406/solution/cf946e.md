**提示 1：** 如何判断一个数字是否是 “美丽数” ？

**提示 2：** 要比原有的数字更小，需要满足的条件是什么？

对于第一个问题，答案非常简单：每个数码出现的次数都是偶数次。

对于第二个问题，答案是：在补全前导零使得表示两个数字的字符串长度一样时，两个字符串第一个不同的位置满足新数字字符小于原有数字字符。

先设原有字符串的长度为 $n$ .

如果两个数字的长度不同，则第二个字符串除了长度不超过 $n-1$ 外，没有其他限制，因此可以尽可能多地填写偶数个 $9$ ，即 $\lfloor\frac{n-1}{2}\rfloor\times 2$ 个 $9$ 。

否则，新数字一定和原数字长度相等，而在题目要求的限制下，原数字的长度为偶数。

此时，新数字的字符串表示一定存在前缀，与原数字的字符串表示前缀相等。而这个前缀越长，得到的数字越大。

因此从长到短遍历前缀（至少长度为 $1$ ），对于第一个不同的字符，从大到小枚举其可行取值，则接下来所有字符没有任何限制。

而此时，前缀中出现奇数次的字符在后面也必须出现一次，其余位置可以全部填 $9$ ，这样填写 $9$ 的次数也恰好增加偶数次，因为数字总长为偶数。此时一定是最优的数字选择方案，因为 $9$ 是能选取的最大字符，且不与其他条件发生矛盾。

因此，只要此时空缺的字符足够填入所有出现奇数次的字符，则即可构造最优答案。而后面这些没有限制的字符应当倒序排列，以使得结果最大。

时间复杂度为 $\mathcal{O}(n)$ ，因为最多每一位枚举 $9$ 种不同取值，而只要枚举 $11$ 次后缀。就至少有 $10$ 个位置可以供我们任意填数。

#### 具体代码如下（只包含中间处理部分）——

```Python []
bit_count = [bin(i).count('1') for i in range(1 << 10)]
def main():
    s = I()
    msk = 0
    for c in s:
        msk ^= 1 << int(c)
    
    n = len(s)
    ans = ''
    if n % 2 == 0:
        for i in range(n - 1, -1, -1):
            msk ^= 1 << int(s[i])
            for j in range(int(s[i]) - 1, -1, -1):
                if i == j == 0: break
                nmsk = msk ^ (1 << j)
                if bit_count[nmsk] <= n - i - 1:
                    ans = s[:i] + str(j) + '9' * (n - i - 1 - bit_count[nmsk]) + ''.join(str(x) for x in range(9, -1, -1) if nmsk >> x & 1)
                    break
            if ans: break
    return ans if ans else '9' * ((n - 1) // 2 * 2)
```