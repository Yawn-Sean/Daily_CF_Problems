**提示 1：** 从上一次拿牌的位置开始考虑，每一次拿的牌应当满足什么条件？

**提示 2：** 如何快速找到下一次要拿的牌？

**提示 3：** 在知道拿牌顺序后，如何确定进行几次操作？

我们不需要模拟拿牌的过程，我们把拿牌的过程理解为：

- 从某个位置开始往后寻找，直到找到当前数组的最小值。每次移动寻找的位置需要 $1$ 个成本。

- 将其删去，需要 $1$ 个成本。

这样，我们每次删去的位置相当于是 **上次删去数据的位置后，第一次出现最小数据的位置** 。

而由我们最后取出的序列是一个原数组排序后的序列，我们每次都可以马上找到下一次取的数是多少。

接下来，只需在对应的数出现的下标中，寻找最接近上一次取的位置的下标即可（在后面的）。

因此，我们统计每个元素出现的下标，上述过程即可通过二分实现。而同一个大小的数只需找到第一个取的位置，之后取的位置便都已知了。

于是，综上，我们得到了 **我们取数的下标顺序** 。接下来求操作次数。

其实我们就是看 **相邻两次取数的下标之间有多少个数还没有被取出来** 。

这是个区间查询的问题，我们只需要更新每个位置是否还有元素。因此整体是单点更新，区间求和的问题，可以通过树状数组实现。

综上，时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()

    idxs = [[] for _ in range(10 ** 5 + 1)]
    for i in range(n):
        idxs[nums[i]].append(i)

    fen = FenwickTree(1 for _ in range(n))

    ans = 0
    pt = 0
    for v in range(10 ** 5 + 1):
        p = bisect.bisect_left(idxs[v], pt)
        m = len(idxs[v])
        for idx in range(m):
            i = idxs[v][(p + idx) % m]
            if i >= pt:
                ans += fen.rsum(pt, i)
            else:
                ans += fen.rsum(pt, n - 1) + fen.sum(i)
            fen.add(i, -1)
            pt = i

    print(ans)
```