**提示 1：** 先考虑只有两个字符串，此时两者应该怎么排？

**提示 2：** 如果有多个字符串，其中两个相邻的字符串满足上面的条件，其交换是否是能使得结果增大的？

**提示 3：** 不断进行交换操作，结果如何？

我们先考虑只有两个字符串的情况，假设为 $s_1, s_2$ 。

设 $s_1$ 中有 $c_{1s}$ 个 `'s'` ，$c_{1h}$ 个 `'h'` ，以及 $c_1$ 个 `'sh'` 作为其子序列；$s_2$ 中有 $c_{2s}$ 个 `'s'` ，$c_{2h}$ 个 `'h'` ，以及 $c_2$ 个 `'hs'` 作为其子序列。

此时如果不进行交换， `'sh'` 子序列的数量为 $c_{1s}c_{2h}+c_1+c_2$ ；如果进行交换 $c_{2s}c_{1h}+c_1+c_2$ 。

因此交换更不劣，当且仅当 $c_{2s}c_{1h}\geq c_{1s}c_{2h}$ .

而在有更多字符串的情况下，如果交换相邻的两个字符串，其他位置形成的 `'sh'` 子序列不受影响，其他位置与当前交换位置形成的 `'sh'` 数量也仍然不改变，因此交换带来的效果仍然与前面的分析一样，是 $c_{2s}c_{1h}-c_{1s}c_{2h}$ .

于是，如果最后的字符串排序结果存在某个位置，使得 $c_{2s}c_{1h}\gt c_{1s}c_{2h}$ ，则总可以交换这两个字符串，使得结果变大。

因此我们最后字符串的排序结果应当满足，对于任意相邻两项字符串，都有 $c_{2s}c_{1h}\geq c_{1s}c_{2h}$ ，于是可以关于这个比较关系排序，而中间相等的元素相互交换完全不影响结果。

这里不建议根据 $\frac{c_{2s}}{c_{2h}+c_{2s}}\geq\frac{c_{1s}}{c_{1h}+c_{1s}}$ 对比值排序，尽管其写起来更方便，但浮点数的比较可能产生偏差。

排序后，我们相当于计算一个拼好的字符串中 `'sh'` 子序列的个数。我们可以计算到每个位置为止的 `'s'` 和 `'sh'` 子序列分别的个数，DP 统计即可。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    def cmp(i, j):
        if hs[i] * ss[j] > ss[i] * hs[j]: return 1
        if hs[i] * ss[j] < ss[i] * hs[j]: return -1
        return 0

    n = II()
    strs = [I() for _ in range(n)]
    hs = [s.count('h') for s in strs]
    ss = [s.count('s') for s in strs]

    st_range = sorted(range(n), key=cmp_to_key(cmp))
    cnt_s = 0
    ans = 0
    for i in st_range:
        for c in strs[i]:
            if c == 's': cnt_s += 1
            else: ans += cnt_s

    print(ans)
```
