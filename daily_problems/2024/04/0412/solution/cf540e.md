**提示 1：** 总共有多少个元素改变了位置？

**提示 2：** 哪些位置的元素会参与最后的逆序对的计算？

**提示 3：** 所有要考虑的元素数量过多，能否将同类的进行合并？如何考虑合并后的元素？

首先，由于每次操作两个位置的数，因此最终数组中改变位置的元素的数量至多为 $2n$ ，也至多只有 $2n$ 个位置的数字发生改变。

而参与运算的位置就在这 $2n$ 个位置的最小值和最大值之间。

这里的最小值和最大值差别可能很大，因此我们需要考虑将 “同样作用的数” 合并。

我们发现，首先这 $2n$ 个位置本身是重要的。而 $2n$ 个位置中包含 $2n-1$ 个间隔。**每个间隔中的数位置都不发生改变，内部不产生逆序对，且与其他位置的相对大小关系是确定的** ，因此可以一起考虑用一个元素代替，这个元素的长度等于区间的长度。

接下来，我们可以根据题目中的交换转换为一个序列，该序列包含大小关系的信息，及每个元素长度的信息。

而最后要求总逆序对的个数，可以采用树状数组 / 归并排序等方式实现。

- 树状数组：在每一次计算逆序对时，计算前面比它大的元素的长度总和，与当前长度相乘即可。

- 归并排序：每一次归并过程中带来的逆序对计数——已经在序列中的总长度乘以当前元素长度。

整体而言是普通逆序对问题的简单推广，时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    rnd = random.getrandbits(20)
    
    d = {}
    for _ in range(n):
        x, y = MII()
        x += rnd
        y += rnd
        if x not in d: d[x] = x
        if y not in d: d[y] = y
        d[x], d[y] = d[y], d[x]

    pos = {d[v]: v for v in d}
    pts = sorted(d)
    map_pos = {v: i * 2 for i, v in enumerate(pts)}
    
    n = len(pts)
    fen = FenwickTree(2 * n - 1)
    
    ans = 0
    for i in range(n - 1, -1, -1):
        if i < n - 1:
            p = 2 * i + 1
            ans += fen.sum(p) * (pts[i + 1] - pts[i] - 1)
            fen.add(p, pts[i + 1] - pts[i] - 1)
        
        p = map_pos[pos[pts[i]]]
        ans += fen.sum(p)
        fen.add(p, 1)
    
    print(ans)
```