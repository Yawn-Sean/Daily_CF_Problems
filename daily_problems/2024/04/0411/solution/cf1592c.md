**提示 1：** 考虑所有连通块异或和的异或和，其数值等于每个元素的异或和。

**提示 2：** 一堆相同的元素取异或和，结果可能是什么？

**提示 3：** 根据提示 2 中你给出的结论，如何确定最后连通块的异或和？如何确定是否能分拆成对应数量？

首先，如果你没看提示的话，请先阅读提示 1 。

接下来，考虑每个连通块的异或和 $x$ ，则所有连通块异或和的异或和是若干个 $x$ 的异或和，结果为 $0$ 或者 $x$ （分别对应连通块数量是偶数 / 奇数的情形），而这个数也恰好是每个元素的异或和。

根据上述结论，如果每个元素的异或和非 $0$ ，那么构造的连通块异或和应当与之相等。

那么，如果每个元素的异或和恰好等于 $0$ 呢？此时，**我们任意切割一条边，得到的两个连通块的异或和的异或恰好为 $0$**，两者相等，满足条件，直接输出 `'YES'` 即可。

而如果每个元素的异或和非 $0$ ，我们需要拆分成奇数个连通块，因此 **如果 $k=2$ ，则只允许拆分为 $2$ 个连通块，此时无法达成条件，返回 `'NO'` 即可。**

而在其他情况下，如果能拆分成大于 $3$ 个连通块，那么我们取两个包含叶子的连通块不做操作，剩余连通块合并，则由于不变的两个连通块异或和满足条件，剩余的连通块由奇数个原有连通块构成，异或和也满足条件，因此也符合要求。于是，**如果我们能做到拆分成足够多的连通块，那么我们总可以做到拆分成 $3$ 个连通块** 。

于是，接下来我们寻找最多的连通块分割个数。这件事情可以贪心解决，从叶子节点往上走，一旦遇到异或和等于 $x$ 的连通块即计数 $+1$ 并开启新连通块，这样即可统计最多个数，只需其大于 $3$ 即可返回 `'YES'` ，否则返回 `'NO'` 。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, k = MII()
    nums = LII()
    
    path = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    val = reduce(xor, nums)
    if val == 0: return 'YES'
    elif k == 2: return 'NO'
    else:
        parent = [-1] * n
        stack = [0]
        order = []
        while stack:
            u = stack.pop()
            order.append(u)
            for v in path[u]:
                if parent[u] != v:
                    parent[v] = u
                    stack.append(v)
        dp = [0] * n
        xor_value = nums[:]
        for u in reversed(order):
            if xor_value[u] == val:
                dp[u] += 1
                xor_value[u] = 0
            if u:
                dp[parent[u]] += dp[u]
                xor_value[parent[u]] ^= xor_value[u]
        return 'NO' if dp[0] == 1 else 'YES'
```