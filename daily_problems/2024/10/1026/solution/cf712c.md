**提示 1：** 如果我们从 $x$ 开始操作到 $y$ ，会面临什么问题？

**提示 2：** 所有操作都是可逆的。

**提示 3：** 反向考虑，相当于从 $y$ 得到一个不小于 $x$ 的数。

这题一上来，很容易开始正向尝试。但是至少有以下问题：

- 减少了某边长度后，突然构成不了三角形了。

- 由于存在三角形的限制，每次减小变长不是减小的越多越好。很难找到真的最优的点，且难以说理。

但是，我们可以注意到，所有操作都是可逆的，我们把操作的序列反过来，相当于从小三角形构造大三角形。

此时，只要我们生成的新边小于另外的两边之和即可满足限制。

而我们最终只需得到至少一条长度至少为 $x$ 的边（第一次满足这一条件时，一定恰好只有一条边长度为 $x$ ），则最后一次操作可以调整为将那条边变成 $x$ 。而剩下的两条边依次赋值为 $x$ 即可。于是我们只需求出恰好使得一条边长度不小于 $x$ 的最小步数。

同时，这时我们生成的边越长越好吗？答案是肯定的。我们每次贪心地取最大的两条边，再将剩下的一条边替换为两边之和减 $1$ ，这样能保证我们最长的两条边始终最长，也就能以最小的步数到达至少为 $x$ 的条件。

通过将问题的转化，我们在两个方面发生进展：一是前后的三角形条件不再发生依赖关系，因为产生的总是最长边，而最长边确定，三角形的条件只需列一条；二是使得情况可以通过贪心进行分析，不会存在局部最优的问题，因为目标都是使得最大边长最大。目标的一致性对于贪心而言很重要。

这里也给了我们启示，即使用贪心时，要想 “这样做真的是最优的吗” 。

这么做的复杂度如何呢？发现每次最长的边会以指数级增长（增长速度至少为斐波那契数列），因此最多 $\mathcal{O}(\log M)$ 次操作即可到达至少为 $x$ 的边长。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    x, y = MII()

    a, b = y, y
    cnt = 0

    while a < x:
        a, b = a + b - 1, a
        cnt += 1

    print(cnt + 2)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int x, y;
    cin >> x >> y;

    int a = y, b = y, cnt = 0;

    while (a < x) {
        b += a - 1;
        swap(a, b);
        cnt ++;
    }

    cout << cnt + 2;

    return 0;
}
``` 