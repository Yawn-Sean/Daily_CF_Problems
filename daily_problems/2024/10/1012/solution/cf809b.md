**提示 1：** 如果只需找到一个答案，你可以找到吗？注意查询次数的提示。

**提示 2：** 接下来，利用前一次的结果，分别处理左边和右边。之前查到的元素是否会对后面产生影响？

首先，总长 $10^5$ ，而查询次数 $60$ ，容易引发二分的猜测。

如果我们只有一个元素要查，应该怎么办呢？即 $k=1$ 的情况。

假设当前区间为 $[l,r]$ ，我们怎么让查询区间减半呢？

一种方式：查询 $l,r$ 两点，如果左侧更近，就在左侧查询。

另一种方式：我们查询点 $x,x+1$ ，如果左侧更近也说明了就在左侧。只需取 $x$ 为中点即可让区间长度每次减半。

这两种方式本质上是一致的，就是挑选了两个点，根据其中点将整个区间分为了两个几乎等长的部分。

如果 $k$ 更大，上述两种方式实际上也都可以保证减半后的区间里包含目标。因此我们可以二分找到其中一个答案。

接下来怎么办呢？我们需要利用前一次的结果。现在数组被前一次的结果分为了左右两段。我们尝试在左边和右边分别查找答案。

此时，第一种方式就失灵了，因为我们初始的区间有一个端点离我们刚刚找到的答案很近。考虑使用第二种方式，因为其相对而言是最不受区间外的点的影响的（具体逻辑可见后面的说明）。

为什么第二种方式是合理的呢？

如果 $[l,r]$ 区间中包含答案，同时仅仅 $r+1$ 处有元素，则其离中点更近的元素一定在区间 $[l,r]$ 中，而不在 $r+1$ 处。即可发现 $r+1$ 处的元素对结果没有影响。

于是直接对左边进行二分即可。如果找到了答案，则直接输出，否则再在右边进行二分。

如何判定找到了答案呢？我们可以使用之前找到的点 $x$ 和这次找到的 $y$ 对比，查看 $query(y,x)$ 即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    def query(x, y):
        print(1, x, y, flush=True)
        return True if I()[0] == 'T' else False

    def search(l, r):
        while l < r:
            m = (l + r) // 2
            if query(m, m + 1): r = m
            else: l = m + 1
        return r

    def answer(x, y):
        print(2, x, y)

    n, k = MII()
    x = search(1, n)
    y = search(1, x - 1)
    if y == 0 or not query(y, x): y = search(x + 1, n)
    answer(x, y)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    auto query = [&] (int x, int y) {
        cout << 1 << ' ' << x << ' ' << y << endl;
        string s;
        cin >> s;
        return s[0] == 'T';
    };

    auto f = [&] (int l, int r) -> int {
        while (l < r) {
            int m = (l + r) / 2;
            if (query(m, m + 1)) r = m;
            else l = m + 1;
        }
        return r;
    };

    int n, k;
    cin >> n >> k;
    int x, y;
    x = f(1, n);
    y = f(1, x - 1);
    if (y == 0 || !query(y, x)) y = f(x + 1, n);

    cout << 2 << ' ' << x << ' ' << y;

    return 0;
}
```
