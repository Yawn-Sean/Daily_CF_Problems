/*
先 sort 一下
假如都在同一个组，则就是 a[n - 1] + a[n] - a[1] - a[2]，首先把这个先算出来作为基准
考虑最开始就是一个组，然后不断从一个组里往外掏
掏大的还是掏小的？
假如只拿一个最小值，则最小值一定会变大，最大值可能变大，min(a[1] + a[2] + h, a[2] + a[3])
假如只拿一个次小值，则最小值也一定会变大，最大值可能变大，min(a[1] + a[2] + h, a[1] + a[3])
假如最小和次小都不拿，则最小值一定不变，最大值可能变大
假如最小和次小都拿，则最小值不变，最大值可能变大
假如动最小的时候还动其他数，则最大值可能变大，不优

假如只拿一个最大值，则最小值不变，最大值一定变大
假如只拿一个次大值，则最小值不变，最大值一定变大
假如最大和次大都拿或者都不拿，则最小值和最大值都不变

假如这四个数都不管，只动中间的数，则最小一定不变，最大只可能变大，肯定不优

所以，我们只需要讨论最小值和次小值怎么分组即可，并且显然考虑最小值比考虑次小值结果更好
*/
int n, h;
PII a[N];

void meibao() {
    cin >> n >> h;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].x;
        a[i].y = i;
    }
    sort(a + 1, a + n + 1);
    vector<int> group(n + 1, 1);
    int res = a[n - 1].x + a[n].x - a[1].x - a[2].x;
    int mx1 = max(a[n - 1].x + a[n].x, a[1].x + a[n].x + h);
    int mn1 = a[1].x + a[2].x + h;
    if (n >= 3) {
        mn1 = min(mn1, a[2].x + a[3].x);
    }
    if (res > mx1 - mn1) {
        res = mx1 - mn1;
        group[a[1].y] = 2;
    }
    cout << res << "\n";
    for (int i = 1; i <= n; i++) {
        cout << group[i] << " ";
    }
}          
