/*
k = 1 显然
k = 2 假如本来就是连通的，则一定是一个环，不可能满足题意
k = 3，左边 5 个点，右边 5 个点，操作一下
k = 4，无解
k >= 3 且为奇数时统一的构造方法：
- 左边 k + 2 个点，右边 k + 2 个点
- 左边 k + 1 个点的度为 k，1 个点的度为 k - 1，右边同理
- 然后连起来左右两边那两个度为 k - 1 的点
但是这样想了很久没想到咋表述
羊神提示：
我们考虑多用一些点，不只是 k + 2 个点
考虑桥断开之后的其中一个连通块，有一个点的度是 k - 1，剩下的点度数都是 k
先考虑从度为 k - 1 的点，向另外 k - 1 个点连边，则这个点的度就好了
之后对于刚才的那 k - 1 个点，需要各自再连 k - 1 条边
格局打开，再新建 k - 1 个点，让刚才的 k - 1 个点和现在新加的 k - 1 个点都连一遍
这样新增的 k - 1 个点，每个点的度数都还差 1
k - 1 是偶数，所以两两连就好了
*/

int k;

void meibao() {
    cin >> k;
    if (k == 1) {
        cout << "YES\n";
        cout << "2 1\n";
        cout << "1 2\n";
        return;
    }
    if (k % 2 == 0) {
        cout << "NO\n";
        return;
    }

    cout << "YES\n";
    cout << 4 * k - 2 << " " << k * (2 * k - 1) << "\n";

    for (int i = 2; i <= k; i++) {
        cout << "1 " << i << "\n";
    }
    for (int i = 2; i <= k; i++) {
        for (int j = k + 1; j <= 2 * k - 1; j++) {
            cout << i << " " << j << "\n";
        }
    }
    for (int i = k + 1; i <= 2 * k - 1; i += 2) {
        cout << i << " " << i + 1 << "\n";
    }

    int base = 2 * k - 1;
    for (int i = 2; i <= k; i++) {
        cout << 2 * k << " " << base + i << "\n";
    }
    for (int i = 2; i <= k; i++) {
        for (int j = k + 1; j <= 2 * k - 1; j++) {
            cout << base + i << " " << base + j << "\n";
        }
    }

    for (int i = k + 1; i <= 2 * k - 1; i += 2) {
        cout << base + i << " " << base + i + 1 << "\n";
    }
    cout << "1 " << 2 * k << "\n";
}      
