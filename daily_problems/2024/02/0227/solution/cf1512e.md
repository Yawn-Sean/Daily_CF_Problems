**提示 1：** $l$ 到 $r$ 之间可以出现 $1$ 到 $n$ 中任意两两不重复的组合。那么其和的应当在什么范围内？

**提示 2：** 范围内的所有数是否都能取到？怎么取到？（进一步——找到一个方式让和**连续地变化**）

首先， $l,r$ 的具体数值显然并不重要，我们只在乎这段子数组的长度 $r-l+1$.

那么这个子数组最小和是多少呢？就是 $1,2,3,...,r-l+1$ 的和，因为这就是最小的 $r-l+1$ 个数。你可以逐个相加得到，也可以使用等差数列公式得到其和，其和为 $\frac{(r-l)(r-l+1)}{2}$.

最大和也是类似的，最大的 $r-l+1$ 个数是 $n,n-1,...,n-(r-l)$，其和为 $\frac{(2n-r+l)(r-l+1)}{2}$.

如果我们的目标和 $s$ 不在这个范围内，显然无法构造。那如果 $s$ 在范围内，就一定可以构造出结果了吗？

答案是肯定的。我们尝试从 $1,2,3,...,r-l+1$ 这个序列起步，每次使得数组和增加 $1$，直到到达最后的 $n-(r-l),...,n-1,n$.

这个调整过程可以这么进行：找到子数组中最大的、且增加 $1$ 不会导致重复数字 / 数字大于 $n$ 的数，对其加 $1$. 这样我们就可以逐次增加实现答案的构造。直接实现的复杂度可能为 $\mathcal{O}(n^2)/\mathcal{O}(n^3)$.

而这里我们是可以跳步的——每个位置增加的数量在 $0$ 到 $n-(r-l)-1$ 之间，因为用前面的逻辑，大的数增加量一定不比小的数少，我们从大的数开始往小的数遍历，贪心地使得目前位置增加得尽可能多即可。这样时间复杂度可以控制在 $\mathcal{O}(n)$.

其余位置填入 $[1,n]$ 中的其他正整数即可。

总时间复杂度为 $\mathcal{O}(n)$.

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, l, r, s = MII()
    length = r - l + 1
    if length * (length + 1) // 2 > s or (n * 2 - length + 1) * length // 2 < s:
        print(-1)
        return
    
    used = [0] * (n + 1)
    
    s -= length * (length + 1) // 2
    res = list(range(1, length + 1))
    # 从后往前进行增加操作
    for i in range(length - 1, -1, -1):
        diff = min(s, n - length)
        s -= diff
        res[i] += diff
        used[res[i]] = 1
    
    ans = [-1] * n
    # 对子数组进行赋值
    ans[l-1:r] = res
    
    pt = 1
    for i in range(n):
        if ans[i] == -1:
            while used[pt]:
                pt += 1
            ans[i] = pt
            used[pt] = 1
    
    print(*ans)
    
    return
```
