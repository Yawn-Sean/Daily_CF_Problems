**提示 1：** 怎么缩小我们的搜索范围？

**提示 2：** 二分后，区间长度会怎么改变？最后的区间长度如何？

**提示 3：** 前面的步骤无法完全确定位置，但还多余了很多次查询机会，怎么办？注意运行轨迹是事先确定的。

我们先假设搜索对象是不改变位置的，那么这题就是最裸的一个二分查找习题。（不会这一步的同学可以去自学下二分！）

那么这题的不同点在哪里呢？也就是我们的搜索对象是可以每次改变位置的！这将如何改变我们搜索的区间长度呢？

假设原本的区间长度为 $l$ ，那么一次操作后，区间长度也就变成了 $\lceil\frac{l}{2}\rceil$，同时再加上新的移动，区间长度扩大 $2*k$，也就变成了 $\lceil\frac{l}{2}\rceil+2k$.

在 $l$ 比较大的情况下，这样的二分是很有效率的，但是在 $l$ 比较小的情况下，这样的二分很可能不能进一步缩小搜索区间。

但这里我们也只用了 $\lceil\log M\rceil$ 次查询次数，还有很大量的查询次数。

关键：**在区间足够小时，直接查询单点进行猜答案！**

由于搜索对象的行动是事先确定的，因此我们进行随机猜测也一定以 $\frac{1}{区间长度}$ 的概率成功。这样，在足够多次的查询后，总有一次我们运气不错，猜对答案。如果我们猜错了，我们可以在很短的时间内通过二分进行区间缩短。

**思考题：** 区间越短越好，因为这样我们更容易猜中；那区间最短能多短呢？

我们假设某个区间长度的情况下还能进行二分，且二分后得到的区间长度更短。因此可以列出不等式——

$$l>\lceil\frac{l}{2}\rceil+2k$$

发现 $l\geq 4k+2$，因此我们可以在区间不长于 $42$ 的时候进行猜测。

时间复杂度：开始二分的复杂度为 $\mathcal{O}(\log M)$，后面猜答案需要的期望猜测次数是 $\mathcal{O}(k)$，因此总复杂度（也是查询次数）期望为 $\mathcal{O}(\log M+k)$.

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    def query(left, right):
        print(left, right, flush=True)
        return True if I() == 'Yes' else False
    
    n, k = MII()
    l, r = 1, n
    while True:
        # 这里可以不取得那么极限（到 42），相对不大即可
        while r - l > 60:
            m = (l + r) // 2
            if query(l, m): r = m
            else: l = m
            l = max(l - k, 1)
            r = min(r + k, n)
        
        x = random.randint(l, r)
        if query(x, x): break
        l = max(l - k, 1)
        r = min(r + k, n)
    return
```
