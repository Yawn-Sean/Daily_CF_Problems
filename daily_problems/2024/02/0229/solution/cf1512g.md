**提示 1：** 假设 $d(n)=M$ ，你能否找出我们 $n$ 的范围？

**提示 2：** 对于一个确定的 $n$ ，你如何快速地计算 $d(n)$ ？

首先考虑上面提示的第一个问题。 $n\lt d(n)$ 一定成立，因为 $n$ 是它本身的因子。于是，由于我们要搜索的 $d(n)\leq 10^7$ ，因此我们的搜索空间满足 $n\lt 10^7$.

于是我们考虑预处理这 $10^7$ 个数的因子和，接下来在对应的 $d(n)$ 下记录可行的 $n$ 的最小值即可

而对于一个这样数据范围的数，我们如何快速得到其因子和呢？接下来介绍两种做法。

- 方法一：贡献法——考虑每个数是哪些其他数的因子（ Python 这样做会 TLE ）

具体而言，我们考虑每个数作为因子，对其他数的因子和的贡献。我们发现只有对其倍数，其能产生贡献，因此每个因子能作为 $\frac{M}{x}$ 个数的因子。因此，从小到大枚举每一个数，并更新其倍数的因子和，即可得到范围内每个数的因子和。

其时间复杂度为 $\frac{M}{1}+\frac{M}{2}+\dots+\frac{M}{M}=\mathcal{O}(M\log M)$ ，大约数量级为 $2\times 10^8$ ，部分语言可以通过。下面简单给出这种做法的 Python 实现。

```Python []
factor_sum = [0] * (10 ** 7)
for i in range(1, 10 ** 7):
    for j in range(i, 10 ** 7, i):
        factor_sum[j] += i
```

- 方法二：积性函数——重要的数论函数性质

大家可以查看 [这个链接](https://oi-wiki.org/math/number-theory/basic/#%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0) 了解相关数论知识。下面简单摘抄下积性函数定义——

若函数 $f(n)$ 满足 $f(1)=1$ 且 $\forall x,y\in\mathbf{N}^*,\gcd(x,y)=1$ 都有 $f(xy)=f(x)f(y)$ ，则 $f(n)$ 为积性函数。

也就是每个数的函数值可以表示为其两个互质因子的函数值的乘积。

而为什么因子和满足这一性质呢？我们考虑一个数 $x$ ，其可以分解为互质的两个数 $y,z$ 的乘积。那么，对于 $y,z$ 的两个因子 $d_y,d_z$ ，有 $d_yd_z$ 是 $x$ 的因子；同时 $x$ 的因子，根据质因子进行分组，也可以得到对应的 $d_y,d_z$ ，因此 $x$ 的因子与 $y,z$ 的因子对形成一一映射，于是两者数量相等，因子和满足积性函数性质。

于是，我们可以使用这一点简化计算。首先我们有如下初值：

$f(1)=1, f(p^n)=1+p+p^2+...+p^n$

对于其他数 $x$ ，我们只需要预处理得到 $x$ 的其中一个质因子 $p$ ，我们总能找到一个 $k$ 使得 $\mathrm{gcd}(\frac{x}{p^k},p^k)=1$ （ $k$ 实际上为 $x$ 质因数分解中 $p$ 的次数），这样我们就可以利用之前计算的结果得到答案了。

这样处理的时间复杂度为 $\mathcal{O}(M\log \log M)$ ，来源于筛法以及找到质因数分解的次数。次数平均意义上比 $\log M$ 小得多。

这一步处理完，我们只需要像前面说的一样，在对应 $d(n)$ 处记录即可。

#### 具体代码如下（只包含中间处理部分）——

```Python []
div = [1] * (10 ** 7 + 1)
for i in range(2, 10 ** 7 + 1):
    if div[i] == 1:
        div[i] = i
        for j in range(i * i, 10 ** 7 + 1, i):
            div[j] = i

phi = [1] * (10 ** 7 + 1)
for i in range(2, 10 ** 7 + 1):
    x = 0
    v = 1
    while i % v == 0:
        x += v
        v *= div[i]
    v //= div[i]
    phi[i] = phi[i // v] * x

ans = [-1] * (10 ** 7 + 1)
for i in range(1, 10 ** 7 + 1):
    if phi[i] <= 10 ** 7 and ans[phi[i]] == -1: ans[phi[i]] = i

def main():
    print(ans[II()])
    return 
```