**提示 1：** 考虑一棵树，其最大匹配如何计算？

**提示 2：** 最大匹配的数量和什么有关？

**提示 3：** 哪些子树形态是一致的？

我们接下来按照提示的顺序展开。

对于一棵普通的树，我们进行最大匹配，可以通过树形 DP 进行实现。之所以可以 DP，是考虑到如果有一个最深的节点还没有进行匹配，那么它“不用白不用”，使用它不仅可以形成匹配，同时对其上侧的匹配没有影响。

因此我们在 DP 的过程中需要记录的状态包括：一个子树中的最大匹配，以及这个子树的根节点是否被使用了。

而转移的过程是：**每个节点对应子树的最大匹配 = 其子节点对应子树的最大匹配 + (1 若其有空闲子节点，否则 0).**

但这题的特殊点在于，我们这棵树很大，我们没有办法通过构造这棵树再进行 DP，那这时候我们应该如何处理这个问题呢？

我们发现，一个树的形态不变的情况下，我们 DP 的结果显然也不会改变。而我们的 Trie 有一个非常重要的特点：其任何一个子树也是一个 Trie。而如果这里出现的 Trie 有许多形态一样的，我们就可以压缩我们的 DP 状态。

**重要发现：** 每个子树的根到其叶子的每一条路径，一定满足左括号的数量一定，右括号的数量一定。

**简单证明：** 每两条这样的路径都分别对应于一个括号字符串的后缀，且这两个括号字符串前缀相同，由于总的左括号数量和右括号数量是确定的，去掉前缀后也是确定的。

因此考虑用 $tree(left, right)$ 表示一棵子树，其对应于 $left$ 个左括号与 $right$ 个右括号的合法后缀形成的 Trie.

其左节点为 $tree(left-1, right)\ (left\geq 1)$，右节点为 $tree(left, right-1)\ (right\geq 1)$，那么我们就可以通过左右两棵子树的 DP 结果得到 $tree(left, right)$ 的匹配答案了，也就完成了这道题。

需要注意的是，我们这里的 Trie 需要是合法后缀，因此中间出现的所有 Trie 需要满足 $left\leq right$ ，否则后缀左括号更多，意味着前缀右括号更多，也就形成了不合法局面。

时间复杂度为 $\mathcal{O}(n^2)$ ，因为有 $\mathcal{O}(n^2)$ 棵不同的子树，转移复杂度为 $\mathcal{O}(1)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
mod = 10 ** 9 + 7

def main():
    n = II()
    # dp[i][j] 表示有 i 个左括号，j 个右括号的最大匹配
    # status[i][j] 表示根节点是否被选取
    # if i <= j: dp[i][j] = dp[i-1][j] + dp[i][j-1] * (i <= j - 1)
    # 如果两棵子树中有一个 status = 0，那么答案 + 1，status[i][j] = 1
    # 使用滚动数组实现
    dp = [0] * (n + 1)
    status = [0] * (n + 1)
    for i in range(n + 1):
        dp[i] = (i + 1) // 2
        status[i] = i % 2
    
    for i in range(1, n + 1):
        ndp = [0] * (n + 1)
        nstatus = [0] * (n + 1)
        for j in range(i, n + 1):
            ndp[j] = dp[j]
            if not status[j]:
                ndp[j] += 1
                nstatus[j] = 1
            if i < j:
                ndp[j] += ndp[j-1]
                if not nstatus[j] and not nstatus[j-1]:
                    ndp[j] += 1
                    nstatus[j] += 1
            ndp[i] %= mod
        dp = ndp
        status = nstatus
    
    print(dp[n])
    return 
```