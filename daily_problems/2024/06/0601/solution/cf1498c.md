**提示 1：** 一个粒子可以分裂成几个粒子跟哪些变量有关？

**提示 2：** 将提示 1 中的变量视为状态，考虑从一个状态的粒子下一次碰撞时，可以变成哪些其他的状态的粒子。

我们考虑提示 1 中的问题，一个粒子能分裂成几个粒子跟以下变量有关：

- Decay age，即题目中给出的 $D(x)$ 。

- 前面有多少块板子。

- 后面有多少块板子。这两个变量是因为粒子最后会产生穿过板子或者反弹的粒子，这两个粒子后续的情况跟其前面 / 后面的板子数量有关。

而事实上，前面和后面的板子数量之和是给定的，因此总共实际上是两个状态。

设前面有 $i$ 块板子，且 $D(x)=j$ 的粒子能产生 $dp[i][j]$ 个粒子，那么其经过一次穿过板子后，会变成两个粒子，分别为：

- 前面还有 $i-1$ 块板子，且 $D(x)=j$ 。

- 前面还有 $n-i$ 块板子，且 $D(x)=j-1$ 。

于是可得 $dp[i][j]=dp[i-1][j]+dp[n-i][j-1]$ 。因此我们只需按照 $j$ 从小到大， $i$ 从小到大的顺序进行递推即可。

边界情况是 $dp[0][0]=1$ ，其中 $j\neq 0$ 。这是显然的。

时间复杂度为 $\mathcal{O}(nk)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    def f(x, y):
        return x * (k + 1) + y

    mod = 10 ** 9 + 7
    t = II()
    outs = []

    for _ in range(t):
        n, k = MII()
        dp = [0] * ((n + 1) * (k + 1))
        
        for j in range(1, k + 1):
            dp[f(0, j)] = 1
            for i in range(1, n + 1):
                dp[f(i, j)] = (dp[f(i - 1, j)] + dp[f(n - i, j - 1)]) % mod
        
        outs.append(dp[f(n, k)])

    print('\n'.join(map(str, outs)))
```