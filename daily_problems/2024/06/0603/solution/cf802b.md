**提示 1：** 我们只需要考虑两种情况：考虑新的一个人需要的书，其可能在当前的集合中，也可能不在当前集合中。

**提示 2：** 如果那本书在集合中，则无需考虑。

**提示 3：** 如果那本书不在集合中，则需要删掉一本书。删哪本呢？删最不被需要的一本。

请仔细阅读上述提示，理解完成后本题的解答也就呼之欲出了。

首先，我们手里维护“最优”的若干本书，以应对后续的需求（这里没有给出“最优”的定义，后面会提到）。

接下来，如果新来了一个人，则有如下两种情况：

如果那个人要的书我们手头刚好有，那么我们无需进行任何操作。

那如果那个人要的书我们没有，我们就必须得买新书了。如果买新书前我们已经有 $k$ 本书了，我们就不得不丢掉其中的一本。

那么我们选择丢掉哪一本呢？应当丢掉的是后续最不被需要的那一本。而我们考虑手头的书，其下一次被借阅的时间从小到大分别为 $t_1,t_2,\dots,t_k$ ，则其中，最不被需要的是其中 $t_i$ 最大的，因此我们删去 $t_k$ 即可。

为什么这么选择呢？

称书不得不删除的时刻为发生了“冲突”。

从直觉上来看，越靠后的那种类别的书前面会经过更多别的书，而其前面出现的书可能会有更多的“冲突”情况发生，而在“冲突”处理的过程中，我们如果决定不保留该书，那么我们可以在更早的时刻丢掉它；否则，我们将保留该书直到其再次出现，那么中间丢掉书的操作受到的限制就更大了（因为不能选择该书），因此总操作次数直觉上更大，因此丢掉靠后的书。

这只是直觉上的理解。接下来给出正式证明的简要思路。

首先，我们假设目前我们拥有的元素下一次出现的位置构成数组 $pos$ ，我们对 $pos$ 进行排序，形成新数组 $sorted_pos$ 。上述贪心思路可以保证我们找到字典序最小的 $sorted_pos$ 。

而在字典序最小的 $sorted_pos$ 下，一定可以保证购买书本的总数量最小。首先，一个书本第一次出现一定对应于一次购买，这一数量无法改变。我们只需查看后续所有“节省”下来的购买次数，即对方要的书我们刚好有。对方要的书一定是在 $sorted_pos$ 中最小的元素，因此维持 $sorted_pos$ 的最小字典序即可。

在上述情况下，我们需要维护一个结构，删去的元素可能是下一次出现最晚的元素，而我们只需要保留某类图书的最后一次出现的位置，因此前一次出现的位置也应当删除。

这两类删除，一类是任意位置，一类是删去特定元素，因此可以使用 C++ 中的有序集合或任何语言的懒删除堆进行实现。

同时，我们也需要维护某个元素下一次出现的位置，这件事我们在预处理时逆向遍历数组即可完成。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, k = MII()
    ids = LGMI()

    next_pos = [n] * n
    pos = [n] * n

    for i in range(n - 1, -1, -1):
        next_pos[i] = pos[ids[i]]
        pos[ids[i]] = i

    hpq = []
    cnt = 0
    vis = [0] * n
    ans = 0

    for i in range(n):
        while hpq and vis[hpq[0] % n] == 0:
            heappop(hpq)
        
        if vis[ids[i]] == 0:
            if cnt == k:
                vis[heappop(hpq) % n] = 0
                cnt -= 1
            vis[ids[i]] = 1
            
            heappush(hpq, -next_pos[i] * n + ids[i])
            cnt += 1
            ans += 1
        
        heappush(hpq, -next_pos[i] * n + ids[i])

    print(ans)

```