**提示 1：** 尝试进行 $2$ 次操作，得到的字符串和原字符串有何差别？

**提示 2：** 偶数次操作对字符串的改变可以怎么理解？

**提示 3：** 奇数次操作可以理解为先进行一次操作，之后再做偶数次操作。

请先进行自己的尝试，尤其是查看两次操作后的可能结果。

---

尝试后可以发现，两次操作相当于把一个 $1$ 变成 $0$ ，把一个 $0$ 变成 $1$ ，即进行了一次交换操作。

而这样的交换 **不会改变字符串中出现 $0$ 和 $1$ 的频率** 。

于是，如果两个字符串中 $1$ 的数量不同，则无法通过偶数次操作把初始字符串变为最终的字符串；否则，两次操作恰好使得两个不匹配的位置匹配，因此 **总操作次数等于两个字符串不同的位置的个数** 。

那如果总操作次数为奇数次呢？

我们相当于做一次操作后，再进行偶数次操作。

而经过一次操作后，字符串 $s_1$ 中 $1$ 的个数也是固定的。设其原来有 $c_1$ 个 $1$ ，则被翻转的 $0$ 的个数为 $n-c_1$ ，于是 $1$ 的总数为 $n-c_1+1$ ，其需要与目标字符串 $1$ 的个数相等。

接下来的判断与之前一样，也需要找到翻转后两个字符串不同的位置的个数。

因此我们要最小化翻转后的不同的位置个数。

整体的操作相当于把全字符串全部翻转之后，再调整其中的一个位置，因此计算最小化问题时，只需要考虑调整的这一个位置。

可以考虑翻转的位置，其原来一定是 $1$ ，如果其目标也是 $1$ ，则对这个位置进行操作使得该位置得到了匹配，于是可以使得不同的位置个数相对更小。

因此查看有无对应的位置即可。

时间复杂度为 $\mathcal{O(n)}$ .

#### 具体代码如下（只包含中间处理部分）——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []

    for _ in range(t):
        n = II()
        s1 = I()
        s2 = I()

        ans = n + 5
        c1 = s1.count('1')
        c2 = s2.count('1')
        if c1 == c2:
            cnt = 0
            for i in range(n):
                if s1[i] != s2[i]:
                    cnt += 1
            ans = cnt
        if n - c1 + 1 == c2:
            cnt = 0
            f = False
            for i in range(n):
                if s1[i] == s2[i]:
                    cnt += 1
                    if s2[i] == '1':
                        f = True
            ans = min(ans, cnt + 2 - f * 2)
                        
        outs.append(ans if ans < n + 5 else -1)

    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n;
        string s1, s2;
        cin >> n >> s1 >> s2;

        int c1 = 0, c2 = 0;
        for (int i = 0; i < n; i ++)
            c1 += (s1[i] == '1'), c2 += (s2[i] == '1');
        
        int ans = n + 5;
        if (c1 == c2) {
            int res = 0;
            for (int i = 0; i < n; i ++)
                res += (s1[i] != s2[i]);
            ans = min(ans, res);
        }
        if (n - c1 + 1 == c2) {
            int res = 0, f = 0;
            for (int i = 0; i < n; i ++) {
                if (s1[i] == s2[i])
                    res += 1, f |= (s1[i] == '1');
            }
            ans = min(ans, res + 2 - f * 2);
        }
        cout << (ans < n + 5 ? ans : -1) << '\n';
    }

    return 0;
}
```