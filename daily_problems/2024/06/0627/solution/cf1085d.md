**提示 1：** 请仔细观察题目给的样例，你猜最后权重是怎么分配的？

**提示 2：** 尝试简单说明你的结论。

很简单的脑筋急转弯。

从题目给的样例可以发现，赋予非零权重的总是 **跟叶子节点相连的边** 。

这件事怎么证明呢？

对于任何一条经过两个叶子的路径，我们可以把其上权重加总，再平均分配给两个叶子，这样，总直径长度不会变大，理由如下——

- 考虑所有不经过当前路径端点的路径长度，其变小或不变。

- 接下来考虑经过其中一个端点的路径长度。我们设与第一个端点的路径长度为 $d_1$ ，与第二个端点的路径长度为 $d_2$ ，那么在调整前后 $d_1+d_2$ 不变，因此平均后，两条路径长度一样，最大值变小。

- 原路径长度不变。

于是，总能调整图至只有叶子节点连的边权非负。

而一条路径总可以经过其中任何两个叶子，我们相当于要求任何两个叶子连的边权的和最大值最小，因此直接平均分配即可。

设叶子节点连的边的总数为 $k$ ，则每条边权为 $\frac{s}{k}$ ，而直径最多包含两条这样的边，于是直径长度为 $\frac{s}{k}$ 。

特殊情况是树只有两个节点，但仍可以用类似上式进行处理。

时间复杂度为 $\mathcal{O}(n)$ .

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, s = MII()
    degs = [0] * n

    for _ in range(n - 1):
        u, v = GMI()
        degs[u] += 1
        degs[v] += 1

    print(2 * s / degs.count(1))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, s;
    cin >> n >> s;

    vector<int> degs(n);
    for (int i = 0; i < n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        degs[--u] ++, degs[--v] ++;
    }

    int cnt = 0;
    for (auto &x: degs) cnt += x == 1;

    cout << setprecision(12) << 2.0 * s / cnt;

    return 0;
}
```
