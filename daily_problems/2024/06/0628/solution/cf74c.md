**提示 1：** 板子中间非边缘的所有点都不重要，因为一定可以从边缘出发。

**提示 2：** 哪些边缘可以不用一起取？设计一个数据结构维护这件事。

首先，这个图形本身是 $10^6\times 10^6$ ，因此不能构建矩阵硬跑。

但是显然，非边缘的格子是无需考虑的，因为我们总能找到边缘的点使其能到达中间的格子。

于是，我们需要考虑的点集缩小到了 $10^6$ 量级。接下来，我们只需要确认哪些边缘的点是互相可达的即可。

为此我们只需要考虑每个点走两个斜线方向分别与什么点相撞即可，将相撞的点用并查集合并，最后统计连通块数量就完成了。

这种方法的复杂度为 $\mathcal{O}(n+m)$ ，若不考虑并查集的复杂度。

但这题也有数学解法。我们回忆之前平面镜的知识，反射的光路可以理解为从像发出来的光路。而我们现在有四个平面镜，因此可以确定对应的所有的像的位置，再分别作出两个方向的光，即可代表所有的可覆盖点。

发现平面镜的反射就类似于直线本身移动 $2\times(n-1)$ 或 $2\times(m-1)$ 或做了奇数次镜像。

前者可以保证距离为 $2\gcd(n-1, m-1)$ 的倍数的位置的直线均可以被构造，镜像使得 $2\gcd(n-1,m-1)-i$ 的位置也可达。

因此，总共需要 $0,1,\dots,\gcd(n-1, m-1)$ ，共计 $\gcd(n-1, m-1)+1$ ，求解复杂度为 $\mathcal{O}(\log \min(n, m))$ .

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    x, y = MII()
    print(math.gcd(x - 1, y - 1) + 1)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;
    cout << __gcd(n - 1, m - 1) + 1;

    return 0;
}
```
