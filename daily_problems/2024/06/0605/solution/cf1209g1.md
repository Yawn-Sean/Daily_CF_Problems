**提示 1：** 如果数组本身就是一块一块的，我们无需操作。不然的话一定有两个数会 “交织” 在一起。而这样的两个数最后会变成同一个数。

**提示 2：** 尝试找到所有存在 “交织” 关系的数字形成的区间。这个区间怎么操作答案最小？

如果某个数字出现的所有位置全部都连续，那么这个数字无需调整，直接忽略。

否则，某个数字内部存在其他数字，则我们称这两个数字 “交织” 。

“交织”的两个数字，最后一定会变成同一个数字。

因此，我们只需找到所有满足 “交织” 关系的数字对，这些数字对最后都会变成同一个数字。

“交织” 关系可以怎么理解呢？我们考虑每个数字出现的左端点和右端点，其形成了区间 $[l, r]$ ，则只要区间之间相交 / 包含，则这两个数字最后都得变成同一个数字。

而相交的区间，因为变成了新的同一个数，因此可理解为 **合并成了新区间** 。于是我们上述操作相当于 **区间合并，直到最后区间两两分离** 。

区间和并的最小成本如何呢？我们区间内的所有数变成了同一个数，因此最少的变化元素个数为，区间总长度减去区间中出现元素的最大频率。而变化的元素个数就是我们这题的成本。

因此我们区间合并时维护这件事即可。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, q = MII()
    nums = LII()

    pos = [n] * (2 * 10 ** 5 + 1)
    cnt = [0] * (2 * 10 ** 5 + 1)

    for i in range(n - 1, -1, -1):
        if pos[nums[i]] == n:
            pos[nums[i]] = i
        cnt[nums[i]] += 1

    ans = 0

    l = r = 0
    ma = 0

    for i in range(n):
        if r < i:
            ans += r - l + 1 - ma
            l = r = i
            ma = 0
        
        if pos[nums[i]] > r:
            r = pos[nums[i]]
        if cnt[nums[i]] > ma:
            ma = cnt[nums[i]]

    ans += r - l + 1 - ma

    print(ans)
```