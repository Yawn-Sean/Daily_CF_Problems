**提示 1：** 考虑两个相切的圆，其经过操作后仍然相切，那么其半径应当满足什么条件？

**提示 2：** 所有相切的圆都需要满足对应的条件，但同时，如果半径只发生很小幅度的微调，两个分离的圆可以始终保持分离。

**提示 3：** 从提示 2 看，我们只需要考虑所有相切的圆对。接下来，我们只需要考虑微调其中一个圆的半径使其变动 $Δr$ 后，整体半径和是否改变。

首先，如果两个圆开始外切，最后仍然保持外切，那么其满足关系 $r_1+r_2=d$ ，其中 $r_1,r_2$ 分别是两个圆的半径， $d$ 是圆心的距离。

因此，如果两个圆相切，那么 **其中一个圆半径变化 $Δr$ ，另一个圆半径变化 $-Δr$** 。

而如果这个 $Δr$ 是足够小的，那么不会使得两个相离的圆变成相切或相交。

我们理解下我们前面的分析结果：任意两个相切的圆，其中一个圆的半径的变化可以推知另一个圆的半径的变化；前后的相切关系在 $Δr$ 足够小的情况下保持一致。

因此，如果圆 $C_1$ 与 $C_2$ 相切， $C_2$ 与 $C_3$ 相切，……， $C_{k-1}$ 与 $C_k$ 相切，那么假设 $C_1$ 半径变化 $Δr$ ，我们可以依次推出 $C_2,C_3,\dots,C_k$ 半径的变化幅度。

因此，如果我们用图来描述， **将每个圆视为一个节点，则只要两个节点之间存在一条路径，则其中任何一个点的半径变化已知，则另一个点的半径变化已知** 。

于是，一个圆半径的变化可以推导出同一个连通块内的所有圆的半径的变化。

接下来变成了一个图问题。

在图中，相连的两个点对应的圆的半径变动应当互为相反数。

我们依次考虑每个连通块，看是否存在一个连通块半径和可以增加，如果存在，只需要保证其他连通块的半径和不变即可。

对于某个连通块，我们假设其中一个节点 $u$ 的半径变动 $Δr$ ，则剩余每个节点的变动情况都可以通过边的关系推出，即相邻两点的半径变动互为相反数。则可能包含以下情况：

- 某个点的变动既需要是 $Δr$ ，又需要是 $-Δr$ 。那么 $Δr=-Δr$ ，$Δr=0$ ，因此这个连通块不可变。

- 否则， $Δr$ 可以不为 $0$ ，我们只需要统计连通块内 $Δr$ 和 $-Δr$ 的个数，只要两者不相同，我们可以使得 $Δr$ 为绝对值很小的正数 / 负数，可以使得整体半径和增加。

事实上，上述过程相当于一个二染色问题。

时间复杂度为 $\mathcal{O}(n+m)$ ， $n$ 为圆的个数， $m$ 为相切的圆的对数，显然小于 $n^2$ ，因此可以毫无疑问地通过。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    xs = []
    ys = []
    rs = []

    for _ in range(n):
        x, y, r = MII()
        xs.append(x)
        ys.append(y)
        rs.append(r)

    path = [[] for _ in range(n)]
    for i in range(n):
        for j in range(i):
            dx = xs[i] - xs[j]
            dy = ys[i] - ys[j]
            totr = rs[i] + rs[j]
            if dx * dx + dy * dy == totr * totr:
                path[i].append(j)
                path[j].append(i)

    col = [-1] * n
    flg = False

    for i in range(n):
        if col[i] == -1:
            f = True
            col[i] = 0
            c0, c1 = 1, 0
            stack = [i]
            while stack:
                u = stack.pop()
                for v in path[u]:
                    if col[v] == -1:
                        col[v] = col[u] ^ 1
                        if col[v]: c1 += 1
                        else: c0 += 1
                        stack.append(v)
                    elif col[v] ^ col[u] != 1:
                        f = False
            if f and c0 != c1:
                flg = True
                break

    print('YES' if flg else 'NO')
```