**提示 1：** 我们可以分别考虑每一位结果为 $0 / 1$ 的方案分别有多少种。

**提示 2：** 考虑设计状态，使其包含某一位到前 $i$ 项时的计算结果是 $1$ 还是 $0$ ，并可以计算到前 $i+1$ 项时的计算结果是 $0$ 还是 $1$ 。

我们每一位可以分别考虑，分别考虑每一位构成的 $01$ 的序列的方案数，最后进行相乘即可（因为位运算对于每一位独立）。

接下来就设计 DP 计算每一位有多少种方案。

DP 关键在于设计状态。

我们需要考虑第 $i$ 项时，`(a1 AND a2) OR (a2 AND a3) OR ... OR (a(i-1) AND ai)` 在当前位的计算结果，并推出新的包含第 $i+1$ 项的计算结果。

因此我们设计的状态包含以下两个方面：

- 当前的计算结果。

- 当前数组的最后一项。这件事是为了我们得到最后的 `ai AND a(i+1)` 以更新新的计算结果。

因此总状态数量为 $4$ 个，且从第 $i$ 项到第 $i+1$ 项发生的递推为线性递推，我们可以枚举新的一位为 $0$ 还是 $1$ 得到状态的转移方程。

而有了线性递推关系，要求第 $n$ 层的结果，可以使用矩阵快速幂，这里是 [相关链接](https://oi-wiki.org/math/linear-algebra/matrix/) 里面的矩阵加速递推部分，最后对每一位的结果相乘即可。

时间复杂度为 $\mathcal{O}(M^3\log n+l)$ ，其中 $M=4$ ，来源于矩阵快速幂和后面的乘法原理。

这题也可以不用这么多状态，可以直接计算某一位结果为 $0$ 的方案数。

我们可以列出 DP 关系： $dp_i=dp_{i-1}+dp_{i-2}$ 。

即如果当前新考虑的元素是 $0$ ，则前面的元素无所谓，有 $dp_{i-1}$ 种方案；否则，前一项必须是 $0$ ，再前面的元素就无所谓了，有 $dp_{i-2}$ 种方案。

这种线性递推关系也可以通过矩阵快速幂快速算出第 $n$ 项数值，但整体复杂度优化不大。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, k, l, mod = MII()

    if k >= 1 << l:
        print(0)
    else:
        # 最后一项是 i 且当前或和是 j
        grid = [[0] * 4 for _ in range(4)]
        for i in range(2):
            for j in range(2):
                msk = i * 2 + j
                for ni in range(2):
                    nj = j | (ni & i)
                    nmsk = ni * 2 + nj
                    grid[msk][nmsk] += 1
        
        grid_n = matrix_pow(grid, n, mod)
        dp = [[0] * 4]
        dp[0][0] = 1
        dp = matrix_mul(dp, grid_n, mod)
        
        c0 = (dp[0][0] + dp[0][2]) % mod
        c1 = (dp[0][1] + dp[0][3]) % mod
        
        ans = 1 % mod
        for i in range(l):
            if k >> i & 1: ans = ans * c1 % mod
            else: ans = ans * c0 % mod
        
        print(ans)
```