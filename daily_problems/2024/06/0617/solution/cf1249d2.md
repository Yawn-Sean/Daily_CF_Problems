**提示 1：** 先考虑不删除任何区间的情况下，那些被覆盖的次数超过 $k$ 次的点。从左到右依次考虑它们，最左侧的点要满足条件，“最好”删去哪些区间？

**提示 2：** 如何维护一个结构，使其能够快速找到要删去的区间？

一个贪心问题。

由于我们要删去区间使得结果满足条件，即使得每个点被覆盖的次数都变成不超过 $k$ 次的，因此我们实际上要做的就是使得当前覆盖次数超过 $k$ 次的点覆盖次数减少。

这些点考虑的顺序是任意的，但为了方便，我们应该从左到右或者从右到左依次考虑它们。

如果我们要使得最左侧的点被覆盖次数小于 $k$ ，我们应该找到目前覆盖了它的所有区间。我们删去哪些呢？**我们应该删去这些区间中右端点最大的几个，因为这么删可以使得右侧的点也更多地吃到红利，减小被覆盖的次数** 。

于是，我们需要维护的事情是覆盖某个点的所有区间，支持的操作还包括删去右端点最大的区间。

前面这件事可以想到扫描线：一个区间在 $l$ 时加入考虑，在 $r+1$ 时退出考虑（即只有在 $[l,r]$ 的位置，这个区间在数据结构中得到维护）。而后面删去最大的事情可以用堆实现。

整体是添加、任意删去和删去最大三种操作，因此可以使用懒删除堆 / 有序集合完成。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

Python 做法如下——

```Python []
def main():
    n, k = MII()

    rs = []
    segs_l = [[] for _ in range(2 * 10 ** 5 + 2)]
    segs_r = [[] for _ in range(2 * 10 ** 5 + 2)]

    for i in range(n):
        l, r = MII()
        rs.append(r)
        segs_l[l].append(i)
        segs_r[r+1].append(i)

    msk = 2 * 10 ** 5 + 5

    hpq = []
    cur_used = [0] * n
    cur_size = 0

    ans = []

    for i in range(2 * 10 ** 5 + 1):
        for idx in segs_l[i]:
            cur_used[idx] = 1
            cur_size += 1
            heappush(hpq, -rs[idx] * msk + idx)
        
        for idx in segs_r[i]:
            cur_size -= cur_used[idx]
            cur_used[idx] = 0
        
        while cur_size > k:
            idx = heappop(hpq) % msk
            if cur_used[idx]:
                cur_size -= 1
                cur_used[idx] = 0
                ans.append(idx)

    print(len(ans))
    print(' '.join(str(x + 1) for x in ans))
```

C++ 做法如下——

```cpp []
TBD
```
