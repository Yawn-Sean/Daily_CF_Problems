**提示 1：** 操作看似很复杂，请先理解操作是在干什么。

**提示 2：** 我们最终的目标是一个单位矩阵，而要最小化的是把 $0$ 变 $1$ ， $1$ 变 $0$ 的次数。为此应该让对角线上出现的 $1$ 尽可能多，其他位置 $1$ 尽可能少。

**提示 3：** 一开始的四种操作相当于移动，而矩阵的移动与对角线是相对的。

一个简单贪心题。

首先，四种操作相当于矩阵向上 / 下 / 左 / 右移动了一个格子，出去的一行 / 一列重新填补到另一端。

而我们的目标是使得到单位阵的成本最低，即，使得改变数值的位置最小，因此要对角线上的 $1$ 尽可能多，其他位置的 $1$ 尽可能少。

这两件事是一致的，因为 $1$ 的总数固定。

因此我们只需使得对角线上 $1$ 出现个数最多。

一整个矩阵的移动相对更难考虑。但是我们可以考虑运动的相对性，即原来是矩阵关于对角线发生移动，我们想成对角线关于矩阵发生移动。

于是我们发现对角线的所有可能位置只可能是沿着主对角线方向的若干元素的和，类似如下：

1 2 3
3 1 2
2 3 1

于是，枚举这 $n$ 种情况即可。

如果对角线上有 $k$ 个 $1$ ，而 $1$ 的总数是 $cnt$ ，则总成本为 $(cnt-k)+(n-k)=cnt+n-2k$ ，我们对其求值即可。

时间复杂度为 $\mathcal{O}(n^2)$ .

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    I()
    n = II()
    cnt = [0] * n
    for i in range(n):
        s = I()
        for j in range(n):
            if s[j] == '1':
                cnt[(i - j) % n] += 1
    return sum(cnt) + n - max(cnt) * 2
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;
    while (t --) {
        int n;
        cin >> n;

        vector<int> cnt(n);
        int ans = n;

        for (int i = 0; i < n; i ++) {
            string s;
            cin >> s;
            for (int j = 0; j < n; j ++)
                if (s[j] - '0')
                    cnt[(i + n - j) % n] ++, ans ++;
        }
        cout << ans - *max_element(cnt.begin(), cnt.end()) * 2 << '\n';
    }

    return 0;
}
```
