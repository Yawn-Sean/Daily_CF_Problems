**提示 1：** 假设目前已经有了一个选取人的集合，你如何判断一个新的人是否应该纳入这个集合中？算出其对概率的边际贡献（就是有他没他的差别）。

**提示 2：** 根据上述判断，就可以猜测出一个贪心。请试图证明它。

首先，假设我们目前选择了一批人，其做出题目的概率为 $p_1, p_2, \dots, p_k$ ，设其恰有一个人做对的概率是 $P_1$ ，而无人做对的概率是 $P_0$ ，那么此时新来了一个人，其概率为 $x$ ，则新的恰有一人做对的概率是：

$xP_0+(1-x)P_1$ 

于是，其带来的概率增量是：

$xP_0+(1-x)P_1-P_1=x(P_0-P_1)$ 

因此，如果 $P_0\lt P_1$ ，无论如何不应该加入新的人；否则，加入的人概率越大，对于整体概率的提升程度越高，因此可以猜测是按照概率从高到低的排序加入我们的集合中。（不是严谨证明，因为加入顺序影响上述概率增量）

接下来尝试证明这件事。那么我们就研究最优解的性质就行。不妨找到最少的人数构成的最优解。

假设最优解是 $k$ 个人，而其中有一个人 $i$ 不是最大的 $k$ 个概率之一，而作为前 $k$ 大概率的 $j$ 却没有被选中。

那么我们考虑其它的 $k-1$ 个人。此时，如果这 $k-1$ 个人满足 $P_0\lt P_1$ ，那么无论新增 $i,j$ 中的哪一个人，最后答案都会变小，因此 $k-1$ 个人的解是更优的，这与我们当前的解是 “最少的人数构成的最优解” 矛盾。

于是，可以认为 $P_0\geq P_1$ ，在这种情况下，新加入的人概率越大越好，于是，应当选择 $j$ 而非 $i$ ，即这 $k-1$ 个人搭配 $j$ 是更好的答案。与当前解的最优性矛盾。

综上所述，解一定取的是最大的几个概率构成的集合。我们枚举集合大小即可。

时间复杂度为 $\mathcal{O}(n\log n)$ ，来源于关于概率排序。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    probs = LFI()
    probs.sort(reverse=True)

    p0, p1 = 1, 0
    ans = 0

    for p in probs:
        p1 = p1 * (1 - p) + p0 * p
        p0 *= 1 - p
        ans = max(ans, p1)

    print(ans)
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<double> probs(n);
    for (auto &prob: probs) cin >> prob;
    
    sort(probs.begin(), probs.end(), [&](double x, double y) {return x > y;});

    double p0 = 1, p1 = 0, ans = 0;

    for (auto &prob: probs)
        p1 = p1 * (1 - prob) + p0 * prob, p0 *= 1 - prob, ans = max(ans, p1);

    cout << setprecision(15) << ans;

    return 0;
}
```
