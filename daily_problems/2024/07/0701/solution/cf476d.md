**提示 1：** 先对所有数字进行除以 $k$ 处理，接下来要求组内的数两两互质。

**提示 2：** 由于两两互质，不能有 $2$ 个偶数，于是可以给出答案的下界，再给出对应构造即可。

简单构造题。

首先，每个数都是 $k$ 的倍数，因此先对每个数除以 $k$ 再进行处理，这样每组组内两两互质。

于是，每组中至多只有一个偶数，至少有 $3$ 个奇数。

于是所有组中，最大的奇数至少是第 $3n$ 个奇数，为 $6n-1$ ，接下来构造即可。

我们顺序把奇数进行分组，变为：

$1,3,5$

$7,9,11$

$13,15,17$

$\dots$

这样，同组的奇数之间一定是两两互质的，因为其两两之差只能为 $2$ 或 $4$ ，这两数与奇数的最大公约数一定为 $1$ .

接下来只需给每一组配一个偶数即可，发现直接分别配 $2,8,14$ 等即可，比每组中最小的奇数大 $1$ 。

因为这样，其两侧的相邻奇数与其互质，而每组中最大的奇数不是 $3$ 的倍数，而与偶数的差是 $3$ ，因此也互质。

这种情况下，每一组分别为 $6i+1,6i+2,6i+3,6i+5$ 。最后再乘以 $k$ 即可。

时间复杂度为 $\mathcal{O}(n)$ .

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()

    outs = []
    outs.append(str(k * (n * 6 - 1)))

    for i in range(n):
        outs.append(f'{(6 * i + 1) * k} {(6 * i + 2) * k} {(6 * i + 3) * k} {(6 * i + 5) * k}')

    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    vector<int> tmp = {1, 2, 3, 5};

    cout << k * (6 * n - 1) << '\n';
    for (int i = 0; i < n; i ++) {
        for (auto &x: tmp) cout << (6 * i + x) * k << ' ';
        cout << '\n';
    }

    return 0;
}
```