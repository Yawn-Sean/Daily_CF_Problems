**提示 1：** 我们要让字典序最小，但是前面一堆 $1$ ，因此要使得第一个非 $1$ 的数字出现得最早。

**提示 2：** 仔细想下，第一个非 $1$ 的数字出现是什么意思。

**提示 3：** 第一个非 $1$ 数字构造完了，之后怎么办？

一道小巧的构造题。

首先，我们要先找第一个非 $1$ 的数字，让其出现的地方尽可能早。

这件事怎么办到呢？这就要求我们 **删去最少的数字，使得剩下的数字不再互质**。 即 **剩下的数尽可能多，且都是某个非 $1$ 正整数 $x$ 的倍数** 。

对于大于等于 $4$ 的数而言，一定是 $2$ 的倍数最多，因为个数等于 $\lfloor\frac{n}{x}\rfloor$ ， $x$ 越小，倍数越多。对于小于 $4$ 的情况，题中已经给出构造了。

那么，接下来怎么办呢？剩下的数都是 $2$ 的倍数，因此，**将所有数同时除以 $2$ ，可以得到一个新的 $1,2,\dots,\lfloor\frac{n}{2}\rfloor$** ，这是一个跟我们此前问题形式完全一致的问题，因此可以递归解决。

时间复杂度如何呢？设 $n$ 规模的复杂度为 $T(n)$ ，则 $T(n)=n/2+T(n/2)$ （前一段的 $1$ 共有 $n/2$ 个，加上后一段的构造），因此总复杂度是 $\mathcal{O}(n)$ 即线性的。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()

    def f(n):
        if n <= 3:
            return [1] * (n - 1) + [n]
        return [1] * (n - n // 2) + [x * 2 for x in f(n // 2)]

    print(' '.join(map(str, f(n))))
```

C++ 做法如下——

```cpp []
signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    function<void(int, int)> answer = [&] (int n, int x) {
        if (n <= 3) {
            for (int i = 0; i < n - 1; i ++)
                cout << x << ' ';
            cout << n * x << ' ';
            return;
        }
        for (int i = 0; i < n - n / 2; i ++)
            cout << x << ' ';
        answer(n / 2, x * 2);
    };
    answer(n, 1);

    return 0;
}
```
