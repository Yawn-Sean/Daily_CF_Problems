**提示 1：** 如果我们进行了 $x$ 操作，相当于我们可以将每一个数增加 $0,...,x$ 中的任何数再取模。

**提示 2：** 根据提示 1，如果操作次数确定，我们每个数能变动的范围是一个区间。相当于判断区间中的数能否形成一个非递减序列。这件事怎么做？（贪心）

**提示 3：** 根据提示 2，每一个操作次数我们都能判断非递减序列的可行性。同时操作次数更多的情况下更容易达成目标，因此可以使用二分。

请仔细阅读上述提示。下面是具体做法的解释，不太算是思考的逻辑。

考虑使用二分，因为我们如果进行 $k$ 次操作可以达成要求，我们一定可以进行 $k+1$ 或更多的次数达成要求（后续操作可以选择 $0$ 个下标进行改变）。

在满足上述性质——即若一个整数 $k$ 满足条件，则比其大的整数都满足条件——的情况下，便满足了二段性，可以使用二分。

而使用二分，我们需要考虑对于某个操作次数 $k$ 能否构造一个非递减序列。

考虑每个数，在经过 $k$ 次操作后可以变为 $x,x+1,\dots,x+k$ 关于 $m$ 取模的所有数，要得到 $x+i\bmod m$ 只需在 $k$ 次操作中挑选 $i$ 次对该下标进行操作即可。

接下来怎么判断可行性呢？

我们假设到 $i$ 下标时，得到的最小的能使得前缀单调不减的数字为 $x$ ，则接下来考虑下标 $i+1$ ：

- 如果该数比 $x$ 小，那么我们最好的做法是尽可能把它刚好凑成 $x$ ，如果次数不够就不可行。

- 如果该数比 $x$ 大，那么我们有两种策略：

    - 不改变该数。

    - 增加该数，直到其又从 $0$ 开始增大到 $x$ 。这样可以使得 $i+1$ 位置达到 $x$ ，比原数小。如果这么做，需要操作次数足够，设原数字为 $y$ ，则操作次数至少为 $m-y+x$ 次让其变为 $x$ ，否则只能维持原样。

根据上述讨论，我们可以贪心得到 $i+1$ 位置能得到的最小的数。如果上述操作可以不断进行，则对应 $k$ 可行，否则 $k$ 不可行。

那么二分上界如何选取呢？事实上，二分上界为 $m-1$ ，因为 $m-1$ 次操作足以使任何数变成其他任何数。

于是，通过二分，本题的复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, m = MII()
    nums = LII()

    l, r = 0, m - 1
    while l <= r:
        mid = (l + r) // 2
        
        last_val = 0
        f = True
        for num in nums:
            if num < last_val:
                if mid < last_val - num:
                    f = False
                    break
            else:
                if num + mid >= m and num + mid - m >= last_val:
                    continue
                last_val = num
        
        if f: r = mid - 1
        else: l = mid + 1

    print(l)
```