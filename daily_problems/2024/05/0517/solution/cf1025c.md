**提示 1：** 想想题中给出的操作究竟干了什么事。注意，你只关系所有相邻位置。

**提示 2：** 其实相当于把字符串拆成两部分，再用另一端接起来。

这是一个典型的脑筋急转弯。

我们做的操作是这样：

把 $s$ 拆成 $s_1$ 和 $s_2$ ，再得到 $rev(s_1)+rev(s_2)$ ，其中 $rev$ 表示反转字符串， $+$ 表示字符串拼接。

事实上，我们只在乎所有的相邻位置。我们发现 $s_1$ 内部的相邻字符不改变， $s_2$ 内部的相邻字符也不改变。

于是，我们发现我们的操作相当于只是 **切断了一个位置的相邻字符，再把首尾位置的字符变成相邻的** 。

而这件事可以从另一个视角来看进行更简单的刻画。

我们把字符串直接首尾相连，形成一个环。

每次操作相当于当前的字符串首尾连起来，变成一个环；再把环进行一个翻转，再剪一刀。（可以想成一条手链之类的东西）

因为翻转并不影响这题的计算，因此我们只需考虑哪个位置切即可。即找到这个 “环形字符串” 的最长交替子串（不比原字符串长度长）。

这件事很容易实现。这个最长交替字串一定出现在 $s+s$ 中，我们找到 $s+s$ 的最长交替子串即可。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    s = I()
    n = len(s)
    s = s + s

    ans = 0
    cnt = 1
    for i in range(2 * n - 1):
        if s[i] != s[i+1]: cnt += 1
        else: cnt = 1
        ans = max(ans, cnt)

    print(min(ans, n))
```