**提示 1：** 对于每一个子序列，我们要求的序列有多少种？

**提示 2：** 这题要求单调不减子序列，有个经典问题是最长递增子序列（LIS），这题相当于换了个目标，因此可以使用相同的状态定义。回忆一下 LIS 的状态定义如何，想想这里应该如何转移。

**提示 3：** 如何保证你找到的子序列是两两不同的？

如果有一个子序列为 $x_1,x_2,\dots,x_k$ ，那么满足条件 $y_1\leq x_1, y_2\leq x_2,\dots, y_k\leq x_k$ 的序列数量可以用乘法原理计算： $y_1$ 有 $x_1$ 种可能， $y_2$ 有 $x_2$ 种可能，…… $y_k$ 有 $x_k$ 种可能。因此总数量等于 $x_1\times x_2\times\dots\times x_k=\prod\limits_{i=1}^k x_i$ .

于是我们对所有不同的子序列计算对应数值的和即可。

本题要求和的对象是单调不减的子序列，而关于这个问题，我们可以回忆下经典问题：单调递增子序列的最大长度。这两个问题有很强的相似性，因为都考虑的全集都是递增 / 非递减的子序列。

因此考虑使用 DP 并用类似的状态定义。我们假设到 $i$ 位置的前缀中，以 $v$ 为最后一项构成的子序列，数值和为 $dp[i][v]$ .

则新考虑 $i+1$ 位置，如果 $v\neq nums[i+1]$ ，那么这个序列必然不包含第 $i+1$ 个元素，直接用 $dp[i+1][v]=dp[i][v]$ 转移即可。

否则，如果 $v=nums[i+1]$ ，则首先 $dp[i][nums[i+1]]$ 仍可以转移到 $dp[i+1][nums[i+1]]$ ，同时，新增选取第 $i+1$ 个元素的子序列的数值。

选取第 $i+1$ 个元素，要求前一个被选的元素不超过 $nums[i+1]$ ，同时数组新增一个元素 $nums[i+1]$ ，数组的数值乘以 $nums[i+1]$ ，因此应当将 $nums[i+1]\times\sum\limits_{v=0}^{nums[i+1]} dp[i][v]$ 转移至 $dp[i+1][nums[i+1]]$ 。

但这样没有考虑到需要计算的子序列应当两两不同，我们多算了哪些子序列呢？

多算的子序列一定是以 $nums[i+1]$ 结尾的，同时之前出现过的子序列。即我们要考虑 $i$ 及之前出现的以 $nums[i+1]$ 结尾的子序列是否被重复计算了。

而事实上这些子序列都被重复计算了，因为这些子序列都可以把最后一项换为第 $i+1$ 项，因此也都出现在选取第 $i+1$ 个元素的子序列中。因此，被重复计算的数值和恰好是 $dp[i][nums[i+1]]$ 。

于是 $dp[i+1][nums[i+1]]=dp[i][nums[i+1]]+nums[i+1]\times\sum\limits_{v=0}^{nums[i+1]}dp[i][v]-dp[i][nums[i+1]]=nums[i+1]\times\sum\limits_{v=0}^{nums[i+1]}dp[i][v]$ 。

关于上面的 DP 的实现，首先，上面的转移对于每一个 $i$ 只转移了一个数字，因此无需使用矩阵，只需要一个一维数组更新一个位置即可。

同时，上面的转移方程还需要求一个前缀和，因此我们只需使用一个能快速得到前缀和并对某个位置进行加法操作的工具，树状数组显然就满足要求了。

时间复杂度为 $\mathcal{O}(M+n\log M)$ ，可以离散化预处理，但仍是不必要的。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    mod = 10 ** 9 + 7

    n = II()
    nums = LII()

    fen = FenwickTree(10 ** 6 + 1)
    # dp 数组记录当前的 dp 结果
    # 实质上等于树状数组 fen 对 [i,i] 区间的查询结果
    # 但直接取一个数组可以 O(1) 得到当前位置的值
    dp = [0] * (10 ** 6 + 1)

    fen.add(0, 1)

    for num in nums:
        v = (fen.sum(num) * num - dp[num]) % mod
        dp[num] += v
        dp[num] %= mod
        fen.add(num, v)

    # 也可以用 dp.sum(10 ** 6)
    print(sum(dp) % mod)
```