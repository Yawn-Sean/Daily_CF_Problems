**提示 1：** 我们显然不在乎前缀的数值，我们只在乎前缀中每个数字出现的频率。

**提示 2：** 在频率满足什么条件的情况下，删去一个元素可以使得剩余元素出现的频率完全一致？请先考虑删去的元素是什么。

首先，因为我们只在乎前缀中每个元素出现的频率，因此我们用一个数据结构计算每个元素出现的个数（频数），并用另一个数据结构记录各个频数出现的次数。

这样，考虑从 $i$ 位置的前缀到 $i+1$ 位置的前缀，相当于新增一个元素，只有该元素的频数 $x$ 改变了，且频数中只有 $x$ 和 $x+1$ 的出现次数改变了，因此可以快速维护。

接下来我们考虑题目：删去前缀中的一个元素，使得剩下的元素出现频率都一致。

这相当于对某个频数进行 $-1$ ，使得所有频数都相等。

此时有哪些可能呢？

- **删去的元素频数为 $1$**：此时，剩下所有元素出现频数应当均为最大频数。

    - 此时最大频数可能是 $1$ 或其他数值。

    - 如果是 $1$ ，则最大频数为 $1$ ，这种情况显然满足条件。

    - 如果是其他数值，则要求该频数乘以频数出现的次数等于选取前缀的长度 $-1$ .

- **删去的元素为最大频数 $x$**：

    - 此时不妨认为删取元素的出现频数不为 $1$ （如果是 $1$ 则前面讨论过了）。

    - 于是，删去该元素后，该元素的频数变为 $x-1$ ，因此剩余的所有元素频数均为 $x-1$ .

    - 因此考虑操作后 $x-1$ 出现的次数等于原出现次数 $+1$ ，该出现次数乘以 $x-1$ 应等于选取前缀的长度 $-1$ .

根据上述各情况讨论即可，时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LII()

    cnt = [0] * (10 ** 5 + 1)
    freq_cnt = [0] * (n + 1)
    freq_cnt[0] = n

    ans = 0
    max_freq = 0

    for i, v in enumerate(nums, 1):
        freq_cnt[cnt[v]] -= 1
        cnt[v] += 1
        freq_cnt[cnt[v]] += 1

        max_freq = max(max_freq, cnt[v])
        
        if max_freq == 1 or \
            max_freq * freq_cnt[max_freq] == i - 1 or \
            (max_freq - 1) * (freq_cnt[max_freq - 1] + 1) == i - 1:
            ans = i

    print(ans)
```