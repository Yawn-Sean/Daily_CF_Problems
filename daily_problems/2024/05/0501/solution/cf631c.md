**提示 1：** 如果一个前缀 $l_1$ 经过了操作，而其后又进行了一次前缀 $l_2$ 的操作， $l_2\geq l_1$ ，那么我们还有必要考虑第一次操作吗？

**提示 2：** 使用提示 1 的逻辑，维护一个需要考虑的操作集合。

**提示 3：** 如何执行新的操作集合？先将所有需要操作的数字进行排序。

首先，如果一个操作的前缀被后面操作的前缀覆盖了，那么前一次操作是毫无意义的。因为在后一个操作的时候会把前面的这些数全部重新排序。

于是，我们遍历所需要进行的操作，维护一个 **栈** ，如果上一次进行有效操作的区间比当前操作的区间短，那么前一次操作就变得无效，从栈中弹出即可。

因此，我们最后得到了一系列的操作序列，该序列满足前一次的操作的区间长于后一次操作的区间。接下来只需要执行对应的操作即可。

我们先将所有需要经过操作的数取出来排好序。

接下来，考虑进行的每一次操作确定了什么。

如果相邻的两次操作，先操作了操作了长度为 $l_1$ 的前缀，再操作了长度为 $l_2$ 的前缀，那么对于数组而言 $l_2+1,\dots,l_1$ 位置的数字后面都不会进行操作了（因为后续操作的前缀长度小于 $l_2$），这些位置可以得到确定。

同时，这些位置的数值一定是升序 / 降序排列的最后几个元素，这些位置的具体数值可以通过前面排序的数组进行填入。

剩下所有的数都可以通过考虑相邻两次操作之间相差的位置得到。整体可以使用双指针实现。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, q = MII()
    nums = LII()

    stack = []
    for _ in range(q):
        t, r = GMI()
        
        while stack and stack[-1][1] <= r:
            stack.pop()
        stack.append((t, r))

    vals = sorted(nums[:stack[0][1]+1])
    p0, p1 = 0, len(vals) - 1

    stack.append((0, -1))
    for i in range(len(stack) - 1):
        for j in range(stack[i][1], stack[i+1][1], -1):
            if stack[i][0]:
                nums[j] = vals[p0]
                p0 += 1
            else:
                nums[j] = vals[p1]
                p1 -= 1

    print(' '.join(map(str, nums)))
```
