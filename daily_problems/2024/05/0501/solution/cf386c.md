**提示 1：** 考虑某个位置 $i$ 结束的所有子字符串，其有多少种可能的不同字符数量呢？

**提示 2：** 对于某个位置 $i$ 结束的所有子字符串而言，不同字符数量只取决于其起始位置 $j$，且起始位置越靠前，不同字符数量单调不减。

**提示 3：** 什么情况下，往前移动 $j$ 会使得不同字符数量增大？有哪些这样的 $j$ ?

我们考虑某个位置 $i$ 结束的所有子字符串，不断移动其起始位置，看其不同字符数量。

我们考虑起始位置从 $i$ 到 $0$ 的移动，由于字符串是不断新增字符的，因此不同字符数量是单调不减的。

而什么情况下，不同字符数量会增大呢？**出现一个还没有出现过的字符的时候** 。

这就相当于，从后往前，找某个字符 **上一次出现的位置** 。这件事是可以 $\mathcal{O}(1)$ 维护的，只需遍历新字符的时候更新新字符的出现位置即可。

于是我们得到了所有会增大不同字符数量的位置。

而在相邻的两个位置之间，设构成了一个区间，则以区间内的位置作为起点的子字符串，对应的不同字符数量是一致的，因此可以维护一个 **有序数组，记录字符上一次的位置** 。其不同字符数量可以根据在有序数组中的位置得到确定。

而由于总共只有 $|Σ|=26$ 个字符，因此该有序数组很短。我们这里需要对有序数组进行修改和遍历（以得到每一段区间对于最后计数的影响），因此可以使用最朴素的实现直接进行删除和插入，达到 $\mathcal{O}(|Σ|)$ 的时间复杂度。

时间复杂度为 $\mathcal{O}(n|Σ|)$ ，其中 $|Σ|$ 表示字符集大小，这里是 $26$ 。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    s = I()
    n = len(s)

    last_pos = [-1] * 27
    sorted_last_pos = [-1] * 27

    ans = [0] * 26

    for i in range(n):
        c = ord(s[i]) - ord('a')
        sorted_last_pos.remove(last_pos[c])
        last_pos[c] = i
        sorted_last_pos.append(i)
        
        for j in range(26):
            # 这段区间对应的子字符串有 26 - j 个不同字符
            # 这里多减去了 1 是为了放入一个长度为 26 的数组
            ans[25 - j] += sorted_last_pos[j+1] - sorted_last_pos[j]

    # 把后面的 0 都删了
    while ans[-1] == 0:
        ans.pop()

    print(len(ans))
    print(*ans, sep='\n')
```
