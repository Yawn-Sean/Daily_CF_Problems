**提示 1：** 如果目前连通块完全确定，那么每个连通块内最大度数的点度数是多少？

**提示 2：** 题目条件给了哪些关于连通块的限制？最后如何构造最大连通块？

题目的要求实际上是：在考虑前面 $i$ 个条件时，能构造出的由 $i$ 条边构成的图的最大度数点的度数。每个条件是 $u_i$ 与 $v_i$ 连通。

在连通关系不改变的情况下，我们可以将连通块内所有的点都和选取的某个点相连，就像样例给出的那样，这样可以使得连通块内最大度数点度数最大。

而这个最大度数等于连通块大小 $-1$ ，因此我们只需使得最大连通块内点最多。

我们接下来考虑的就是最大连通块可以有多大。我们先使用并查集等方式，把不得不连通的块连起来。对于每个大小为 $size$ 连通块，只需要 $size-1$ 条边就可以保证其连通关系，因此会有剩余的边，即考虑连通关系时发现之前两点已经连通。

如果边数有剩余，设剩下了 $m$ 条边，那么我们可以把 $m+1$ 个连通块合并起来形成一个大连通块。这时，只要选取的连通块是最大的，构造的大连通块就也是最大的。

因此对于每一个 $i$ 单独计算结果即可。

时间复杂度为 $\mathcal{O}(n^2)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, d = MII()
    outs = []

    # 也可以直接替代为一个可以增删的有序结构，只要增删复杂度不超过 O(n) 复杂度不变
    cnt = [0] * (n + 1)
    cnt[1] = n

    union = UnionFind(n)
    # 选择的连通块数量
    k = 1

    for _ in range(d):
        u, v = GMI()
        if union.find(u) != union.find(v):
            cnt[union.getSize(u)] -= 1
            cnt[union.getSize(v)] -= 1
            union.merge(u, v)
            cnt[union.getSize(u)] += 1
        else:
            k += 1
        
        ans = 0
        cur = k
        for i in range(n, 0, -1):
            if cur == 0: break
            v = min(cur, cnt[i])
            ans += v * i
            cur -= v
        
        outs.append(ans - 1)

    print('\n'.join(map(str, outs)))
```