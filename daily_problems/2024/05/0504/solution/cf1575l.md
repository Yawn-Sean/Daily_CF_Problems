**提示 1：** 考虑从最后的结果数组回推。

**提示 2：** 最后结果数组中找到满足 $f(x)=x$ 的所有位置，其相邻两项在原数组中应当满足什么关系？

原题相当于从原数组中选取子序列，看满足 $f(x)=x$ 的总位置个数的最大值。

正向没有很好的处理方法，因此反向考虑，从最后数组中满足条件的位置往回推。

假设结果的数组中 $i,j\ (i\lt j)$ 满足 $f(i)=i,f(j)=j$ ，设 $i,j$ 的原位置分别是 $x,y$ ，则：

$a_x=i\lt a_y=j$

同时，靠前的位置向前移动的下标数量一定不大于靠后的位置向前移动的下标数量。而这里，靠前的位置应当从 $x$ 移动到 $i=a_x$ ，靠后的位置应当从 $y$ 移动到 $j=a_y$ ，即：

$x-a_x\leq y-a_y$

于是我们需要从原数组中选取子序列，其中相邻两项满足条件：

$a_x\lt a_y,\ x-a_x\leq y-a_y$

除此之外，仍需要满足 $x-a_x\geq 0$ ，否则 $x$ 位置的元素无法向左移动到 $a_x$ 的位置。

这是个二维偏序（有两个维度的大小关系限制）问题，要找到 $(a_x,x-a_x)$ 满足对应条件的子序列。

我们处理二维偏序的常见方法是关于其中一个维度进行排序，再考虑剩下的另一个维度。因此我们将所有可行的 $(a_x, x-a_x)$ 对关于 $a_x$ 排序。

接下来 $x-a_x$ 只需要满足构成非递减的子序列的条件即可，这是个很典型的问题，力扣上有类似的 [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 。

但我们还存在一个问题：我们这里找到的子序列一定是原数组的子序列吗？毕竟我们排序过了，可能会打乱前后顺序。

事实上，一定仍然是原数组的子序列，因为新数组的子序列相邻两项满足 $a_x\lt a_y,\ x-a_x\leq y-a_y$ ，两个不等式相加，有 $x\lt y$ ，因此在原数组中也一定维持原有的先后顺序。于是，求得的 $x-a_x$ 的最长非递减子序列长度就是答案。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    nums = LGMI()

    tmp = [[] for _ in range(n)]

    for i in range(n):
        if i - nums[i] >= 0:
            tmp[nums[i]].append(i - nums[i])

    lis = []
    for i in range(n):
        for j in reversed(tmp[i]):
            x = bisect.bisect_right(lis, j)
            if x < len(lis): lis[x] = j
            else: lis.append(j)

    print(len(lis))
```