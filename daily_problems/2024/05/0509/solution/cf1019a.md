**提示 1：** 最后你的票数严格大于其他人的票数，这个条件中有两个变量，尝试将其转换为两个单变量的不等式条件。

**提示 2：** 存在一个 $x$ ，使得最终情况下你的票数大于 $x$ ，其他人的票数小于等于 $x$ ，如果我们枚举 $x$ ，那么所有条件都只关于一个变量了，就好处理了。

**提示 3：** 怎么用最小的成本让其他人的票数小于等于 $x$ ？怎么在前面的条件满足的基础上进一步使得自己的票数大于 $x$ ？

首先我们这边做的事是通过支付成本使得别人的票变为自己的（贿赂），目标是自己的票比其他所有人的都多。

最后要满足的条件都和我们的操作有关，相当于两边的变量都是不固定的，因此不是很好处理。

于是考虑 **引入新的中间变量 $x$ ，使得最终情况下你的票数大于 $x$ ，其他人的票数小于等于 $x$** 。

这样我们两个条件均有具体而固定的目标，同时 $x$ 只需从 $0$ 循环到 $n-1$ 枚举。如果我们对每一个 $x$ 都能以线性左右的复杂度计算结果，那么最后我们将以 $n\times\mathcal{O}(n)=\mathcal{O}(n^2)$ 的时间复杂度解决问题。

接下来考虑如何满足上面提到的两个条件。

因为自己的票数来可能是其他任何一个人的票，但其他人的票数只会单调减少，因此先考虑后一个条件，即其他人的票数小于等于 $x$ 。

##### 其他人的票数小于等于 $x$

我们不断挑选其中贿赂成本最低的人，收买其选票。同时，我们自己获得的票数也因此增加。

##### 你的票数大于 $x$ 

此时如果你的选票仍然不超过 $x$ ，你应当选择剩下的所有还没贿赂的人中，贿赂成本最低的若干个，以使得最后选票数量可以达到 $x+1$ ，且总成本最小。

通过上面的两步贪心，我们可以得到正确的结果。

最朴素的实现可以在每次循环内部排序，已得到成本最小的结果，这样的时间复杂度为 $n\mathcal{O}(n\log n)=\mathcal{O}(n^2\log n)$ .

但其实上面的排序总是关于贿赂成本升序的，因此可以在循环枚举 $x$ 前，预处理关于成本排序的结果，以去掉复杂度中的 $\log n$ .

假设 $n$ 个人已经关于贿赂成本降序排序了，那么我们可以顺序遍历，不断记录当前各方选票数量，表示不贿赂的情况下对方选票数量。

一旦遇到某一方选票已经到达 $x$ ，则这一类的选票需要贿赂，而此前遍历位置的贿赂成本小于后面遍历的位置，因此选择贿赂所有后面的同类投票者。

最后我们也可以得到关于成本排序的未被贿赂的人员下标，按成本从小到大的顺序进行遍历以使得你的选票数量大于 $x$ 即可。

总时间复杂度为 $n\times\mathcal{O}(n)=\mathcal{O}(n^2)$ .

**Bonus：** 你能否给出复杂度更优的做法？应当用到连续的两个 $x$ 对应的贿赂人选是差别不大的。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, m = MII()

    parties = []
    costs = []

    for _ in range(n):
        p, c = MII()
        parties.append(p - 1)
        costs.append(c)

    st_range = sorted(range(n), key=lambda x: costs[x], reverse=True)

    # 分别记录哪些人还没被贿赂，每个党派有多少投票人
    used = [0] * n
    cnt = [0] * m

    ans = inf

    for max_votes in range(0, n + 1):
        cnt_votes = 0
        res = 0
        for i in st_range:
            if parties[i] == 0:
                cnt_votes += 1
            else:
                if cnt[parties[i]] < max_votes:
                    cnt[parties[i]] += 1
                    used[i] = 1
                else:
                    cnt_votes += 1
                    res += costs[i]
        
        for i in range(n - 1, -1, -1):
            if cnt_votes <= max_votes and used[st_range[i]]:
                res += costs[st_range[i]]
                cnt_votes += 1
            # 将两个数组进行清空，这样可以避免重复开数组
            used[st_range[i]] = 0
            cnt[parties[i]] = 0
        
        ans = min(ans, res)

    print(ans)
```