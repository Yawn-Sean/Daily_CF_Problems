**提示 1：** 一个字符串只要有一个三元组满足条件就已经需要加入计数了。因此更长的字符串一定更容易满足要求。

**提示 2：** 考虑一个长度为 $k$ 的字符串，其只需要 $\mathcal{O}(k^2)$ 中的一个条件，这是很容易做到的。想办法写程序验证这件事。

**提示 3：** 验证完提示 2 的结果后，给出一个合适的数数代码。

首先，如果一个字符串满足要求，那么另一个包含它的字符串也一定满足要求。

因此，我们移动子字符串的左端点 $l$ ，我们只需找到最小的右端点 $r$ 使得 $s[l\dots r]$ 满足要求，则右端点可以为 $r,\dots,n-1$ 中的任何一个，因此有 $n-r$ 种方法。

那么，怎么对一个 $l$ 找到最小的 $r$ 呢？

事实上，本题的性质并不容易用双指针维护，因为满足条件的对数并不容易计算。我们还是从条件出发探讨。

考虑一个长度为 $k$ 的字符串，其需要满足 $\mathcal{O}(k^2)$ 个相关条件。总共 $2^k$ 个字符串，随机一个字符串，要使得其 $i,i+j,i+2j$ 不满足条件，概率是 $\frac{3}{4}$ 。

如果这些条件都是相互独立的，最后期望有 $2^k\times \left(\frac{3}{4}\right)^{\mathcal{O}(k^2)}\to 0$ 个字符串不满足所有条件。

尽管这些条件不是相互独立的，但这仍然给了我们很强的提示： $k$ 一旦大起来很容易就会满足条件加入计数。

为了验证这件事，你只需要枚举所有长度为 $k$ 的字符串，查看是否满足条件，发现长度为 $9$ 的字符串就已经一定能找出三元组了。

因此不满足要求的子字符串形式很少，我们只需预处理储存结果即可。

因此，我们枚举左端点 $l$ 时，不断扩大右端点，使用前面预处理结果判断，直到找到第一个能满足三元组条件的 $r$ ，对答案增加 $n-r$ 即可。

时间复杂度为 $\mathcal{O}(nk+k^32^k)$ ，其中 $k$ 表示考虑的不满足条件的字符串的长度。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    vis = [set() for _ in range(11)]

    for i in range(1, 11):
        for j in range(1 << i):
            x = bin(j)[2:].zfill(i)
            f = False
            for mid in range(i):
                for wing in range(1, i):
                    if mid - wing < 0 or mid + wing >= i: break
                    if x[mid - wing] == x[mid] == x[mid + wing]:
                        f = True
            if f: vis[i].add(j)

    s = I()
    n = len(s)
    ans = 0

    for i in range(n):
        cur = 0
        for j in range(i, n):
            cur = 2 * cur + int(s[j])
            if cur in vis[j - i + 1]:
                ans += n - j
                break

    print(ans)
```