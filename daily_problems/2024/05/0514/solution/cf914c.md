**提示 1：** 一次操作后，数字会不超过多少？接下来进行的操作次数是可以预处理的。

**提示 2：** 我们只需要知道一次操作后，这个数变成了多少，就可以知道这个数多少次操作后会变成 $1$ 。

**提示 3：** 我们统计一次操作后，变成每个数的分别有多少个。

首先，由于 $n\lt 2^{1000}$ ，因此二进制表示中最多有 $1000$ 个 $1$ ，一次操作后必然变成不超过 $1000$ 的数。

而我们只需要预处理 $1~1000$ 的数多少次操作后会变成 $1$ ，又由于我们知道原数有多少个 $1$ ，即经过一次操作后会变成的数，于是可以知道原数经过多少次操作后会变成 $1$ 。

因此，我们先将原有的 $x$ 经过一次操作，接下来找所有恰经过 $k-1$ 次操作可以变成 $1$ 的数即可。

因此我们对所有 $[1,n]$ 的数，统计其经过一次操作后，变为 $c$ 的元素的数量即可。

也就是说，我们要统计 $[1,n]$ 中，二进制表示里出现 $1$ 次数为 $c$ 的数的数量，这是个典型的数位 DP 问题。

具体而言，我们从高到低枚举数位，枚举新的一位是 $0$ 还是 $1$ 。如果此前的数字已经严格更小，那么下一位可以随意填写 $0 / 1$ ，否则只能选择不超过当前位数码的数字。

设置状态 $dp[i][bound][cnt]$ 表示到第 $i$ 位时，前面的数字是否严格小于给定上界（ $bound$ ），且其中出现的 $1$ 的个数为 $cnt$ 。枚举下一位的过程中，更新 $bound, cnt$ 即可。

最后我们要找的是 $dp[n][0/1][cnt]$ 的和，且 $cnt$ 满足恰经过 $k-1$ 次操作后会变成 $1$ ，这件事我们刚刚已经预处理过了。

这里也有一些 [关于数位 DP 的讲解](https://oi-wiki.org/dp/number/) ，但是好像没有太清楚，有些例题，大家可以瞎看看。

另外建议这里单独讨论 $k=0/1$ 的情况，不然容易因为实现的原因出现边界问题。

总时间复杂度为 $\mathcal{O}(\log^2n)$ ，来源于数位 DP，共有这么多状态，且转移是 $\mathcal{O}(1)$ 的。

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = I()
    k = II()

    if k == 0:
        print(1)
        exit()

    if k == 1:
        print(len(n) - 1)
        exit()

    ops = [0] * (1 << 10)
    for i in range(2, 1 << 10):
        ops[i] = ops[i.bit_count()] + 1

    mod = 10 ** 9 + 7

    ones = [0] * (1 << 10)
    cur = 0
    for c in n:
        for i in range((1 << 10) - 1, 0, -1):
            ones[i] += ones[i-1]
            ones[i] %= mod
        if c == '1':
            ones[cur] += 1
            ones[cur] %= mod
            cur += 1

    ans = 0
    for i in range(1, 1 << 10):
        if ops[i] == k - 1:
            ans += ones[i]
            ans %= mod

    if ops[n.count('1')] == k - 1:
        ans += 1
        ans %= mod

    print(ans)
```