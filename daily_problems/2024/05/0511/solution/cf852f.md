**提示 1：** 这里的所有元素都一定保持是 $a$ 的幂次，因此可以取对数，把乘法变成更简单的加法运算。

**提示 2：** 计算每一次操作后的次数，你发现了什么？

欸，先看提示 1 。

每一项显然都是 $a$ 的幂次，因此考虑关于 $a$ 取对数，则数组一开始是 $[1,1,\dots,1]$ ，后面的每次操作是将数值替换为其本身和后一项的和。

然后我们可以尝试找规律，因为实际上是数组的最后为起点，我们从后往前列幂次。前 $6$ 次操作后的结果为：

$1,2,2,2,2,2,2,\dots$

$1,3,4,4,4,4,4,\dots$

$1,4,7,8,8,8,8,\dots$

$1,5,11,15,16,16,16,\dots$

$1,6,16,26,31,32,32,\dots$

$1,7,22,42,57,63,64,\dots$

怎么对着矩阵观察规律呢？

首先，我们可以关注到横着来看，最后会相等，而最后的结果都是 $2^i$ 的形式。

考虑这个性质，我们应该横着观察，而一种常见的方式是差分。我们发现差分后恰好构成组合数，即：

$1,1,0,0,0,0,0,\dots$

$1,2,1,0,0,0,0,\dots$

$1,3,3,1,0,0,0,\dots$

$1,4,6,4,1,0,0,\dots$

$1,5,10,10,5,1,0,\dots$

$1,6,15,20,15,6,1,\dots$

因此次数恰好是前几个组合数的和。

这件事怎么证明呢？使用数学归纳法，假设第 $M$ 轮结束后，第 $N (N\geq 0)$ 个数是 $C_M^0+C_M^1+\dots+C_M^N$ ，则第 $M+1$ 轮结束后时，第 $N (N\geq 0)$ 个数是原先第 $N$ 个数和第 $N-1$ 个数的和，即：

$(C_M^0+C_M^1+\dots+C_M^N)+(C_M^0+C_M^1+\dots+C_M^{N-1})\\
=(C_M^0)+(C_M^1+C_M^0)+\dots+(C_M^N+C_M^{ N-1})\\
=C_{M+1}^0+C_{M+1}^1+\dots+C_{M+1}^N$

这里用到了组合式 $C_{n+1}^{k+1}=C_n^k+C_n^{k+1}$ ，左侧表示 $n+1$ 中取出 $k+1$ 个的方案数，右侧表示先把 $n+1$ 个元素拆为 $n$ 个和 $1$ 个元素，如果后面这个元素选取了，则前面的选取 $k$ 个，否则选取 $k+1$ 个。可以发现两种描述都计算了一件事，因此左右两侧相等。

因此我们得到了幂次应当是组合数的求和。

题目告诉我们，存在一个质数的 $φ(a,Q)\leq 10^6+123$ 使得 $a^{φ(a,Q)}\bmod Q=1$ ，因此我们只需要求出组合数关于 $φ(a, Q)$ 取模的结果即可，因为 $a^{kφ(a,Q)+r}\bmod Q=(a^{φ(a,Q)})^ka^r\bmod Q=a^r\bmod Q$ .

首先，我们枚举 $1$ 到 $10^6+123$ 的数，找到对应的 $φ(a, Q)$ ，这里无需使用快速幂，因为后一项的计算结果是前一项的 $a$ 倍数。

最后只需计算一个组合数关于质数的取模即可，且质数大于组合数的上下标。

一个组合数 $C_n^m=\frac{n!}{m!(n-m)!}$ ，我们可以使用 $n!=n\times(n-1)!$ 快速计算出所有 $k!$ 的取模结果。

接下来只需计算 $\frac{1}{k!}$ 的取模结果，也被称为逆元（[具体定义](https://oi-wiki.org/math/number-theory/inverse/)）。

为此，我们可以用 $\mathcal{O}(\log Q)$ 的时间复杂度，找到 $n!$ 的逆元 $\frac{1}{n!}$ ，再不断使用 $\frac{1}{(i-1)!}=i\times\frac{1}{i!}$ 不断回推前面每一个阶乘的逆元。

于是，在预处理后，可以 $\mathcal{O}(1)$ 计算出每个组合数模质数的结果，因此其前缀和取模的结果也可以快速得出。

最后，指数的取模结果确定，我们只需计算对应的 $a^r\bmod Q$ ，这里可以使用快速幂，但由于 $r\lt φ(a,Q)$ ，因此可以直接预处理所有 $φ(a, Q)$ 以下的乘方结果，即可 $\mathcal{O}(1)$ 找到答案。

总时间复杂度为 $\mathcal{O}(n+φ(a,Q))$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, m, a, q = MII()

    powers = [1]
    for i in range(10 ** 6 + 123):
        powers.append(powers[-1] * a % q)
        if powers[-1] == 1:
            powers.pop()
            break

    phi = len(powers)

    fact = Factorial(m, phi)

    ans = [1] * n
    for i in range(n - 2, -1, -1):
        ans[i] = (ans[i + 1] + fact.combi(m, n - 1 - i)) % phi

    print(' '.join(str(powers[x]) for x in ans))
```
