**提示 1：** 如何计算一个排列是第几个排列？

**提示 2：** 这里要对 $order$ 相加， $order$ 很大怎么办？有何合理的存储方式？

**提示 3：** 如何找到第 $k$ 个排列？

如果不想看我的题解，可以直接去这里学习提示 1 和提示 3 提到的两件事：[康托展开](https://oi-wiki.org/math/combinatorics/cantor/) .

我们先看给定一个排列的时候，到底怎么计算其是第几个排列。

我们发现第一个位置的元素有 $n$ 中选择方案，而其后的所有元素有 $(n-1)!$ 种排列方案。

因此有 $(n-1)!$ 种方案排列的第一项是 $0$ ， $(n-1)!$ 种方案排列的第一项是 $1$ ，……， $(n-1)!$ 种方案排列的第一项是 $n-1$ 。

于是第 $0\sim(n-1)!-1$ 个排列是 $0$ 开头的，第 $(n-1)!\sim 2\times(n-1)!-1$ 个排列是 $1$ 开头的……

因此，设我们求排列是第 $order$ 个，那么 **排列的第一位 $k$ 直接告诉了我们 $order=k(n-1)!+d\ (0\lt d \lt (n-1)!)$** 。

剩下的元素怎么讨论呢？ **其本质上是 $n-1$ 个数的排列，我们只需把它们按照相对的大小关系变成 $0,1,2,\dots,n-2$ 的排列，因此其仍然是一个与前面讨论相同的规模更小问题** 。

而根据相对大小调整数值的数字，都是比前面选过的数更大的数。

比方说，我们考虑排列 $[1,2,0,3]$ ，则我们先根据第一项是 $1$ ，得到这是第 $6~11$ 个排列；接下来去掉第一个元素，剩下 $[2,0,3]$ ，维持原有大小关系，变为 $[1,0,2]$ ，发现实际上变动数值的位置是比前面的数更大的位置。

因此我们每个数需要调整多少次数值（即进行上面的 $-1$ 操作，如上面例子里面的 $2,3$ 变成了 $1,2$ ）只需要看前缀中有多少个元素比它小，这件事很容易用树状数组维护。

但是我们 $order$ 的数值大小可以达到 $n!$ ，我们不能直接储存其数值，怎么办呢？

我们发现我们刚刚的计算过程给了我们提示。我们不必算出 $order$ 的具体数值，我们第一步算出了 $k\times(n-1)!$ ，第二步排列长度缩减至 $n-1$ ，因此会根据第二位调整的数值新算入 $k'\times(n-2)!$ ……以此类推，我们可以用 $k_{n-1}(n-1)!+k_{n-2}(n-2)!+\dots=\sum\limits_{i=0}^{n-1}k_ii!$ 表示 $order$ ，只需存储一个 $k_i$ 构成的数组即可。

接下来我们需要对两个 $order$ 进行求和，这件事本身就是大数加法，从最小位开始往大考虑，看是否进位。具体而言，如果我们要计算以下两个 $order$ 之和：

$3\times 3!+2\times 2!+0\times 1!+0\times 0!$

$+0\times 3!+2\times 2!+1\times 1!+0\times 0!$

从小的阶乘考虑到大的阶乘，发现 $0!$ 和 $1!$ 前的系数为 $0,1$ ，分别无法变成 $1!,2!$ ，因此不进位。

但 $2!$ 前的系数是 $4$ ，因此 $4\times 2!=1\times 3!+1\times 2!$ ，发生进位。

接下来 $3!$ 需要考虑原有加和 $3\times 3!$ 以及进位产生的 $3!$ ，因此 $3!$ 前的系数为 $4$ ，而 $4\times 3!=4!$ ，因此最后仍然发生进位。

于是，计算结果为 $0\times 3!+1\times 2!+1\times 1!+0\times 0!$ .

最后，我们要从 $order$ 反推序列。这件事相当于是我们前面计数的逆过程。

我们可以根据 $\lfloor\frac{order}{(n-1)!}\rfloor$ 找到答案排列的第一个元素；找完第一个元素后，剩下的元素本质上仍然是 $n-1$ 个元素的排列，我们可以找到第二个元素是剩余元素中第几大的，以此类推即可。可以仔细理解前面计数的逻辑。

这里需要找删去若干个元素后的第 $i$ 个元素，这件事是可以通过树状数组上的二分实现的。

时间复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    perm1 = LII()
    order1 = [0] * n

    fen = FenwickTree(n)
    for i in range(n):
        order1[i] = perm1[i] - fen.sum(perm1[i])
        fen.add(perm1[i], 1)

    perm2 = LII()
    order2 = [0] * n

    fen = FenwickTree(n)
    for i in range(n):
        order2[i] = perm2[i] - fen.sum(perm2[i])
        fen.add(perm2[i], 1)

    order = [0] * n
    carry = 0
    for i in range(n - 1, -1, -1):
        carry, order[i] = divmod(order1[i] + order2[i] + carry, n - i)

    ans = [0] * n
    fen = FenwickTree(n, [1] * n)
    for i in range(n):
        ans[i] = fen.bisect_min_larger(order[i] + 1)
        fen.add(ans[i], -1)

    print(' '.join(map(str, ans)))
```
