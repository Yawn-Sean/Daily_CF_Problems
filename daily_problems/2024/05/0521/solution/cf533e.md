**提示 1：** 两个字符串是从同一个字符串删去一个字符得到的。考虑两个删除的位置，前面删除位置前的字符串、后面删除位置后的字符应该保持一致。

**提示 2：** 中间的字符串应该满足什么性质？

我们假设原字符串是 $S_0[1,2,\dots,n]$ ，假设第一个字符串删的是 $i$ 位置，第二个字符串删的是 $j$ 位置，则 $S_0[1,2,\dots,\min(i, j)-1]$ 同时作为两个字符串的前缀， $S_0[\max(i,j)+1,\dots,n]$ 同时作为两个字符串的后缀。

而如果我们去除开头和结尾的相同的部分，剩下的字符串是怎么得到的呢？

**相当于是 $S_0$ 的一个子字符串，去掉开头和结尾得到的。**

于是，我们只需要判断剩下的字符串可不可以用同一个字符串分别去掉头 / 尾得到。

这件事可以怎么判断呢？

我们设 $s_1$ 是去头得到的， $s_2$ 是去尾得到的，那么 $s_1$ 去尾等于 $s_2$ 去投，用这一条件判断即可。

形式化地表述，上面的逻辑可以理解为：

我们设删的两个字符分别是 $x$ 和 $y$ （不妨假设 $x$ 更靠前），那么原字符串可以表示为 $A+x+B+y+C$ ，然后我们得到的新字符串分别是 $A+B+y+C, A+x+B+C$ 。

去掉相同的前缀和后缀后，剩下了 $B+y,x+B$ ，那么只需两个字符串一个去掉头等于另一个去掉尾。

时间复杂度为 $\mathcal{O}(n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n = II()
    s1 = I()
    s2 = I()

    l = -1
    r = -1
    for i in range(n):
        if s1[i] != s2[i]:
            if l == -1: l = i
            r = i

    print((s1[l:r] == s2[l+1:r+1]) + (s1[l+1:r+1] == s2[l:r]))
```
