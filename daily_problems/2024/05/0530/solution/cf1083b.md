**提示 1：** 分别考虑每个长度不同的前缀，分别最多出现几个不同的？

**提示 2：** 考虑从长度为 $m$ 的前缀到长度为 $m+1$ 的前缀，上述计算可以怎么利用前一次的结果进行后推？

这题第一个主要思路是，分别计算每一个长度不同的前缀分别有多少个不同的字符串。

考虑 $s,t$ 的长度为 $m$ 的前缀 $s_m, t_m$ ，则 $s_m$ 到 $t_m$ 的所有长度为 $m$ 字符串均可以成为长度为 $m$ 的可行前缀，因此，长度为 $m$ 的前缀对结果的贡献为 $s_m$ 到 $t_m$ 的字符串数量 $cnt$ 和 $k$ 的最小值。

那么在考虑前缀长度从 $m$ 变成 $m+1$ 的过程中， $cnt$ 应该如何变化呢？

首先，发现每个字符串可以在后面添加 `'a'`, `'b'` 之一，因此 $cnt$ 乘 $2$ 。

而这样计算会多算哪些字符串呢？如果 $s$ 新的一位是 `'b'` ，那么 $s$ + `'a'` 就是多算的一个元素；如果 $t$ 新的一位是 `'a'` ，那么 $t$ + `'b'` 就是多算的一个元素。根据这两个条件进行调整即可。

注意可以在中间过程中对 $cnt$ 取 $cnt=\min(cnt, k + 1)$ ，避免中间计算过程中结果过大。

时间复杂度为 $\mathcal{O}(1)$ .

当然这题还有另一个视角来看：

**我们把所有 `'a'` 换成 `'0'` ，把所有 `'b'` 换成 `'1'` ，我们将前缀视为一个二进制表示，相当于求的是所有前缀的差加一和 $k$ 的最小值的和。**

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    n, k = MII()
    s = I()
    t = I()

    cur = 1
    ans = 0

    for i in range(n):
        cur = cur * 2 - (s[i] == 'b') - (t[i] == 'a')
        cur = min(cur, k + 1)
        ans += min(cur, k)
    
    print(ans)
```
