**提示 1：** 首先， $f(l,r)$ 的数值不应过大，因为满足条件的子字符串有 $f(l,r)=r-l+1$ ，不超过 $n$ .

**提示 2：** 对于一个确定的 $k$ ，满足 $f(l,r)=k$ 的 $s[l\dots r]$ 应当是什么形式？利用好这个形式的特点。

首先 $f(l,r)=r-l+1\leq n$ ，因此 $f(l,r)$ 数值不会过大。

而如果 $f(l,r)=k$ ，子字符串 $s[l\dots r]$ 应当使得其最后若干位是 $k$ 的二进制表示，而前面全都是 $0$ .

而由于 $k$ 不超过 $n$ ，因此 **其二进制表示长度是 $\mathcal{O}(\log n)$** 量级的。

因此我们 **枚举所有长度不超过 $\log n$ 量级的字符串，我们假设其表示了 $f(l,r)$** ，那么我们只需要看其前面是否有足够多的 $0$ ，使得字符串的总长度为 $f(l,r)$ 即可。

而从一个位置开始往前的连续的 $0$ 的个数，可以通过预处理得到。如果这一位是 $1$ ，则连续 $0$ 的个数为 $0$ ；否则，等于前一位连续 $0$ 的个数加一。

为了避免重复计算，我们只需要求枚举的短字符串开头必须是 $1$ 即可。

整体复杂度为 $\mathcal{O}(n\log n)$ .

#### 具体代码如下（只包含中间处理部分）——

```Python []
def main():
    s = I()
    n = len(s)
    pref_zero = [0]
    for c in s:
        if c == '0': pref_zero.append(pref_zero[-1] + 1)
        else: pref_zero.append(0)
    
    ans = 0
    for i in range(n):
        cur = 0
        for j in range(i, max(0, i - 18) - 1, -1):
            if s[j] == '1':
                cur |= 1 << i - j
                if pref_zero[j] + i - j + 1 >= cur:
                    ans += 1
    return ans
```
