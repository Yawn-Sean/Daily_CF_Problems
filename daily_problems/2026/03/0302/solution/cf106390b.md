**提示 1：** 我们将跳操作前后视为两步。第一步怎么处理？第二步怎么处理？

本题可以使用分层图直接跑最短路的方式解决，进入第二层的时候新增一个表示距离原点为 $x$ 的虚拟节点，从 $u$ 到 $x$ 和 $x$ 到 $u$ 分别连一条边即可。这样需要 Dijkstra ，但这里原图是棵树，所以可以优化。下面介绍另一个做法。

因为只能跳两步，所以我们分跳前和跳后两步考虑。

跳前，直接 DFS 就能找到最短路。

接下来考虑跳的操作。假设 $u$ 的父亲结点在跳后距离为 $w$ ，则如果到 $u$ 的路径的跳的操作在父亲节点或之前进行，则答案应该是 $w+父亲节点的答案$ 。否则，只能在 $u$ 这层跳，也就是 $u$ 这层的最小值。直接对这两者取最小值，就是 $u$ 的答案。

不可能先到更深层的结点再跳回来，因为我们可以直接在浅的一层跳回来，成本更低。

如果要卡掉这题的 $\log$ 做法，可以钦定一个跳的次数的最大值 $v$ ，这样我们只需进行 $v$ 轮这里的更新就行，时间复杂度为 $\mathcal{O}(nv)$ 。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    inf = 10 ** 18
    
    for _ in range(t):
        n = II()
        path = [[] for _ in range(n)]
        
        for _ in range(n - 1):
            u, v, w = MII()
            u -= 1
            v -= 1
            path[u].append(w * n + v)
            path[v].append(w * n + u)
        
        parent = [-1] * n
        dis0 = [0] * n
        dis1 = [0] * n
        min_dis = [inf] * n
        
        que = [0]
        for u in que:
            min_dis[dis0[u]] = fmin(min_dis[dis0[u]], dis1[u])
            for msk in path[u]:
                w, v = divmod(msk, n)
                if parent[u] != v:
                    parent[v] = u
                    dis0[v] = dis0[u] + 1
                    dis1[v] = dis1[u] + w
                    que.append(v)
        
        for u in que:
            dis1[u] = fmin(dis1[u], min_dis[dis0[u]])
            for msk in path[u]:
                w, v = divmod(msk, n)
                if parent[v] == u:
                    dis1[v] = dis1[u] + w
        
        outs.append(' '.join(map(str, dis1)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	long long inf = 1e18;

	while (t --) {
		int n;
		cin >> n;

		vector<vector<pair<int, int>>> path(n);
		for (int i = 0; i < n - 1; i ++) {
			int u, v, w;
			cin >> u >> v >> w;
			u --, v --;
			path[u].emplace_back(v, w);
			path[v].emplace_back(u, w);
		}

		vector<int> dis0(n, 0);
		vector<long long> dis1(n, 0), min_dis(n, inf);

		auto dfs = [&] (auto &self, int u, int p) -> void {
			min_dis[dis0[u]] = min(min_dis[dis0[u]], dis1[u]);

			for (auto &[v, w]: path[u]) {
				if (v != p) {
					dis0[v] = dis0[u] + 1;
					dis1[v] = dis1[u] + w;
					self(self, v, u);
				}
			}
		};

		dfs(dfs, 0, -1);

		auto dfs1 = [&] (auto &self, int u, int p) -> void {
			dis1[u] = min(dis1[u], min_dis[dis0[u]]);

			for (auto &[v, w]: path[u]) {
				if (v != p) {
					dis1[v] = dis1[u] + w;
					self(self, v, u);
				}
			}
		};

		dfs1(dfs1, 0, -1);

		for (auto &x: dis1) cout << x << ' '; cout << '\n';
	}

	return 0;
}
```
