**提示 1：** 考虑计算每个序列的序号。用二进制表示。

**提示 2：** 最高位如何确定？剩下的呢？

先看提示 1 。

二进制表示的最高位只取决于最后一个片是否到达了目标位置。

我们可以借此不断删掉最后一个片，进而确定每个二进制位。但过程中我们的出发位置和目标会发生调整。

我们称三个位置为出发位置、暂存位置和最终位置。

如果当前最大的一片还没到达最终位置，则倒数第二片还在不断向暂存位置调整（直到所有片都到达暂存位置时，最大片才能到达最终位置，所以倒数第二片目标实际上是暂存位置）。此时删去最大片后，最终位置和暂存位置应当互换。

否则，我们是在从暂存位置往最终位置挪动的过程中，因此是出发位置和暂存位置互换。

按照上述逻辑，不断模拟三种位置得到二进制表示的每一位，最后找最大值对应的下标即可。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    bin_2s = []
    
    for i in range(m):
        s = I()
        source, tmp, target = 'A', 'C', 'B'
        
        bin_2 = []
        
        for c in reversed(s):
            if c == target:
                bin_2.append(1)
                source, tmp = tmp, source
            else:
                bin_2.append(0)
                tmp, target = target, tmp
        
        bin_2s.append(bin_2)
    
    print(bin_2s.index(max(bin_2s)) + 1)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<string> bin_2s;

	for (int i = 0; i < m; i ++) {
		string s;
		cin >> s;

		char source = 'A', tmp = 'C', target = 'B';
		string bin_2;

		for (int j = n - 1; j >= 0; j --) {
			if (s[j] == target) {
				bin_2 += '1';
				swap(source, tmp);
			}
			else {
				bin_2 += '0';
				swap(tmp, target);
			}
		}

		bin_2s.emplace_back(bin_2);
	}

	cout << max_element(bin_2s.begin(), bin_2s.end()) - bin_2s.begin() + 1;

	return 0;
}
```
