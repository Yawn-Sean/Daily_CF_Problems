**提示 1：** 两种想法——检查某个答案是否满足要求；找到分开两条路径的边。

方法一：越大的最小值越难凑，所以考虑使用二分，在树上进行 DP 。DP 维护从更深的位置到当前结点的最大路径权值。DP 的过程中，能合并且凑出大于等于 $x$ 的分支路径直接合并，并将当前节点网上传的数值变为 $-∞$ 。

方法二：对于一个子树而言，我们可以很方便地维护子树内路径的最大权值。而我们枚举分开两条路径的边，则其中一侧是子树的问题，另一侧是去掉这个子树的问题。前者可以直接 DP ，后者用换根 DP 可以解决。

时间复杂度为 $\mathcal{O}(n)$ 或者 $\mathcal{O}(n\log nM)$ ，当然这题原来的时限是 $1$ 秒，所以后者可能被卡，但是我用coach mode 改成了 $2$ 秒。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        path = [[] for _ in range(n)]
        
        for _ in range(n - 1):
            u, v, w = MII()
            u -= 1
            v -= 1
            path[u].append(w * n + v)
            path[v].append(w * n + u)
        
        parent = [-1] * n
        que = [0]
        
        for u in que:
            for msk in path[u]:
                w, v = divmod(msk, n)
                if parent[u] != v:
                    parent[v] = u
                    que.append(v)
        
        dp0 = [0] * n
        dp1 = [0] * n
        
        for u in reversed(que):
            v1, v2 = 0, 0
            
            for msk in path[u]:
                w, v = divmod(msk, n)
                if parent[v] == u:
                    nw = w + dp0[v]
                    if nw > v1: v1, v2 = nw, v1
                    elif nw > v2: v2 = nw
                    dp1[u] = fmax(dp1[u], dp1[v])
            
            dp0[u] = v1
            dp1[u] = fmax(dp1[u], v1 + v2)
        
        up_dp0 = [0] * n
        up_dp1 = [0] * n
        
        for u in que:
            v1, v2, v3 = up_dp0[u], 0, 0
            w1, w2 = 0, 0
            
            for msk in path[u]:
                w, v = divmod(msk, n)
                
                if parent[v] == u:
                    nw = w + dp0[v]
                    if nw > v1: v1, v2, v3 = nw, v1, v2
                    elif nw > v2: v2, v3 = nw, v2
                    elif nw > v3: v3 = nw
                    
                    if dp1[v] > w1: w1, w2 = dp1[v], w1
                    elif dp1[v] > w2: w2 = dp1[v]
            
            for msk in path[u]:
                w, v = divmod(msk, n)
                
                if parent[v] == u:
                    nw = w + dp0[v]
                    if nw == v1:
                        up_dp0[v] = v2 + w
                        up_dp1[v] = v2 + v3
                    elif nw == v2:
                        up_dp0[v] = v1 + w
                        up_dp1[v] = v1 + v3
                    else:
                        up_dp0[v] = v1 + w
                        up_dp1[v] = v1 + v2
    
                    if dp1[v] == w1: up_dp1[v] = fmax(up_dp1[v], w2)
                    else: up_dp1[v] = fmax(up_dp1[v], w1)
        
        outs.append(max(fmin(dp1[i], up_dp1[i]) for i in range(n)))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<vector<pair<int, int>>> path(n);
		for (int i = 0; i < n - 1; i ++) {
			int u, v, w;
			cin >> u >> v >> w;
			u --, v --;
			path[u].emplace_back(v, w);
			path[v].emplace_back(u, w);
		}

		vector<long long> dp0(n, 0), dp1(n, 0);

		auto dfs1 = [&] (auto &self, int u, int p) -> void {
			long long v1 = 0, v2 = 0;
			for (auto &[v, w]: path[u]) {
				if (v != p) {
					self(self, v, u);
					long long nw = w + dp0[v];

					if (nw > v1) swap(v1, v2), v1 = nw;
					else if (nw > v2) v2 = nw;

					dp1[u] = max(dp1[u], dp1[v]);
				}
			}

			dp0[u] = v1;
			dp1[u] = max(dp1[u], v1 + v2);
		};

		dfs1(dfs1, 0, -1);

		long long ans = 0;

		auto dfs2 = [&] (auto &self, int u, int p, long long up0, long long up1) -> void {
			long long v1 = up0, v2 = 0, v3 = 0;
			long long w1 = 0, w2 = 0;

			ans = max(ans, min(dp1[u], up1));

			for (auto &[v, w]: path[u]) {
				if (v != p) {
					long long nw = w + dp0[v];
					if (nw > v1) swap(v2, v3), swap(v1, v2), v1 = nw;
					else if (nw > v2) swap(v2, v3), v2 = nw;
					else if (nw > v3) v3 = nw;

					if (dp1[v] > w1) swap(w1, w2), w1 = dp1[v];
					else if (dp1[v] > w2) w2 = dp1[v];
				}
			}

			for (auto &[v, w]: path[u]) {
				if (v != p) {
					long long nup0, nup1;
					long long nw = w + dp0[v];

					if (nw == v1) {
						nup0 = v2 + w;
						nup1 = v2 + v3;
					}
					else if (nw == v2) {
						nup0 = v1 + w;
						nup1 = v1 + v3;
					}
					else {
						nup0 = v1 + w;
						nup1 = v1 + v2;
					}

					if (dp1[v] == w1) nup1 = max(nup1, w2);
					else nup1 = max(nup1, w1);

					self(self, v, u, nup0, nup1);
				}
			}
		};

		dfs2(dfs2, 0, -1, 0, 0);

		cout << ans << '\n';
	}

	return 0;
}
```
