**提示 1：** 对于一个子矩形，其数值的范围？

**提示 2：** 存下来一些结果，后面查询就方便了。

首先，对于一个子矩形而言，其对应的最小值和最大值一个在左上角一个在右下角。

因为中间的元素可以比上面的元素大，走到上边缘后比左侧的数大。跟右下角的比较是类似的。

所以我们可以直接遍历可能的正方形，枚举左上角和边长，得到所有可能的子正方形的答案，总共有 $\mathcal{O}(n^3)$ 个正方形。

接下来每次查询，我们枚举可能的正方形边长，看是否被一个正方形的范围包含。这个怎么快速判断呢？我们可以预处理左端点小于等于 $x$ 的最大的右端点，如果 $a$ 对应的数值大于等于 $b$ ，则此时存在对应大小的正方形满足要求。

时间复杂度为 $\mathcal{O}(n^3+qn)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    grid = [LII() for _ in range(n)]
    
    saved = [[n * n + 1] * (n * n + 1) for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if i + k >= n or j + k >= n:
                    break
                saved[k][grid[i][j]] = fmin(saved[k][grid[i][j]], grid[i + k][j + k])
    
    for i in range(n):
        for j in range(n * n - 1, -1, -1):
            saved[i][j] = fmin(saved[i][j], saved[i][j + 1])
    
    outs = []
    
    for _ in range(q):
        a, b = MII()
        
        for i in range(n - 1, -1, -1):
            if saved[i][a] <= b:
                outs.append((i + 1) ** 2)
                break
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int n, q;
    cin >> n >> q;

    vector<vector<int>> grid(n, vector<int>(n));
    for (auto &x: grid) for (auto &y: x) cin >> y;

    vector<vector<int>> saved(n, vector<int>(n * n + 1, n * n + 1));

    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            for (int k = 0; i + k < n && j + k < n; k ++) {
                saved[k][grid[i][j]] = min(saved[k][grid[i][j]], grid[i + k][j + k]);
            }
        }
    }

    for (int i = 0; i < n; i ++) {
        for (int j = n * n - 1; j >= 0; j --) {
            saved[i][j] = min(saved[i][j], saved[i][j + 1]);
        }
    }

    while (q --) {
        int a, b;
        cin >> a >> b;

        for (int i = n - 1; i >= 0; i --) {
            if (saved[i][a] <= b) {
                cout << (i + 1) * (i + 1) << '\n';
                break;
            }
        }
    }

	return 0;
}
```
