**提示 1：** 先考虑对于一个前缀， $0$ 对应的下标的方案数可以计算吗？

把问题考虑成一个个插入 $i$ 到已有的排列中。

下面放 $0$ 表示放标记为 $0$ 的那些下标，放 $1$ 也是类似的。

我们考虑放 $0$ 的方案数。

从小到大遍历 $i$ 。如果多了一个 $1$ ，无论，我们就多了一个放 $0$ 的位置。填完一个 $0$ 之后就少了一个位置。所以每个 $0$ 的选择方案数是固定的，可以使用乘法原理计数。

而这里放 $0$ 的方案数和放 $1$ 的位置是无关的，所以可以将原问题拆为两部分考虑。

而 $1$ 的方案数是类似的，只需从大到小遍历 $i$ 考虑即可。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    mod = 998244353
    
    ans = 1
    cur = 0
    
    for i in range(n):
        if nums[i]: cur += 1
        else:
            ans = ans * cur % mod
            cur -= 1
    
    cur = 0
    for i in range(n - 1, n % 2 - 1, -1):
        if nums[i]:
            ans = ans * cur % mod
            cur -= 1
        else:
            cur += 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    int mod = 998244353, ans = 1, cur = 0;

    for (int i = 0; i < n; i ++) {
        if (nums[i]) cur ++;
        else {
            ans = 1ll * ans * cur % mod;
            cur --;
        }
    }

    cur = 0;
    for (int i = n - 1; i >= n % 2; i --) {
        if (nums[i]) {
            ans = 1ll * ans * cur % mod;
            cur --;
        }
        else cur ++;
    }

    cout << ans;

	return 0;
}
```
