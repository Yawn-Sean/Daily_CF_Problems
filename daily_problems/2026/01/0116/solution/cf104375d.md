**提示 1：** 各种操作只会新增元素，同时不影响元素的相对大小关系。

**提示 2：** 可以直接排序后原地修改。

操作的各种情况其实不影响大小关系。

所以可以直接对数组进行排序。

- 如果数字比最大值大，即比最后一项大，直接新增元素。

- 二分找到数组种第一个不比它小的元素。如果一样大，无需修改，否则将其修改为 $x$ 。（其实可以一起处理）

而查询操作只需二分找到两个端点的位置就行。

时间复杂度为 $\mathcal{O}(n\log n+q(\log n+\log q))$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    nums = LII()
    nums.sort()
    
    outs = []
    for _ in range(q):
        query = LII()
        
        if query[0] == 1:
            v = query[1]
            
            if v > nums[-1]: nums.append(v)
            else:
                p = bisect.bisect_right(nums, v)
                if p > 0 and nums[p - 1] == v: continue
                else: nums[p] = v
        
        else:
            l = query[1]
            r = query[2]
            outs.append(bisect.bisect_right(nums, r) - bisect.bisect_left(nums, l))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;
	sort(nums.begin(), nums.end());

	while (q --) {
		int t;
		cin >> t;

		if (t == 1) {
			int v;
			cin >> v;

			if (v > nums.back()) nums.emplace_back(v);
			else {
				int pos = upper_bound(nums.begin(), nums.end(), v) - nums.begin();
				if (pos && nums[pos - 1] == v) continue;
				else nums[pos] = v;
			}
		}
		else {
			int l, r;
			cin >> l >> r;
			cout << upper_bound(nums.begin(), nums.end(), r) - lower_bound(nums.begin(), nums.end(), l) << '\n';
		}
	}

	return 0;
}
```
