**提示 1：** 有个关键的变量。

考虑操作的最大的前缀长度 $L$ 。

如果 $L\lt i$ ，则 $i$ 从来没有动过，位置始终是 $i$ 。

否则，在这次操作后， $i$ 被混入 $1\sim L$ 之间。

此时因为刚被打乱，所以各衣服是不可区分的，在操作意义上是等价的，因此后面无论怎么操作，每个衣服在各个位置的分布是一致的。

所以无论操作几次，这些衣服在 $1\sim L$ 中每个位置的概率都是 $\frac{1}{L}$ 。这种情况下位置的期望是 $\frac{L+1}{2}$ 。

因此只需计算 $L=v$ 的概率就行，为此可以用以下方式计算：

$P(L=v)=P(L\leq v)-P(L\leq v-1)=\left(\frac{v}{n}\right)^k-\left(\frac{v-1}{n}\right)^k$

小于等于的概率相当于每次操作都从 $1\sim v$ 中取值的概率，因为操作间独立，用乘法就行。

$i$ 不动的前面那一部分的概率也是类似计算。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, i, k = MII()
    ans = 0
    
    ans += ((i - 1) / n) ** k * i
    for M in range(i, n + 1):
        ans += ((M / n) ** k - ((M - 1) / n) ** k) * (M + 1) / 2
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, i, k;
	cin >> n >> i >> k;

	long double ans = 0;

	ans += powl((long double)(i - 1) / n, k) * i;
	for (int M = i; M <= n; M ++) 
		ans += (powl((long double)M / n, k) - powl((long double)(M - 1) / n, k)) * (M + 1) / 2;

	cout << fixed << setprecision(20) << ans;

	return 0;
}
```
