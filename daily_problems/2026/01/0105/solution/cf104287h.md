**提示 1：** 考虑每条边的权值，以及有多少种这样的边。

我们只需计算每条边被计算了多少次，再加起来就好。

相同深度的边根据对称性，计算次数是一模一样的。

第 $i$ 和第 $i+1$ 层之间连的边有 $2^i$ 条。而其权值等于两侧点的个数的乘积。我们只需算出对应子树的大小，整棵树的大小减去这棵子树的大小就是剩余的点数，也就是另一侧的大小。

而子树的大小很容易用 $2^x-1$ 表示，因此问题也就解决了。

时间复杂度为 $\mathcal{O}(d)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    M = 10 ** 5
    mod = 10 ** 9 + 7
    pw2 = [1] * (M + 1)
    
    for i in range(M):
        pw2[i + 1] = pw2[i] * 2 % mod
    
    rev2 = (mod + 1) // 2
    
    for _ in range(t):
        d = II()
        ans = 0
        
        edges = 1
        total = pw2[d] - 1
        cur = total
        
        for i in range(d - 1):
            cur = (cur - 1) * rev2 % mod
            edges = edges * 2 % mod
            
            ans = (ans + cur * (total - cur) % mod * edges % mod) % mod
        
        outs.append(ans * 2 % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e5, mod = 1e9 + 7, rev2 = (mod + 1) / 2;
	vector<int> pw2(M + 1);
	
	pw2[0] = 1;
	for (int i = 0; i < M; i ++) pw2[i + 1] = 2ll * pw2[i] % mod;

	int t;
	cin >> t;

	while (t --) {
		int d;
		cin >> d;

		int ans = 0, edges = 1, total = pw2[d] - 1, cur = total;

		for (int i = 0; i < d - 1; i ++) {
			cur = 1ll * (cur - 1) * rev2 % mod;
			edges = 2ll * edges % mod;

			ans = (ans + 1ll * cur * (mod + total - cur) % mod * edges % mod) % mod;
		}

		cout << 2ll * ans % mod << '\n';
	}

	return 0;
}
```
