**提示 1：** 不变量。

**提示 2：** 找一个中间态。

每次操作相当于取一个三角形进行异或。所以我们可以将输入的两张图直接按照异或规则合并看成一张图。

于是，每个点度数的奇偶性都不会改变。因为每次修改两条边。

接下来的构造有很多不同的思路。

一种是一个个点去删——我们先把 $n$ 这个位置的结点的所有异或后的邻边都删掉，就找两个邻接点操作就好。因为每次操作至少删一条边，所以总操作次数不会超过 $m+k$ 。

也可以找一个中间态，把开始的图和最后的图都往中间态靠。这里考虑以 $1$ 为根的一棵树，其他所有叶子节点都直接跟 $1$ 相连。

显然这样中间态是唯一的，因为每个点的度数的奇偶性是确定的。

怎么达到中间态呢？只要所有大于 $1$ 的点之间不连边就好了。所以一旦出现一条边，操作 $1,x,y$ 就是满足要求的构造了。

时间复杂度为 $\mathcal{O}(n+m+k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m, k = MII()
    deg = [0] * (n + 1)
    outs = []
    
    for _ in range(m + k):
        u, v = MII()
        deg[u] ^= 1
        deg[v] ^= 1
        if u > 1 and v > 1:
            outs.append(f'1 {u} {v}')
    
    if max(deg): print('NO')
    else:
        print('YES')
        print(len(outs))
        print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m, k;
	cin >> n >> m >> k;

	vector<int> deg(n + 1, 0);
	vector<array<int, 3>> ops;

	for (int i = 0; i < m + k; i ++) {
		int u, v;
		cin >> u >> v;
		deg[u] ^= 1, deg[v] ^= 1;
		if (u > 1 && v > 1) ops.push_back({1, u, v});
	}

	if (*max_element(deg.begin(), deg.end())) cout << "NO";
	else {
		cout << "YES\n";
		cout << ops.size() << '\n';
		for (auto &x: ops)
			cout << x[0] << ' ' << x[1] << ' ' << x[2] << '\n';
	}

	return 0;
}
```
