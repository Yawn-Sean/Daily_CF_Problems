**提示 1：** 去掉最深的一层会变成子问题。怎么去掉？

首先，如果我们解决了最后一层是什么数字，并确定了如何两两分组，我们就可以去掉最后一层，把当前问题转化为规模更小的问题。

而初始情况下，我们可以直接提取所有不同的元素，得知叶子上是哪些数。如果不同元素的数量不等于 $\frac{n+1}{2}$ 直接输出无法构造。（因为初始数组元素均不相同）

而这些数的频率减一后，出现在更浅的结点的数就是倒数第二层的数。因此我们可以据此将数分为两类——只在最后一层出现的数和也在倒数第二层出现的数。

这两者的数量应该相等，且应当可以一一匹配，使得最后一层出现的数数值更大。

为此应该直接排序，小的配小的，大的配大的。如果其中出现了大小关系不满足要求的，直接认为不可能就行。

就此，我们去掉了最深一层的结点，也就转化为了规模更小的问题。不断进行上述过程，即可让深度缩小至最小值，进而得到答案。

时间复杂度为 $\mathcal{O}(n\log n)$ ，因为过程中需要进行排序。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    nums.sort()
    
    cnt = [0] * n
    
    for x in nums:
        cnt[bisect.bisect_left(nums, x)] += 1
    
    vals = [[] for _ in range(n)]
    c = 0
    
    for i in range(n):
        if cnt[i]:
            vals[i].append(nums[i])
            cnt[i] -= 1
            c += 1
    
    if 2 * c - 1 != n: print(-1)
    else:
        cur = (n + 1) // 2
        
        while cur > 1:
            p1 = [i for i in range(n) if cnt[i]]
            p2 = [i for i in range(n) if cnt[i] == 0 and vals[i]]
            
            if len(p1) != len(p2):
                exit(print(-1))
            
            for x, y in zip(p1, p2):
                if x > y: exit(print(-1))
                vals[x].extend(vals[y])
                vals[y].clear()
                cnt[x] -= 1
    
            cur = (cur + 1) // 2
        
        print(*vals[0])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;
	sort(nums.begin(), nums.end());

	vector<int> cnt(n, 0);
	for (auto &x: nums)
		cnt[lower_bound(nums.begin(), nums.end(), x) - nums.begin()] ++;

	vector<vector<int>> vals(n);
	int c = 0;

	for (int i = 0; i < n; i ++) {
		if (cnt[i]) {
			vals[i].emplace_back(nums[i]);
			cnt[i] --;
			c ++;
		}
	}

	if (2 * c - 1 != n) cout << -1;
	else {
		int cur = (n + 1) / 2;
		while (cur > 1) {
			vector<int> p1, p2;
			for (int i = 0; i < n; i ++) {
				if (vals[i].size()) {
					if (cnt[i]) p1.emplace_back(i);
					else p2.emplace_back(i);
				}
			}

			if (p1.size() != p2.size()) return cout << -1, 0;

			for (int i = 0; i < p1.size(); i ++) {
				int x = p1[i], y = p2[i];
				if (x > y) return cout << -1, 0;
				for (auto &v: vals[y]) vals[x].emplace_back(v);
				vals[y].clear();
				cnt[x] --;
			}

			cur = (cur + 1) / 2;
		}

		for (auto &v: vals[0]) cout << v << ' ';
	}

	return 0;
}
```
