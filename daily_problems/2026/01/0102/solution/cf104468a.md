**提示 1：** 如果数字出现 $3$ 次或者小于等于 $1$ 次都很容易处理。

**提示 2：** 如果出现两次呢？提出什么要求？

如果有数字出现了 $3$ 次，显然无法满足要求。

如果有数字只出现了 $0$ / $1$ 次，显然不影响答案。

否则，考虑出现两次的下标，以及是否在同一个数组。

如果在同一个数组，意味着两个下标有一个得反转；否则意味着要么都反转，要么都不反转。

这件事很容易理解为 2-SAT ，同时也可以用并查集来做。用 $i$ 表示 $i$ 位置不需要反转，用 $i+n$ 表示 $i$ 位置需要反转。

我们把所有需要满足的条件用边连起来，则同一个连通块内不能同时有 $i,i+n$ ，否则无法构造。

怎么最小化操作次数呢？我们每个连通块内选择最小反转数量就行。

时间复杂度为 $\mathcal{O}(n)$ ，如果你直接写 2-SAT 的话。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []

    for _ in range(t):
        n = II()
        pos = [[] for _ in range(2 * n + 1)]
        
        for i in range(n):
            x, y = MII()
            pos[x].append((i, 0))
            pos[y].append((i, 1))
        
        flg = True
        uf = UnionFind(2 * n)
        
        for i in range(2 * n + 1):
            if len(pos[i]) > 2:
                flg = False
            
            elif len(pos[i]) == 2:
                idx1, f1 = pos[i][0]
                idx2, f2 = pos[i][1]
                if f1 != f2:
                    uf.merge(idx1, idx2)
                    uf.merge(idx1 + n, idx2 + n)
                else:
                    uf.merge(idx1 + n, idx2)
                    uf.merge(idx1, idx2 + n)
        
        for i in range(n):
            if uf.find(i) == uf.find(i + n):
                flg = False
        
        if not flg: outs.append(-1)
        else:
            cnt = [0] * n
            cnt1 = [0] * n
            
            for i in range(2 * n):
                if uf.find(i) < n:
                    cnt[uf.find(i)] += 1
                    if i < n:
                        cnt1[uf.find(i)] += 1
            
            ans = 0
            for i in range(n):
                ans += fmin(cnt1[i], cnt[i] - cnt1[i])
            
            outs.append(ans)

    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<vector<pair<int, int>>> pos(2 * n + 1);

		for (int i = 0; i < n; i ++) {
			int x, y;
			cin >> x >> y;
			pos[x].emplace_back(i, 0);
			pos[y].emplace_back(i, 1);
		}

		bool flg = true;
		atcoder::dsu uf(2 * n);

		for (int i = 0; i <= 2 * n; i ++) {
			if (pos[i].size() > 2) flg = false;
			else if (pos[i].size() == 2) {
				auto [idx1, f1] = pos[i][0];
				auto [idx2, f2] = pos[i][1];
				if (f1 != f2) {
					uf.merge(idx1, idx2);
					uf.merge(idx1 + n, idx2 + n);
				}
				else {
					uf.merge(idx1, idx2 + n);
					uf.merge(idx1 + n, idx2);
				}
			}
		}

		for (int i = 0; i < n; i ++) {
			if (uf.leader(i) == uf.leader(i + n)) {
				flg = false;
			}
		}

		if (!flg) cout << -1 << '\n';
		else {
			vector<int> cnt(n, 0), cnt1(n, 0);
			for (int i = 0; i < 2 * n; i ++) {
				if (uf.leader(i) < n) {
					cnt[uf.leader(i)] ++;
					if (i < n) cnt1[uf.leader(i)] ++;
				}
			}

			int ans = 0;
			for (int i = 0; i < n; i ++)
				ans += min(cnt1[i], cnt[i] - cnt1[i]);
			
			cout << ans << '\n';
		}
	}

	return 0;
}
```
