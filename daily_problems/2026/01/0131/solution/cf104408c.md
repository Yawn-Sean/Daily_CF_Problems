**提示 1：** 考虑每个位置最少有多少次必要的翻转。

考虑第 $i$ 个位置和第 $i+1$ 个位置之间至少反转几次。

最后字符串一定要么使得 $i$ 和 $i+1$ 相等，要么反之。所以我们可以统计相等的次数，则至少需要操作 $\min(次数,n-次数)$ 。

同时考虑最后一个位置，最后要么同时是 $0$ ，要么同时是 $1$ ，因此统计下 $1$ 出现的次数就行。这一位需要操作的次数跟上述逻辑类似。

最后将每一位的结果求和即可。在满足最后一位相同，且相邻的相等关系一致的情况下，对应的最终字符串显然一致。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, m = MII()
        cnt = [0] * m
        
        for _ in range(n):
            s = I()
            
            if int(s[m - 1]):
                cnt[m - 1] += 1
            
            for i in range(m - 1):
                if s[i] != s[i + 1]:
                    cnt[i] += 1
        
        ans = 0
        for i in range(m):
            ans += fmin(cnt[i], n - cnt[i])
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, m;
		cin >> n >> m;

		vector<int> cnt(m, 0);

		for (int i = 0; i < n; i ++) {
			string s;
			cin >> s;

			if (s[m - 1] == '1') cnt[m - 1] ++;

			for (int j = 0; j < m - 1; j ++) {
				if (s[j] != s[j + 1]) {
					cnt[j] ++;
				}
			}
		}

		int ans = 0;
		for (auto &x: cnt) ans += min(x, n - x);
		cout << ans << '\n';
	}

	return 0;
}
```
