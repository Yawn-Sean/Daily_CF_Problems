**提示 1：** 有哪些情况？

**提示 2：** 选哪个圆弧？

首先，如果本身在一条线上，直接走线段就好。

否则，一定相隔 $90$ 度角。此时一定选择一条圆弧。

发现应该走内侧的点对应的圆弧。怎么证明呢？

考虑更内侧的，如果更往里走了 $x$ ，则少走了 $x\times\pi/2$ 的圆弧，多走了 $2x$ 的线段。

考虑更外侧的。如果比外侧的点还靠外，则显然可以往里走使得结果更优。而如果在外侧的点内侧，则无论如何线段部分总长不变，所以往里走会让圆弧部分尽可能短。

因此直接走内部圆弧再加一条线段就好。时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        x1, y1, x2, y2 = MII()
        
        if x1 == 0 and x2 == 0:
            outs.append(abs(y1 - y2))
        elif y1 == 0 and y2 == 0:
            outs.append(abs(x1 - x2))
        else:
            v1 = abs(x1) + abs(y1)
            v2 = abs(x2) + abs(y2)
            
            if v1 > v2:
                v1, v2 = v2, v1
            
            outs.append(math.pi / 2 * v1 + v2 - v1)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	long double pi = acosl(-1);

	cout << fixed << setprecision(10);

	while (t --) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;

		if (!x1 && !x2) cout << abs(y1 - y2) << '\n';
		else if (!y1 && !y2) cout << abs(x1 - x2) << '\n';
		else {
			int v1 = abs(x1) + abs(y1);
			int v2 = abs(x2) + abs(y2);

			if (v1 > v2) swap(v1, v2);

			cout << v1 * pi / 2 + v2 - v1 << '\n';
		}
	}

	return 0;
}
```
