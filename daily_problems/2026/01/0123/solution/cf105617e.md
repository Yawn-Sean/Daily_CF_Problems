**提示 1：** 如何快速求出最终的排列序列？

**提示 2：** 如何根据排列序列求我们需要的 LIS 长度？

首先恢复排列。

最能确定位置的元素是什么呢？是最后一个元素，因为其直接由最后一个数给出。

因此考虑从后往前遍历数组。我们相当于要找空缺位置的第 $i$ 个填入。这件事很容易通过树状数组二分 / 线段树二分实现，就规避了平衡树之类的东西。

接下来插入的过程就可以理解成一个个填入数字的过程了。

考虑插入一个数字时产生的包含这个数字的 LIS 如何。因为数字是从小到大进行插入的，所以我们只在意以前面的元素为最后一项的 LIS 的最大长度，这个答案加一就是包含这个数字的 LIS 长度。

于是直接用一个树状数组 / 线段树维护这个前缀最大值就好了。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    fen = FenwickTreeArray([1] * n)
    pos = [0] * n
    
    for i in range(n - 1, -1, -1):
        pos[i] = fen.bisect_min_larger(nums[i])
        fen.add(pos[i], -1)
    
    max_fen = MaxFenwickTree(n)
    ans = 0
    outs = []
    
    for i in range(n):
        res = max_fen.prefmax(pos[i]) + 1
        ans = fmax(ans, res)
        outs.append(ans)
        max_fen.set(pos[i], res)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int e1() {return 0;}

int op1(int x, int y) {return x + y;}

int e2() {return 0;}

int op2(int x, int y) {return max(x, y);}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<int> ar(n, 1);
	atcoder::segtree<int, op1, e1> seg(ar);

	vector<int> pos(n);
	for (int i = n - 1; i >= 0; i --) {
		pos[i] = seg.max_right(0, [&] (int x) {return x < nums[i];});
		seg.set(pos[i], 0);
	}

	atcoder::segtree<int, op2, e2> seg_max(n);
	int ans = 0;

	for (int i = 0; i < n; i ++) {
		int res = seg_max.prod(0, pos[i]) + 1;
		ans = max(ans, res);
		cout << ans << '\n';
		seg_max.set(pos[i], res);
	}

	return 0;
}
```
