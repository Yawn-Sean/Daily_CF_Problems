**提示 1：** 在 $k\leq n-2$ 时，操作可以很灵活。

**提示 2：** $k=n-1$ 咋办？

首先，我们可以做到将 $k$ 个元素 $+1$ ，另外一个元素 $-k$ 。具体而言，我们只需选取 $k+1$ 个元素，不停进行操作 2，除了一个元素外全部执行一遍 $+k$ 。

如果数组长度至少为 $k+2$ ，则我们可以做到让一个元素 $+1$ ，一个元素 $-1$ 。假设两个元素是 $i,j$ ，另选 $k$ 个位置 $v_1,v_2,\dots,v_k$ ，则我们可以：

1. 对 $v_1,v_2,\dots,v_{k-1},i$ 进行 $+1$ ，对 $v_k$ 进行 $-k$ 。

2. 对 $v_1,v_2,\dots,v_{k-1},j$ 进行 $-1$ ，对 $v_k$ 进行 $+k$ 。

这样合起来相当于 $i$ 位置 $+1$ ， $j$ 位置 $-1$ 。这个操作不影响数组的和，同时只要保证所有元素的和是 $n$ 的倍数，那么最终总是可以每个元素都相等的。所以只需不断执行第一个操作使得数组和是 $n$ 的倍数即可，为此只需统计数组的和。

否则，数组长度刚好为 $k+1$ 。此时所有元素每次都被操作。由于数组相对大小才是关键，所以直接把第二个操作看成选取一个元素加上 $k+1=n$ 。于是我们第一种操作应该调整每个元素使得它们关于 $n$ 取模结果一致。

于是分类统计每个取模结果的元素个数，可以快速得到让所有数都取模结果为 $i$ 的最小操作次数。

我们可以先统计取模结果都变成 $0$ 的操作次数。接下来考虑 $i$ 变成 $i+1$ ，一般的数需要多操作 $1$ 次，而取模结果为 $i+1$ 的数可以少操作 $n-1$ 次，根据这件事进行更新即可，具体可见代码。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, k = MII()
        nums = LII()
        
        if k != n - 1:
            outs.append((-sum(nums)) % n)
        else:
            cnt = [0] * n
            for x in nums:
                cnt[(-x) % n] += 1
            
            cur = sum(i * cnt[i] for i in range(n))
            ans = cur
            
            for i in range(n):
                cur += n * cnt[i]
                cur -= n
                ans = fmin(ans, cur)
            
            outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, k;
		cin >> n >> k;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		if (k < n - 1) {
			int val = 0;
			for (auto &v: nums) val = (val + v) % n;
			cout << (n - val) % n << '\n';
		}
		else {
			vector<int> cnt(n);
			for (auto &v: nums)	cnt[(n - v % n) % n] ++;

			long long cur = 0;
			for (int i = 0; i < n; i ++) cur += 1ll * i * cnt[i];

			long long ans = cur;
			for (int i = 0; i < n; i ++) {
				cur += 1ll * n * cnt[i];
				cur -= n;
				ans = min(ans, cur);
			}

			cout << ans << '\n';
		}
	}

	return 0;
}
```
