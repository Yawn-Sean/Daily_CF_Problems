**提示 1：** 如果 $k$ 足够大？

**提示 2：** 如果 $k$ 小怎么让调整的次数尽可能少？

首先，两个方向的步数是唯一重要的信息，先算出来。

在一个方向走 $x$ 步时，另一个方向最多走了 $(x+1)\times k$ 步（就是把 $x$ 步当中间的分割点，总共有 $x+1$ 段，每段长度是 $k$ ）。

所以如果给出的两个方向的步长差别不大，可以在上述范围内，就只需走两个方向的步数。

否则需要付出一些额外的步数来调整步数较多的那个方向。如果相对上述的基准多出了 $v$ 步，则怎么调整呢？我们应该先朝另一个方向走一步，再走 $k$ 步，走回来，再走 $k$ 步，以此类推。无论怎样，只要走了一个循环的一部分，就会多出两步。所以此时新增的步数是 $v$ 除以 $2k$ 的上取整，再乘 $2$ 。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        sx, sy, tx, ty, k = MII()
        dx = abs(sx - tx)
        dy = abs(sy - ty)
        
        if dx < dy: dx, dy = dy, dx
        
        if dx <= (dy + 1) * k:
            outs.append(dx + dy)
        else:
            other = (dx - (dy + 1) * k + 2 * k - 1) // (2 * k) * 2
            outs.append(dx + dy + other)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		long long sx, sy, tx, ty, k;
		cin >> sx >> sy >> tx >> ty >> k;

		long long dx = abs(sx - tx), dy = abs(sy - ty);
		if (dx < dy) swap(dx, dy);

		if (dx <= (dy + 1) * k) cout << dx + dy << '\n';
		else cout << dx + dy + (dx - (dy + 1) * k + 2 * k - 1) / (2 * k) * 2 << '\n';
	}

	return 0;
}
```
