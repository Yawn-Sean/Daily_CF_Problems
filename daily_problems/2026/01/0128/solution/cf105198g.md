**提示 1：** 先让所有行、列、对角线的和相等，再想办法让每条线都加一个相同的数。

**提示 2：** 特殊情况构造？

因为条件比较多，而自由度也比较高，所以我们不妨强加限制，让我们的构造更有方向。

我们想办法构造一个方案，使得行、列、对角的和都相等。

此时，基准就是一个全都是 $1$ 的矩阵，接下来我们就只要挑选几个位置加数值，使得行、列、对角仍然相等。我们尝试的构造就是让每行、列和对角线都只选择一个位置，加上固定的一个数 $v$ 。这部分的构造可以尽可能让你的构造有规律一些，比如说沿着某条斜线走。如果实在没有想到的话可以打印一下题解的构造。

发现 $n\leq 3$ 的情况比较特殊，但是手动构造也都很容易。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    
    if n == 3:
        print(1, 1, 2)
        print(1, 4, 3)
        print(2, 3, 3)
    else:
        ans = [[1] * n for _ in range(n)]
        
        if n > 2:
            v = 1024 - n
            if n % 2 == 0:
                ans[0][0] += v
                for i in range(1, n - 1):
                    ans[i][i + 1] += v
                ans[n - 1][1] += v
            else:
                ans[0][0] += v
                ans[1][n - 2] += v
                for i in range(2, n - 2):
                    ans[i][i - 1] += v
                ans[n - 2][n - 1] += v
                ans[n - 1][n - 3] += v
        
        print('\n'.join(' '.join(map(str, x)) for x in ans))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	if (n == 3) {
		cout << "1 1 2\n";
		cout << "1 4 3\n";
		cout << "2 3 3\n";
	}
	else {
		vector<vector<int>> ans(n, vector<int>(n, 1));
		int v = 1024 - n;

		if (n > 2) {
			if (n & 1) {
				ans[0][0] += v;
				ans[1][n - 2] += v;
				for (int i = 2; i < n - 2; i ++)
					ans[i][i - 1] += v;
				ans[n - 2][n - 1] += v;
				ans[n - 1][n - 3] += v;
			}
			else {
				ans[0][0] += v;
				for (int i = 1; i < n - 1; i ++)
					ans[i][i + 1] += v;
				ans[n - 1][1] += v;
			}
		}

		for (auto &x: ans) {
			for (auto &y: x) cout << y << ' ';
			cout << '\n';
		}
	}

	return 0;
}
```
