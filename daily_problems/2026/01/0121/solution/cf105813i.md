**提示 1：** 整个带子很长的时候，其实胜负已定。

**提示 2：** 其他情况如何分类讨论进行覆盖？

首先，整个条很长的时候，先手会留下至少一段很长的，而后手只需分割这一段，产生长度刚好是 $b$ 的一段就能保证自己必胜。

所以 $n\gt a+2\times(2b-1)$ 时，Alice 第一次操作后，两侧至少有一段不短于 $2b$ ，此时 Bob 总可以留出长度恰好为 $b$ 的一段，这段 Alice 没法操作，因此 Bob 必胜。

接下来就讨论长度比较短的情况。

一种情况是， Alice 操作后可以使得 Bob 没法操作。这种情况是 $n\leq a+2(b-1)$ 。

排除上面的情况，Alice 操作后，如果 Bob 能操作以使得 Alice 没法进一步操作呢？事实上，此时 $n\lt 3a$ ，在 Alice 操作过后，两侧最多只有一侧长度不止 $a$ ，同时严格短于 $2a$ ，此时 Bob 只要占走这一段中间的位置，就可以两侧的长度都严格短于 $a$ 了，此时 Bob 必胜。

对于剩下的情况，我们让 Alice 先手占据中间位置，此时两侧长度不超过 $2b-1$ （看最早讨论的情况），同时不短于 $a$ （看刚刚讨论的情况）。因此无论 Bob 选择哪一侧，Alice 都可以在另一侧操作。同时两种操作都会使得长度不小于 $b$ 的段减少一个。因此这时 Bob 没法操作了，Alice 获胜。

分类讨论上述情况即可。

时间复杂度显然是 $\mathcal{O}(1)$ 。注意这里直接使用 int 会爆。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        a, b, n = MII()
        
        if n > a + 2 * (2 * b - 1): outs.append('Bob')
        elif n <= a + 2 * (b - 1): outs.append('Alice')
        elif n < 3 * a: outs.append('Bob')
        else: outs.append('Alice')
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int a, b, n;
		cin >> a >> b >> n;
		if (n > a + 2ll * (2 * b - 1)) cout << "Bob\n";
		else if (n <= a + 2ll * (b - 1)) cout << "Alice\n";
		else if (n < 3ll * a) cout << "Bob\n";
		else cout << "Alice\n";
	}

	return 0;
}
```
