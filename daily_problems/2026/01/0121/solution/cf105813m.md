**提示 1：** 让其他子序列都早早出现，给那个不能出现的留空间。

我们只需所有 $n$ 位的序列， $00\dots 0,00\dots 1,\dots, 99\dots 9$ 都出现，除了 $s$ ，则一定满足要求。

怎么处理呢？可以想办法让别的子序列都早出现，那么最后剩下的 $s$ 只需要把最后一个字符删掉就行了。

如果某一位是 $x$ ，我们可以用 $(0-9去掉x)(0-9去掉x)x$ 作为一段，这样，如果这一位是 $x$ 就只能匹配上一个位置，否则，可以用前面的一段匹配一个数字，后面的 $(0-9去掉x)x$ 匹配另一个数字。

于是我们这样构造 $n$ 段，再去掉最后一个字符，就能保证 $s$ 不出现。同时对于其他字符串，因为要么前面 $n-1$ 段中至少有一段匹配了两个位置，要么最后一段不等于 $s$ 的最后一位可以匹配，因此总是构造的序列的子序列。

整体是分层进行筛选，让已经不同的那些子序列早早匹配进而淘汰。

注意不能有前导 $0$ ，所以可以调整下前面的字符的顺序。

时间复杂度为 $\mathcal{O}(n|\Sigma|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    
    for _ in range(t):
        s = [int(c) for c in I()]
        ans = []
        
        for c in s:
            for _ in range(2):
                for x in digits:
                    if x != c:
                        ans.append(x)
            ans.append(c)
        
        ans.pop()
        outs.append(''.join(map(str, ans)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	string digit = "1234567890";

	int t;
	cin >> t;

	while (t --) {
		string s;
		cin >> s;

		int n = s.size();
		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < 2; j ++) {
				for (auto &c: digit) {
					if (s[i] != c) cout << c;
				}
			}
			if (i != n - 1) cout << s[i];
		}
		
		cout << '\n';
	}

	return 0;
}
```
