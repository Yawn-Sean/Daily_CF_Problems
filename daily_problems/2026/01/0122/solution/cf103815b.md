**提示 1：** 如果能快速判断一个区间是否满足要求，如何解决这个问题？

**提示 2：** 我们可以预处理什么来快速判断一个区间是否满足要求呢？

如果对于一个区间 $[l,r]$ 我们能快速检查是否满足要求，则我们可以枚举相同长度的段的长度。对于长度 $x$ ，我们需要检查 $\mathcal{O}(\frac{n}{x})$ 个区间，对于不同的 $n$ 求和，结果是 $\mathcal{O}(n\log n)$ ，来源于调和级数。

所以我们只需预处理方便后续判断一个区间是否是山峰的就行。

我们可以预处理每个位置结束的最长的非递增序列的长度，以及每个位置开始的最长的非递减序列的长度。

如何维护这个数值呢？如果是 $-1$ 直接相较于之前的结果加一就行。否则，考虑前一个出现的非 $-1$ 的数字，如果符合递增 / 递减的要求则加一，否则维护的数值是前面出现的连续的 $-1$ 的个数加一。

接下来判断。首先数组长度不小于 $3$ ，同时前缀最长非递减序列长度加上后缀最长非递增序列长度应该得覆盖整个区间，也就是不短于区间长度。同时山峰不能严格在端点处，所以两侧维护的数值都至少为 $2$ 。（这里判断的条件还是比较多的）

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    inc_length = [1] * n
    pos = -1
    
    for i in range(n - 1, -1, -1):
        if nums[i] > 0:
            if pos != -1:
                if nums[i] > nums[pos]: inc_length[i] = pos - i
                else: inc_length[i] = inc_length[i + 1] + 1
            pos = i
        elif i != n - 1:
            inc_length[i] = inc_length[i + 1] + 1
    
    dec_length = [1] * n
    pos = -1
    
    for i in range(n):
        if nums[i] > 0:
            if pos != -1:
                if nums[i] > nums[pos]: dec_length[i] = i - pos
                else: dec_length[i] = dec_length[i - 1] + 1
            pos = i
        elif i > 0:
            dec_length[i] = dec_length[i - 1] + 1
    
    for i in range(3, n + 1):
        flg = True
        for j in range(0, n, i):
            l = j
            r = fmin(j + i - 1, n - 1)
            if inc_length[l] + dec_length[r] < r - l + 2 or r - l + 1 < 3 or inc_length[l] < 2 or dec_length[r] < 2:
                flg = False
        if flg:
            print('Y')
            break
    else:
        print('N')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<int> inc_length(n, 1), dec_length(n, 1);
	int pos;

	pos = -1;
	for (int i = n - 1; i >= 0; i --) {
		if (nums[i] > 0) {
			if (pos != -1) {
				if (nums[i] > nums[pos]) inc_length[i] = pos - i;
				else inc_length[i] = inc_length[i] = inc_length[i + 1] + 1;
			}
			pos = i;
		}
		else if (i != n - 1) inc_length[i] = inc_length[i + 1] + 1;
	}

	pos = -1;
	for (int i = 0; i < n; i ++) {
		if (nums[i] > 0) {
			if (pos != -1) {
				if (nums[i] > nums[pos]) dec_length[i] = i - pos;
				else dec_length[i] = dec_length[i] = dec_length[i - 1] + 1;
			}
			pos = i;
		}
		else if (i) dec_length[i] = dec_length[i - 1] + 1;
	}

	bool total_flg = false;
	for (int i = 3; i <= n; i ++) {
		bool flg = true;
		for (int j = 0; j < n; j += i) {
			int l = j, r = min(j + i - 1, n - 1);
			if (inc_length[l] + dec_length[r] < r - l + 2 || r - l + 1 < 3 || inc_length[l] < 2 || dec_length[r] < 2) flg = false;
		}
		total_flg |= flg;
	}

	cout << (total_flg ? "Y" : "N");

	return 0;
}
```
