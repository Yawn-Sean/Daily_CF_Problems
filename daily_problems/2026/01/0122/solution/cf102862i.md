**提示 1：** 我们要求的是什么东西？

**提示 2：** 如何维护数据结构求它？

假设最后能产生 $0\sim x$ 中所有的数而不出现 $x+1$ ，则 $0\sim x$ 中所有数的频率的和应该不小于 $x+1$ ，因为比 $x+1$ 更大的数没办法影响到这里，最后 $0\sim x$ 的频率都至少为 $1$ 。

于是我们的答案满足 $0\sim x$ 的频率之和不小于 $x+1$ 。我们取满足这个条件的最大的 $x$ 。这样的 $x$ 一定能成为 MEX 吗？答案是肯定的，我们只需把所有频率超过 $1$ 的都先往 $x-1$ 的方向移动，最后再往 $x+1$ 方向移动就行了。

怎么维护结构来做这件事呢？我们要 $\sum\limits_{i=0}^x cnt[i]\geq x+1$ ，两侧都有变量不好，所以用：

$\sum\limits_{i=0}^x (cnt[i]-1)\geq 0$

所以我们要维护的就是 $cnt[i]-1$ 的前缀和。更新的是某个位置 $i$ 时，相当于对 $i$ 之后的位置进行前缀和的更新，用懒更新线段树很容易维护。

如何找到最后的大于等于 $0$ 的位置呢？此时后面的位置都小于 $-1$ ，所以可以维护区间最大值，使用线段树二分找到最后的满足 $[i,M]$ 的最大值不超过 $-1$ 的位置即可。

时间复杂度为 $\mathcal{O}(q\log q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 10 ** 6
    seg = LazySegTree(fmax, -1, add, add, 0, [-i - 1 for i in range(M + 1)])
    
    q = II()
    outs = []
    
    for _ in range(q):
        t, x = MII()
        if t == 1: seg.apply(x, M + 1, 1)
        else: seg.apply(x, M + 1, -1)
        outs.append(seg.min_left(M + 1, lambda x: x < 0))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int e() {return -1;}

int op(int x, int y) {return max(x, y);}

int add(int x, int y) {return x + y;}

int id() {return 0;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e6;
	vector<int> ar(M + 1);
	for (int i = 0; i <= M; i ++) ar[i] = -i - 1;
	atcoder::lazy_segtree<int, op, e, int, add, add, id> seg(ar);

	int q;
	cin >> q;

	while (q --) {
		int t, x;
		cin >> t >> x;
		if (t == 1) seg.apply(x, M + 1, 1);
		else seg.apply(x, M + 1, -1);
		cout << seg.min_left(M + 1, [&] (int x) {return x < 0;}) << '\n';
	}

	return 0;
}
```
