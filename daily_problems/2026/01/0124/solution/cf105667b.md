**提示 1：** 找到一个好判断的标准。

事实上一个连通块如果不是蛇，有很容易判断的条件，其一定存在 $1\times 3$ / $2\times 2$ 的子连通块。

为什么呢？考虑一个连通块，如果没有 $1\times 3$ / $2\times 2$ 的子连通块，如果其大小为 $1$ 显然成立；否则已经有两个块了，接下来从这两个块延伸出去，很容易证明只能是阶梯型的。

所以我们只需判断子矩阵中是否有 $1\times 3$ （当然可以竖着）/ $2\times 2$ 的子矩阵是相同的数字。

我们只需在矩阵的左上角打标记，最后相当于查询一个矩形内是否完全没被标记，也就是标记的数的和是否严格大于 $0$ ，这件事可以预处理二位前缀和，后续查询达到。

时间复杂度为 $\mathcal{O}(nm+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    grid = [LII() for _ in range(n)]
    
    acc_13 = [[0] * (m + 1) for _ in range(n + 1)]
    acc_22 = [[0] * (m + 1) for _ in range(n + 1)]
    acc_31 = [[0] * (m + 1) for _ in range(n + 1)]
    
    for i in range(n):
        for j in range(m - 2):
            if grid[i][j] == grid[i][j + 1] and grid[i][j] == grid[i][j + 2]:
                acc_13[i + 1][j + 1] = 1
    
    for i in range(n - 1):
        for j in range(m - 1):
            if grid[i][j] == grid[i][j + 1] and grid[i][j] == grid[i + 1][j] and grid[i][j] == grid[i + 1][j + 1]:
                acc_22[i + 1][j + 1] = 1
    
    for i in range(n - 2):
        for j in range(m):
            if grid[i][j] == grid[i + 1][j] and grid[i][j] == grid[i + 2][j]:
                acc_31[i + 1][j + 1] = 1
    
    for i in range(n + 1):
        for j in range(m):
            acc_13[i][j + 1] += acc_13[i][j]
            acc_22[i][j + 1] += acc_22[i][j]
            acc_31[i][j + 1] += acc_31[i][j]
    
    for i in range(n):
        for j in range(m + 1):
            acc_13[i + 1][j] += acc_13[i][j]
            acc_22[i + 1][j] += acc_22[i][j]
            acc_31[i + 1][j] += acc_31[i][j]
    
    q = II()
    outs = []
    
    for _ in range(q):
        x1, y1, x2, y2 = MII()
        
        flg = True
        
        if y2 >= y1 + 2 and acc_13[x1][y1] - acc_13[x2 + 1][y1] - acc_13[x1][y2 - 1] + acc_13[x2 + 1][y2 - 1]:
            flg = False
        
        if x2 > x1 and y2 > y1 and acc_22[x1][y1] - acc_22[x2][y1] - acc_22[x1][y2] + acc_22[x2][y2]:
            flg = False
        
        if x2 >= x1 + 2 and acc_31[x1][y1] - acc_31[x2 - 1][y1] - acc_31[x1][y2 + 1] + acc_31[x2 - 1][y2 + 1]:
            flg = False
        
        outs.append('YES' if flg else 'NO')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<vector<int>> grid(n, vector<int>(m));
	for (auto &x: grid) for (auto &y: x) cin >> y;

	vector<vector<int>> acc_13(n + 1, vector<int>(m + 1, 0));
	vector<vector<int>> acc_22(n + 1, vector<int>(m + 1, 0));
	vector<vector<int>> acc_31(n + 1, vector<int>(m + 1, 0));

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j + 2 < m; j ++) {
			if (grid[i][j] == grid[i][j + 1] && grid[i][j] == grid[i][j + 2]) {
				acc_13[i + 1][j + 1] = 1;
			}
		}
	}

	for (int i = 0; i + 1 < n; i ++) {
		for (int j = 0; j + 1 < m; j ++) {
			if (grid[i][j] == grid[i + 1][j] && grid[i][j] == grid[i][j + 1] && grid[i][j] == grid[i + 1][j + 1]) {
				acc_22[i + 1][j + 1] = 1;
			}
		}
	}

	for (int i = 0; i + 2 < n; i ++) {
		for (int j = 0; j < m; j ++) {
			if (grid[i][j] == grid[i + 1][j] && grid[i][j] == grid[i + 2][j]) {
				acc_31[i + 1][j + 1] = 1;
			}
		}
	}

	for (int i = 0; i < n; i ++) {
		for (int j = 0; j <= m; j ++) {
			acc_13[i + 1][j] += acc_13[i][j];
			acc_22[i + 1][j] += acc_22[i][j];
			acc_31[i + 1][j] += acc_31[i][j];
		}
	}

	for (int i = 0; i <= n; i ++) {
		for (int j = 0; j < m; j ++) {
			acc_13[i][j + 1] += acc_13[i][j];
			acc_22[i][j + 1] += acc_22[i][j];
			acc_31[i][j + 1] += acc_31[i][j];
		}
	}

	int q;
	cin >> q;

	while (q --) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;

		bool flg = true;

		if (y2 >= y1 + 2 && acc_13[x1][y1] - acc_13[x2 + 1][y1] - acc_13[x1][y2 - 1] + acc_13[x2 + 1][y2 - 1]) flg = false;
		if (x2 > x1 && y2 > y1 && acc_22[x1][y1] - acc_22[x2][y1] - acc_22[x1][y2] + acc_22[x2][y2]) flg = false;
		if (x2 >= x1 + 2 && acc_31[x1][y1] - acc_31[x2 - 1][y1] - acc_31[x1][y2 + 1] + acc_31[x2 - 1][y2 + 1]) flg = false;

		cout << (flg ? "YES" : "NO") << '\n';
	}

	return 0;
}
```
