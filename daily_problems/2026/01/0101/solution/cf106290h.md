**提示 1：** 考虑每个数值对答案的贡献。

**提示 2：** 枚举右端点。

每个数值一定要么在子数组内，要么在子数组外，要么两遍都有。所以对答案的贡献只可能是 $1$ 或者 $2$ 。

我们就要最大化贡献是 $2$ 的元素的个数，也就是既出现在子数组内，又出现在子数组外。

考虑对于某个元素 $x$ 而言，如果右端点为 $r$ ，可能的左端点是哪些。

如果 $r$ 左侧没有任何 $x$ ，则没有合法的左端点。

如果 $r$ 右侧还有 $x$ ，则在 $x$ 前一次出现（包含这个位置）之前的所有左端点位置都是合法的。

如果 $r$ 右侧没有 $x$ ，那么左端点一定只能在 $x$ 的第一次出现和最后一次出现之间（不含第一次，包含最后一次）。

我们对于某个 $x$ ，在这些区间进行 $+1$ 操作，最后查询数组最大值也就是挑选最优的左端点。

而在我们从小到大枚举右端点的过程中，对于某一个固定的 $r$ ，只有关于 $nums[r]$ 的信息改变了，所以每遍历一个位置只需修改 $\mathcal{O}(1)$ 次。而上述是区间加减，查询最大的操作，所以很容易用懒更新线段树维护。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        first_pos = [-1] * (n + 1)
        last_pos = [-1] * (n + 1)
        prev = [0] * n
        
        for i in range(n):
            prev[i] = last_pos[nums[i]]
            last_pos[nums[i]] = i
            if first_pos[nums[i]] == -1:
                first_pos[nums[i]] = i
        
        ans = 0
        seg = LazySegTree(fmax, 0, add, add, 0, n)
        
        for i in range(n + 1):
            if last_pos[i] != -1:
                ans += 1
        
        to_add = 0
        
        for i in range(n):
            if last_pos[nums[i]] != i:
                seg.apply(prev[i] + 1, i + 1, 1)
            elif prev[i] != -1:
                seg.apply(0, prev[i] + 1, -1)
                seg.apply(first_pos[nums[i]] + 1, last_pos[nums[i]] + 1, 1)
            to_add = fmax(to_add, seg.all_prod())
        
        outs.append(ans + to_add)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		vector<int> first_pos(n + 1, -1), last_pos(n + 1, -1), prev(n);

		for (int i = 0; i < n; i ++) {
			prev[i] = last_pos[nums[i]];
			last_pos[nums[i]] = i;

			if (first_pos[nums[i]] == -1)
				first_pos[nums[i]] = i;
		}

		int ans = 0;
		atcoder::lazy_segtree<int, op, e, int, mapping, composition, id> seg(n);

		for (int i = 0; i <= n; i ++) {
			if (last_pos[i] != -1) {
				ans ++;
			}
		}

		int to_add = 0;

		for (int i = 0; i < n; i ++) {
			if (last_pos[nums[i]] != i) seg.apply(prev[i] + 1, i + 1, 1);
			else {
				seg.apply(0, prev[i] + 1, -1);
				seg.apply(first_pos[nums[i]] + 1, last_pos[nums[i]] + 1, 1);
			}
			to_add = max(to_add, seg.all_prod());
		}

		cout << ans + to_add << '\n';
	}

	return 0;
}
```
