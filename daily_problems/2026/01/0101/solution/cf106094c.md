**提示 1：** 如果有个数，它的权是 $k$ ，则需要满足什么条件？

**提示 2：** 一步一步凑。

如果一个数能被开根号 $k$ 次最后仍然是整数，则从最后的数出发，需要平方 $k$ 次，所以每个质因子的系数都需要是 $2^k$ 的倍数。

因此我们先将原数质因数分解，再一遍遍扩大 $k$ ，看最小的操作次数是否超过可操作次数。

时间复杂度为 $\mathcal{O}(\log n\log k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 2 * 10 ** 5
    pr = list(range(M + 1))
    
    for i in range(2, M + 1):
        if pr[i] == i:
            for j in range(i, M + 1, i):
                pr[j] = i
    
    t = II()
    outs = []
    
    for _ in range(t):
        x, k = MII()
        
        cnt = []
        while x > 1:
            p = pr[x]
            c = 0
            while x % p == 0:
                x //= p
                c += 1
            cnt.append(c)
    
        ans = 0
        cur = 2
        v = 1
        while True:
            tmp = 0
            for i in range(len(cnt)):
                val = (cnt[i] + cur - 1) // cur
                tmp += val * cur - cnt[i]
                cnt[i] = val * cur
            
            if tmp > k: break
            
            ans = v
            
            k -= tmp
            cur *= 2
            v += 1
    
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 2e5;
	vector<int> pr(M + 1);
	iota(pr.begin(), pr.end(), 0);

	for (int i = 2; i <= M; i ++) {
		if (pr[i] == i) {
			for (int j = i; j <= M; j += i) {
				pr[j] = i;
			}
		}
	}

	int t;
	cin >> t;

	while (t --) {
		int x;
		long long k;
		cin >> x >> k;

		vector<long long> cnt;
		while (x > 1) {
			int p = pr[x];
			long long c = 0;

			while (x % p == 0) {
				x /= p;
				c ++;
			}

			cnt.emplace_back(c);
		}

		int ans = 0, v = 1;
		long long cur = 2;

		while (true) {
			long long tmp = 0;
			for (auto &x: cnt) {
				long long val = (x + cur - 1) / cur;
				tmp += val * cur - x;
				x = val * cur;
			}

			if (tmp > k) break;
			ans = v;

			k -= tmp;
			cur *= 2;
			v ++;
		}

		cout << ans << '\n';
	}

	return 0;
}
```
