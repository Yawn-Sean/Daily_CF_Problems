**提示 1：** 考虑构造方案。奇数轮怎么做？偶数轮怎么做？

奇数轮的时候，如果有一个项是 $1$ ，显然应该干掉他，因为之后也只能在奇数轮做。

偶数轮，其实可以任选，效果都是一样的。

按照这个逻辑贪心模拟即可。如果按照这个贪心策略无法构造则不可行。

当然，这题更难的出法其实是只判断能不能做。有这样的条件：

- 首先，总数量不能是偶数，不然最后一次必须是偶数轮，同时这个数又是 $1$ ，矛盾了。

- 同时考虑偶数轮需要干掉的人数至多为 $\max(x-1,0)$ 的和，奇数轮数量的最大值是 $\sum x$ 减去上述数值。而奇数轮不能比偶数轮 $+1$ 还大。

时间复杂度为 $\mathcal{O}(n)$ （如果你用了排序当然就多个对数了）。

这也提示了我们有些时候判定问题未必比构造更简单。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        op_total = sum(nums)
        op_step2 = sum(fmax(v - 1, 0) for v in nums)
        
        if op_total % 2 == 0: outs.append('NO')
        elif op_step2 < op_total - op_step2 - 1: outs.append('NO')
        else:
            outs.append('YES')
            
            st_range = sorted([i for i in range(n) if nums[i]], key=lambda x: nums[x])
            
            ones = []
            ops = []
            
            pt = 0
            flg = 1
            k = len(st_range)
            
            for _ in range(sum(nums)):
                while pt < k and nums[st_range[pt]] == 1:
                    ones.append(st_range[pt])
                    pt += 1
                
                if flg and ones:
                    idx = ones.pop()
                    nums[idx] -= 1
                    ops.append(idx)
                else:
                    nums[st_range[pt]] -= 1
                    ops.append(st_range[pt])
                
                flg ^= 1
            
            outs.append(' '.join(str(x + 1) for x in ops))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		int op_total = 0, op_step2 = 0;

		for (auto &v: nums) {
			op_total += v;
			op_step2 += max(v - 1, 0);
		}

		if (op_total % 2 == 0) cout << "NO\n";
		else if (op_step2 < op_total - op_step2 - 1) cout << "NO\n";
		else {
			cout << "YES\n";

			vector<int> order;
			for (int i = 0; i < n; i ++) {
				if (nums[i]) {
					order.emplace_back(i);
				}
			}

			sort(order.begin(), order.end(), [&] (int i, int j) {return nums[i] < nums[j];});

			vector<int> ones;
			int pt = 0, flg = 1, k = order.size();

			while (op_total --) {
				while (pt < k && nums[order[pt]] == 1) {
					ones.emplace_back(order[pt]);
					pt ++;
				}

				if (flg && !ones.empty()) {
					int idx = ones.back(); ones.pop_back();
					nums[idx] --;
					cout << idx + 1 << ' ';
				}
				else {
					nums[order[pt]] --;
					cout << order[pt] + 1 << ' ';
				}
				flg ^= 1;
			}

			cout << '\n';
		}
	}

	return 0;
}
```
