**提示 1：** 如果我们选择了一些要用的武器，我们应该按照什么顺序使用它们呢？

**提示 2：** 接下来就是取子序列的问题了。

考虑交换两次操作 $(a_1,b_1,c_1)$ 和 $(a_2,b_2,c_2)$ ，总伤害为 $c_1+c_2$ 保持不变，而健康值会从 $V$ 如何变化呢？

前者是 $\left\lfloor\frac{\left\lfloor\frac{V-b_1}{a_1}\right\rfloor-b_2}{a_2}\right\rfloor=\left\lfloor\frac{V-b_1-a_1b_2}{a_1a_2}\right\rfloor$ （这一步去掉取整符号，可以考虑成分子最多多了一个严格小于 $1$ 的小数，不影响最后取整结果），后者是 $\left\lfloor\frac{V-b_2-a_2b_1}{a_1a_2}\right\rfloor$ ，所以操作的顺序一定是根据 $b_1+a_1b_2,b_2+a_2b_1$ 的大小关系决定的。

根据这个大小关系进行排序，则我们一定按照标号从小到大的顺序使用各个武器。这样我们就可以用子序列相关 DP 的基本做法来完成了，即到第 $i$ 个位置且健康值为 $V'$ 时能产生的最大伤害，状态转移的过程中，枚举此时是否使用武器即可。同时使用 $(a,b,c)$ 武器时，需要健康值不小于 $b$ 。

最后取数组中的最大伤害。

时间复杂度为 $\mathcal{O}(n\log n+nP)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, p = MII()
    weapons = [tuple(MII()) for _ in range(n)]
    
    def cmp(weapon1, weapon2):
        a1, b1, c1 = weapon1
        a2, b2, c2 = weapon2
        
        v1 = b1 + a1 * b2
        v2 = b2 + a2 * b1
        
        if v1 < v2: return -1
        if v1 > v2: return 1
        return 0
    
    weapons.sort(key=cmp_to_key(cmp))
    
    dp = [0] * (p + 1)
    
    for a, b, c in weapons:
        for i in range(b, p + 1):
            dp[(i - b) // a] = fmax(dp[(i - b) // a], dp[i] + c)
    
    print(max(dp))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, p;
	cin >> n >> p;

	vector<array<int, 3>> weapons(n);
	for (auto &[a, b, c]: weapons) cin >> a >> b >> c;

	sort(weapons.begin(), weapons.end(), [&] (array<int, 3> x, array<int, 3> y) {
		return 1ll * x[0] * y[1] + x[1] < 1ll * y[0] * x[1] + y[1];
	});

	vector<long long> dp(p + 1, 0);

	for (auto &[a, b, c]: weapons) {
		for (int i = b; i <= p; i ++) {
			dp[(i - b) / a] = max(dp[(i - b) / a], dp[i] + c);
		}
	}

	cout << *max_element(dp.begin(), dp.end());

	return 0;
}
```
