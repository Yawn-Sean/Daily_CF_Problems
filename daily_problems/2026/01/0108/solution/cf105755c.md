**提示 1：** 选取的数需要满足的条件是什么？

**提示 2：** 设计 DP 状态。如何快速找到所有可行的转移？

考虑 $\max(x,y)\lt x\oplus y$ ，需要满足什么条件呢？不妨 $x\leq y$ ，则需要 $x$ 最高位的位置 $y$ 刚好是 $0$ 。

所以不妨从小到大取所有的数，则之前出现过的最高位在之后选取的数中不能再出现。

于是很自然地想到 $dp[msk]$ 表示当前最高位选取情况是 $msk$ 的情况下的最多选取数字个数。

考虑转移。从 $msk$ 出发，哪些是合法的转移呢？如果我们得到了合法的转移，则每个状态的转移最多只有 $\mathcal{O}(\log M)$ 个，就可以快速解决问题了。

对于某个 $msk$ ，哪些 $val$ 的转移会影响到它呢？对于某个 $val$ 而言，此前选取的 $msk$ 需要满足是 $val$ 中 $0$ 构成的位集合 $S$ 的子集，而转移到的状态是 $msk+val的最高位$ 。

所以我们可以预处理，在所有 $S$ 的位置打标记 $val的最高位$ ，然后可以用 $\mathcal{O}(M\log M)$ 的方式，将这些标记传递到所有自己中，这样所有的状态转移就被记录下来了。

时间复杂度为 $\mathcal{O}(n+M\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    vis = [0] * (1 << 22)
    
    for x in nums:
        bit = x.bit_length()
        v = (1 << bit) - 1
        vis[v ^ x] |= 1 << bit - 1
    
    for i in range(22):
        for j in range(1 << 22):
            if j >> i & 1:
                vis[j ^ (1 << i)] |= vis[j]
    
    dp = [0] * (1 << 22)
    
    for i in range(1 << 22):
        for j in range(22):
            if vis[i] >> j & 1:
                ni = i | (1 << j)
                dp[ni] = fmax(dp[ni], dp[i] + 1)
    
    print(max(dp))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    vector<int> vis(1 << 22, 0);
    for (auto &x: nums) {
        int bit = 32 - __builtin_clz(x);
        vis[((1 << bit) - 1) ^ x] |= 1 << (bit - 1);
    }

    for (int i = 0; i < 22; i ++) {
        for (int j = 0; j < 1 << 22; j ++) {
            if (j >> i & 1) {
                vis[j ^ (1 << i)] |= vis[j];
            }
        }
    }

    vector<int> dp(1 << 22, 0);
    for (int i = 0; i < 1 << 22; i ++) {
        for (int j = 0; j < 22; j ++) {
            if (vis[i] >> j & 1) {
                int ni = i | (1 << j);
                dp[ni] = max(dp[ni], dp[i] + 1);
            }
        }
    }

    cout << *max_element(dp.begin(), dp.end());

	return 0;
}
```
