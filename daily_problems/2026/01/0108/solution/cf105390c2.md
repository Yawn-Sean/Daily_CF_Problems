**提示 1：** 博弈部分，策略如何？

**提示 2：** 如何最大化子数组数量？

首先，如果子数组中每个数都是偶数，那么第二个人只需要复制第一个人的操作就必胜了。所以我们要最小化全偶数的子数组的个数。

于是我们只需安排一些位置是奇数，一些位置是偶数，再把奇数和偶数分别排列起来就好了。

排列部分的方案很容易。选取位置的方案怎么办呢？

偶数显然可以被分配成一个一个出现的。而两个偶数之间必然插入至少一个奇数，这样最多多出来两个可以放奇数的位置，这个计数是很容易的。

时间复杂度为 $\mathcal{O}(M)$ 预处理，单次查询时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 3 * 10 ** 5
    mod = 10 ** 9 + 7
    
    f = [0] * (M + 1)
    f[0] = 1
    
    for i in range(1, M + 1):
        f[i] = i * f[i - 1] % mod
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        ans = f[n // 2] * f[n - n // 2] % mod
        if n % 2 == 0: ans = ans * (n // 2 + 1) % mod
        else: ans = ans * ((n // 2 + 1) * (n // 2 + 2) // 2 % mod) % mod
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int M = 3e5, mod = 1e9 + 7;
    vector<int> f(M + 1);

    f[0] = 1;
    for (int i = 1; i <= M; i ++) f[i] = 1ll * i * f[i - 1] % mod;

    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        int ans = 1ll * f[n / 2] * f[n - n / 2] % mod;
        if (n & 1) ans = 1ll * (n / 2 + 1) * (n / 2 + 2) / 2 % mod * ans % mod;
        else ans = 1ll * (n / 2 + 1) * ans % mod;

        cout << ans << '\n';
    }

	return 0;
}
```
