**提示 1：** 求的就是数组的均值的期望。

**提示 2：** 如何证明数组均值不变？

最后是随机任选一个元素，所以求的就是数组的均值。

这时你如果试一下算数组的均值，可以发现就是答案，如果比赛遇到就可以直接这么猜了。

怎么证明呢？我们只需证明在一次操作后均值不变就行。这就是一个鞅。

考虑每个元素的期望变动数值。其变大的可能性是选择比它大的数，变小的可能性是选择比它小的数。于是期望变动等于更大的数的数量减去更小的数的数量除以 $n$ 。

而 $a_i,a_j$ 这一对元素在考虑 $i$ 时的贡献和考虑 $j$ 时的贡献刚好相反，所以上述总期望变动是 $0$ ，因此均值不变。

时间复杂度为 $\mathcal{O}(M+\sum n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 2 * 10 ** 5
    mod = 10 ** 9 + 7
    f = Factorial(M, mod)
    
    t = II()
    outs = []
    
    for _ in range(t):
        n, k = MII()
        nums = LII()
        outs.append(sum(nums) % mod * f.inv(n) % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 2e5, mod = 1e9 + 7;
	vector<int> f(M + 1), g(M + 1);

	f[0] = 1;
	for (int i = 1; i <= M; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;
	g[M] = quickPow(f[M], mod - 2, mod);
	for (int i = M; i > 0; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	int t;
	cin >> t;

	while (t --) {
		int n, k;
		cin >> n >> k;

		int ans = 0;
		for (int i = 0; i < n; i ++) {
			int x;
			cin >> x;
			ans = (ans + x) % mod;
		}

		cout << 1ll * ans * f[n - 1] % mod * g[n] % mod << '\n';
	}

	return 0;
}
```
