**提示 1：** 考虑每一位。哪些数会有贡献？怎么数出来？

第一种操作只是增删数，我们看第二种操作。

这里是异或操作，可以分位考虑。

考虑第 $i$ 位结果，我们考虑集合里面满足 $x+t$ 的第 $i$ 位是 $1$ 的有哪些 $x$ 。

这意味着 $x+t$ 关于 $2^{i+1}$ 取模的结果在 $[2^i,2^{i+1})$ 之间，因此可以得到 $x$ 关于 $2^{i+1}$ 的取模的范围，我们只需计算取模在区间内的数量即可。

如何在增删的过程中快速维护数据结构达到这件事呢？我们只需维护关于 $2^1,2^2,\dots$ 取模结果是 $i$ 的数的个数，为了能快速计算区间和，可以使用树状数组 / 线段树。每次更新的时候把每个树状数组 / 线段树的对应位置进行调整，查询的时候每个结构进行区间查询即可。

注意这里 $x+t$ 可能会超过 $2^{20}$ ，但不会超过 $2^{21}$ ，所以你维护的数据结构需要算上 $2^{20}$ 的这一位。

时间复杂度为 $\mathcal{O}(n\log M+M+q\log^2 M)$ ，如果你用线性的方式初始化树状数组。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    nums = LII()
    
    vis = [0] * (1 << 20)
    for x in nums:
        vis[x] = 1
    
    fens = []
    for i in range(21):
        cnt = [0] * (1 << i + 1)
        for j in range(1 << i + 1):
            for k in range(j, 1 << 20, 1 << i + 1):
                cnt[j] += vis[k]
        fens.append(FenwickTreeArray(cnt))
    
    outs = []
    for _ in range(q):
        t, x = MII()
        
        if t == 1:
            dx = 1 if vis[x] == 0 else -1
    
            for i in range(21):
                fens[i].add(x % (1 << i + 1), dx)
            
            vis[x] ^= 1
        else:
            ans = 0
            
            for i in range(21):
                l = ((1 << i) - x) % (1 << i + 1)
                r = l + (1 << i) - 1
                
                if r < (1 << i + 1): ans += fens[i].rsum(l, r) % 2 * (1 << i)
                else: ans += (fens[i].rsum(l, (1 << i + 1) - 1) + fens[i].rsum(0, r - (1 << i + 1))) % 2 * (1 << i)
            
            outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	vector<int> vis(1 << 20, 0);
	while (n --) {
		int x;
		cin >> x;
		vis[x] ++;
	}

	vector<atcoder::fenwick_tree<int>> fens(21);

	for (int i = 0; i <= 20; i ++) {
		fens[i] = atcoder::fenwick_tree<int>(1 << i + 1);
		for (int j = 0; j < 1 << i + 1; j ++) {
			for (int k = j; k < 1 << 20; k += 1 << i + 1) {
				fens[i].add(j, vis[k]);
			}
		}
	}

	while (q --) {
		int t, x;
		cin >> t >> x;

		if (t == 1) {
			int dx = vis[x] ? -1 : 1;
			for (int i = 0; i <= 20; i ++)
				fens[i].add(x & ((1 << i + 1) - 1), dx);
			vis[x] ^= 1;
		}
		else {
			int ans = 0;
			for (int i = 0; i <= 20; i ++) {
				int l = ((3 << i) - x) & ((1 << i + 1) - 1);
				int r = l + (1 << i);

				if (r <= 1 << i + 1) ans += (fens[i].sum(l, r) & 1) ? 1 << i : 0;
				else ans += ((fens[i].sum(l, 1 << i + 1) + fens[i].sum(0, r - (1 << i + 1))) & 1) ? 1 << i : 0;
			}
			cout << ans << '\n';
		}
	}

	return 0;
}
```
