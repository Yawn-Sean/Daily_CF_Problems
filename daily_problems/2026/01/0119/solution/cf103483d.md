**提示 1：** 是最值问题，且答案越大越容易满足要求，所以可以二分。

**提示 2：** 检查的条件是什么？

首先看提示 1，于是问题变为了检查某个 $|i-j|$ 的最大值是否符合要求。

对于第一个数组的 $[l,r]$ 区间，在步长不超过 $k$ 的情况下，最多可以到达第二个数组的 $[l'=\max(1, l-k),r'=\min(r+k,n)]$ 区间。所以前者的和应该小于等于后者。这对所有的区间都成立。

我们没办法检查所有的区间，所以我们考虑两者的差的最大值，为此可以拆分为 $4$ 个前缀和的计算。整体而言 DP 逻辑类似于最大子段和的用当前和减去前缀的最小值的那个做法，具体可见后面的代码。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    v1 = LII()
    v2 = LII()
    
    acc1 = list(accumulate(v1, initial=0))
    acc2 = list(accumulate(v2, initial=0))
    
    l, r = 0, n
    while l <= r:
        mid = (l + r) // 2
        
        flg = True
        diff = 0
        for i in range(n):
            diff = fmin(acc1[i] - acc2[fmax(i - mid, 0)], diff)
            cur = acc2[fmin(i + mid + 1, n)] - acc1[i + 1]
            if cur + diff < 0:
                flg = False
        
        if flg: r = mid - 1
        else: l = mid + 1
    
    print(l if l < n else -1)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> v1(n), v2(n);
	for (auto &x: v1) cin >> x;
	for (auto &x: v2) cin >> x;

	vector<long long> acc1(n + 1, 0), acc2(n + 1, 0);
	for (int i = 0; i < n; i ++) acc1[i + 1] = acc1[i] + v1[i];
	for (int i = 0; i < n; i ++) acc2[i + 1] = acc2[i] + v2[i];

	int l = 0, r = n;
	while (l <= r) {
		int mid = (l + r) / 2;
		bool flg = true;
		long long diff = 0;

		for (int i = 0; i < n; i ++) {
			diff = min(acc1[i] - acc2[max(i - mid, 0)], diff);
			if (acc2[min(i + mid + 1, n)] - acc1[i + 1] + diff < 0) flg = false;
		}

		if (flg) r = mid - 1;
		else l = mid + 1;
	}

	cout << (l < n ? l : -1);

	return 0;
}
```
