**提示 1：** 考虑完全翻转的字符串，相当于要对于翻转后的字符串的每个前缀的后缀，找到原字符串的前缀和它匹配。

**提示 2：** 如果拼成一个字符串就是个简单的问题了。

先看提示 1 。

如果对于同一个字符串而言，我们要求某个前缀的后缀能匹配上自身的前缀可以直接使用 KMP 算法。这里不是一个字符串怎么办呢？

拼成一个就好了，我们构造字符串 $s+`#`+s'$ ，则 KMP 数组的最后 $n$ 项就是答案了。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def prep(p):
        pi = [0] * len(p)
        j = 0
        for i in range(1, len(p)):
            while j != 0 and p[j] != p[i]:
                j = pi[j - 1]
            if p[j] == p[i]:
                j += 1
            pi[i] = j
        return pi
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        s = [int(c) for c in I()]
        
        s.append(-1)
        for i in range(n):
            s.append(s[i] ^ 1)
        
        outs.append(' '.join(map(str, prep(s)[n + 1:])))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
vector<int> prep(string s) {
	int n = s.size();
	vector<int> kmp(n);
	int j = 0;

	for (int i = 1; i < n; i ++) {
		while (j && s[j] != s[i]) j = kmp[j - 1];
		if (s[j] == s[i]) j ++;
		kmp[i] = j;
	}

	return kmp;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		string s;
		cin >> n >> s;

		s += ' ';
		for (int i = 0; i < n; i ++) s += s[i] ^ 1;

		auto res = prep(s);
		for (int i = n + 1; i <= 2 * n; i ++)
			cout << res[i] << ' ';
		cout << '\n';
	}

	return 0;
}
```
