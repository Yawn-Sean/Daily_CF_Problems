**提示 1：** 只执行操作可以怎么快速实现交换？

**提示 2：** 如何减少交换需要执行的次数？

首先，我们操作 $(i,j),(j,i),(i,j)$ 就可以实现交换，而开始我们可以直接得到每个位置的最终位置，因此最多只需要 $n-1$ 次交换操作，所以总操作次数就可以达到 $3(n-1)$ ，前面的小问就解决了。

而怎么减少交换这个操作的次数呢？我们发现当 $0$ 参与交换的情况下可以减少一次。而一旦有一个 $0$ ，对于长度为 $l$ 的一个环我们就可以借助这个 $0$ 在 $2l+2$ 的复杂度下还原。

一开始的 $0$ 怎么找呢？只需找前 $21$ 个元素的子集就行，因为一定有两个子集异或结果相等，这两个子集的异或就是我们要找的，合成一个数就行。

这样我们开始需要 $\mathcal{O}(\log M)$ 次进行 $0$ 的产生，接下来 $2(n+环的个数)$ 次进行后续的调整。

但环很多怎么办呢？我们可以一开始随机操作几次，这样就可以使得环的期望数量降低。你也可以在环长度较小的情况下用 $3$ 次操作交换的方式来处理。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    ops = []
    
    def operate(i, j):
        if i != j:
            nums[i] ^= nums[j]
            ops.append(f'{i + 1} {j + 1}')
    
    def swap_zero(i, j):
        if i != j:
            operate(i, j)
            operate(j, i)
    
    for _ in range(100):
        u, v = random.randint(0, n - 1), random.randint(0, n - 1)
        operate(u, v)
    
    dp = [0] * (1 << 21)
    
    for i in range(1, 1 << 21):
        v = i & -i
        dp[i] = dp[i - v] ^ nums[v.bit_length() - 1]
    
    for i in range(1, 1 << 21):
        if dp[i] == 0:
            idxs = [j for j in range(21) if i >> j & 1]
            for j in range(1, len(idxs)):
                operate(idxs[0], idxs[j])
            swap_zero(idxs[0], 0)
            break
    
    pos = sorted(range(n), key=lambda x: nums[x])
    val = [0] * n
    
    for i in range(n):
        val[pos[i]] = i
    
    for i in range(1, n):
        if val[i] != i:
            pos[val[0]], pos[val[i]] = pos[val[i]], pos[val[0]]
            val[0], val[i] = val[i], val[0]
            swap_zero(0, i)
            
            cur = i
            while val[0] != cur:
                ncur = pos[cur]
                pos[val[cur]], pos[val[ncur]] = pos[val[ncur]], pos[val[cur]]
                val[cur], val[ncur] = val[ncur], val[cur]
                swap_zero(cur, ncur)
                cur = ncur
            
            pos[val[0]], pos[val[cur]] = pos[val[cur]], pos[val[0]]
            val[0], val[cur] = val[cur], val[0]
            swap_zero(cur, 0)
    
    print(len(ops))
    print('\n'.join(ops))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<pair<int, int>> ops;

	auto operate = [&] (int i, int j) -> void {
		if (i != j) {
			nums[i] ^= nums[j];
			ops.emplace_back(i + 1, j + 1);
		}
	};

	auto swap_zero = [&] (int i, int j) -> void {
		if (i != j) {
			operate(i, j);
			operate(j, i);
		}
	};

	for (int i = 0; i < 100; i ++) {
		int u = rng(), v = rng();
		u = abs(u) % n, v = abs(v) % n;
		operate(u, v);
	}

	vector<int> dp(1 << 21, 0);
	for (int i = 1; i < (1 << 21); i ++) {
		int v = i & -i;
		dp[i] = dp[i - v] ^ nums[__builtin_ctz(v)];
	}

	for (int i = 1; i < (1 << 21); i ++) {
		if (dp[i] == 0) {
			vector<int> idxs;
			for (int j = 0; j < 21; j ++) {
				if (i >> j & 1) {
					idxs.emplace_back(j);
				}
			}

			for (int j = 1; j < idxs.size(); j ++)
				operate(idxs[0], idxs[j]);
			swap_zero(idxs[0], 0);

			break;
		}
	}

	vector<int> pos(n), val(n);

	iota(pos.begin(), pos.end(), 0);
	stable_sort(pos.begin(), pos.end(), [&] (int i, int j) {return nums[i] < nums[j];});

	for (int i = 0; i < n; i ++)
		val[pos[i]] = i;
	
	for (int i = 1; i < n; i ++) {
		if (val[i] != i) {
			swap(pos[val[0]], pos[val[i]]);
			swap(val[0], val[i]);
			swap_zero(0, i);

			int cur = i;
			while (val[0] != cur) {
				int ncur = pos[cur];
				swap(pos[val[cur]], pos[val[ncur]]);
				swap(val[cur], val[ncur]);
				swap_zero(cur, ncur);
				cur = ncur;
			}

			swap(pos[val[0]], pos[val[cur]]);
			swap(val[0], val[cur]);
			swap_zero(cur, 0);
		}
	}

	cout << ops.size() << '\n';
	for (auto &[x, y]: ops) cout << x << ' ' << y << '\n';

	return 0;
}1
```
