**提示 1：** 对一组完全固定的字符串，答案咋算？

**提示 2：** 一个字母一个字母考虑。

如果各个字母的出现次数是 $c_1,c_2,\dots, c_{26}$ ，则方案数是 $\frac{(c_1+c_2+\dots+c_{26})!}{c_1!c_2!\dots c_{26}!}$ 。

分母部分是固定的，而分子是需要分配的。

所以一个字母一个字母考虑，假设原有的字母是 $a_1,a_2,\dots,a_{26}$ ，新增的字母数量是 $b_1,b_2,\dots,b_{26}$ 。

则构造字符串的方案数是 $\frac{((a_1+b_1)+(a_2+b_2)+\dots+(a_{26}+b_{26}))!}{(a_1+b_1)!(a_2+b_2)!\dots(a_{26}+b_{26})!}$ 。

而问号分配成 $b_1,b_2,\dots,b_{26}$ 个对应字母的方案数是 $\frac{(b_1+b_2+\dots+b_{26})!}{b_1!b_2!\dots b_{26}!}$ 。 

所以我们就要求 $\frac{((a_1+b_1)+(a_2+b_2)+\dots+(a_{26}+b_{26}))!}{(a_1+b_1)!(a_2+b_2)!\dots(a_{26}+b_{26})!}\frac{(b_1+b_2+\dots+b_{26})!}{b_1!b_2!\dots b_{26}!}$ 关于不同的 $\{b_i\}$ 的组合的求和，再除以总的方案数。

注意到分子是固定的。而每一步选取 $b_i$ 跟其他的字母是相互独立的，直接用背包，转移系数是 $\frac{1}{(a_i+b_i)!b_i!}$ 即可。

具体地，假设当前的 $b_i$ 的和是 $M$ ，我们枚举新的 $b_i=x$ ，则和转移到 $M+x$ ，且系数多了个 $\frac{1}{(a_i+b_i)!b_i!}$ ，乘上就好。

时间复杂度为 $\mathcal{O}(n^2|\Sigma|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    mod = 10 ** 9 + 7
    f = Factorial(1000, mod)
    
    t = II()
    outs = []
    
    rev26 = pow(26, -1, mod)
    pw_rev26 = [1] * 1001
    
    for i in range(1000):
        pw_rev26[i + 1] = pw_rev26[i] * rev26 % mod
    
    for _ in range(t):
        s = I()
        
        cnt = [0] * 26
        to_fill = 0
        
        for c in s:
            if 'a' <= c <= 'z':
                cnt[ord(c) - ord('a')] += 1
            else:
                to_fill += 1
        
        dp = [0] * (to_fill + 1)
        dp[0] = 1
        
        for i in range(26):
            for j in range(to_fill, -1, -1):
                if dp[j]:
                    for k in range(1, to_fill - j + 1):
                        dp[j + k] += dp[j] * f.fac_inv(cnt[i] + k) % mod * f.fac_inv(k) % mod
                        dp[j + k] %= mod
                    dp[j] = dp[j] * f.fac_inv(cnt[i]) % mod
        
        outs.append(dp[to_fill] * f.fac(to_fill) % mod * f.fac(len(s)) % mod * pw_rev26[to_fill] % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int mod = 1e9 + 7;

	vector<int> f(1001), g(1001);
	f[0] = 1;
	for (int i = 1; i <= 1000; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;
	g[1000] = quickPow(f[1000], mod - 2, mod);
	for (int i = 1000; i >= 1; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	int rev26 = quickPow(26, mod - 2, mod);
	vector<int> pw_rev26(1001);
	pw_rev26[0] = 1;
	for (int i = 1; i <= 1000; i ++)
		pw_rev26[i] = 1ll * pw_rev26[i - 1] * rev26 % mod;

	int t;
	cin >> t;

	while (t --) {
		string s;
		cin >> s;

		vector<int> cnt(26, 0);
		int to_fill = 0;

		for (auto &c: s) {
			if (c >= 'a' && c <= 'z') cnt[c - 'a'] ++;
			else to_fill ++;
		}

		vector<int> dp(to_fill + 1, 0);
		dp[0] = 1;

		for (int i = 0; i < 26; i ++) {
			for (int j = to_fill; j >= 0; j --) {
				if (dp[j]) {
					for (int k = 1; k <= to_fill - j; k ++) {
						dp[j + k] = (dp[j + k] + 1ll * dp[j] * g[cnt[i] + k] % mod * g[k] % mod) % mod;
					}
					dp[j] = 1ll * dp[j] * g[cnt[i]] % mod;
				}
			}
		}

		cout << 1ll * dp[to_fill] * f[to_fill] % mod * f[s.size()] % mod * pw_rev26[to_fill] % mod << '\n';
	}

	return 0;
}
```
