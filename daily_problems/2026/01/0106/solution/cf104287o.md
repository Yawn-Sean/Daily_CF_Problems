**提示 1：** 修改后，可行的答案集如何改变？

**提示 2：** 如何快速判断？

一个核心的观察：在操作 $(l,r,x)$ 后，最多只可能有一个元素 $l$ 可能从不可行的变成可行的。

为什么呢？ $l$ 前的显然没影响。而 $l+1$ 往后的，本身数值最多增加 $x$ ，而前缀也至少增加了 $x$ ，因此不可能从不可行的变成可行的。

所以可以把 $l$ 放入备选集合中。接下来只要我们能从备选集合中找出最小元素，并判断是否符合要求。

因此备选集合本身可以用小顶堆。而我们只需在区间加 $x$ 的更新的情况下，快速计算前缀和以及某个位置的数值就行，这是很容易用树状数组维护的，我们要计算前缀和，每次更新的一定是一个线段，即 $k\times i+b$ 的形式，于是只需差分维护 $k_i\times i+b_i$ 的系数就行。也可以使用懒更新线段树。

注意这边某些实现虽然可能爆 long long，但由于查询结果在 long long 范围内，所以不影响正确性，溢出了也会回到最终真实数值。

时间复杂度为 $\mathcal{O}(n+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    nums = LII()
    
    acc = list(accumulate(nums, initial=0))
    fen_k = FenwickTree(n + 1)
    fen_b = FenwickTree(n + 1)
    
    pq = []
    for i in range(1, n):
        if acc[i] <= nums[i]:
            pq.append(i)
    
    outs = []
    
    for _ in range(q):
        l, r, x = MII()
        l -= 1
        
        fen_k.add(l, x)
        fen_b.add(l, -(l - 1) * x)
        
        fen_k.add(r, -x)
        fen_b.add(r, (r - 1) * x)
        
        if l > 0:
            heappush(pq, l)
        
        while pq:
            u = pq[0]
            
            if acc[u] + fen_k.rsum(0, u - 1) * (u - 1) + fen_b.rsum(0, u - 1) <= nums[u] + fen_k.rsum(0, u):
                break
            
            heappop(pq)
    
        outs.append(-1 if len(pq) == 0 else pq[0] + 1)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x;

	vector<long long> acc(n + 1, 0);
	for (int i = 0; i < n; i ++) acc[i + 1] = acc[i] + nums[i];

	atcoder::fenwick_tree<long long> fen_k(n + 1), fen_b(n + 1);

	priority_queue<int, vector<int>, greater<int>> pq;
	for (int i = 1; i < n; i ++) {
		if (acc[i] <= nums[i]) {
			pq.push(i);
		}
	}

	while (q --) {
		int l, r, x;
		cin >> l >> r >> x;
		l --;

		fen_k.add(l, x);
		fen_b.add(l, -1ll * (l - 1) * x);

		fen_k.add(r, -x);
		fen_b.add(r, 1ll * (r - 1) * x);

		if (l) pq.push(l);

		while (!pq.empty()) {
			int u = pq.top();
			if (acc[u] + fen_k.sum(0, u) * (u - 1) + fen_b.sum(0, u) <= nums[u] + fen_k.sum(0, u + 1)) break;
			pq.pop();
		}

		cout << (pq.empty() ? -1 : pq.top() + 1) << '\n';
	}

	return 0;
}
```
