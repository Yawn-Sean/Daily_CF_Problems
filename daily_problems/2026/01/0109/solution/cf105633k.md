**提示 1：** 枚举第一个会议，第二个会议能否快速得到？

**提示 2：** 注意边界情况。

枚举第一个会议，第二个会议需要满足什么条件呢？要最优化什么问题呢？

首先我们将所有的 YN 转为 01，进而将字符串转化为二进制数。

则第二个会议需要满足原本是 0 的位目前都是 1，同时 1 的数量尽可能多。在数量一样多的情况下，需要满足这个会议的下标尽可能小。

我们如何预处理才能快速找到第二个会议呢？

我们现在对应的二进制数的位置，标记第二个会议的下标。接下来我们对其所有子集都可以用这个下标进行更新，而这件事可以用 SOS-DP 完成，即一步步转移各个二进制位，转移的过程中注意数字 1 位数的最大化和下标的最小化。

这样枚举第一个会议就可以快速用取反的记录结果得到答案了。

最后注意，如果存在满位的会议，上述查询结果会导致输出两个相同的会议，此时可以特判，只需找到另一个位数最多的会议即可。

时间复杂度为 $\mathcal{O}(n+m2^m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    vals = [-100] * (1 << m)
    idxs = [0] * (1 << m)
    
    msks = []
    
    for i in range(n):
        s = I()
        msk = 0
        for j in range(m):
            if s[j] == 'Y':
                msk |= 1 << j
        
        msks.append(msk)
        
        if vals[msk] < 0:
            vals[msk] = 0
            idxs[msk] = i
    
    if vals[-1] == 0:
        chosen = -1
        for i in range(n):
            if i != idxs[-1] and (chosen == -1 or msks[chosen].bit_count() < msks[i].bit_count()):
                chosen = i
        
        x, y = chosen, idxs[-1]
        if x > y: x, y = y, x
        print(x + 1, y + 1)
    
    else:
        for i in range(m):
            for j in range(1 << m):
                if j >> i & 1:
                    nj = j ^ (1 << i)
                    
                    if vals[j] + 1 > vals[nj] or (vals[j] + 1 == vals[nj] and idxs[j] < idxs[nj]):
                        vals[nj] = vals[j] + 1
                        idxs[nj] = idxs[j]
    
        cur = -1
        x, y = -1, -1
        for i in range(n):
            v = (1 << m) - 1 - msks[i]
            if vals[v] > cur:
                cur = vals[v]
                x, y = i, idxs[v]
        
        if cur >= 0: print(x + 1, y + 1)
        else: print('No')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<vector<pair<int, int>>> path(n), rev_path(n);

    while (m --) {
        int u, v, w;
        cin >> u >> v >> w;
        u --, v --;
        path[u].emplace_back(v, w);
        rev_path[v].emplace_back(u, w);
    }

    int inf = 2e9;

    auto shortest_path = [&] (vector<vector<pair<int, int>>> paths) -> vector<int> {
        vector<int> ans(n, inf);
        ans[0] = 0;

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});

        while (!pq.empty()) {
            auto [d, u] = pq.top(); pq.pop();
            if (ans[u] == d) {
                for (auto &[v, nd]: paths[u]) {
                    if (max(d, nd) < ans[v]) {
                        ans[v] = max(d, nd);
                        pq.push({ans[v], v});
                    }
                }
            }
        }

        return ans;
    };

    auto d1 = shortest_path(path);
    auto d2 = shortest_path(rev_path);

    for (int i = 0; i < n; i ++) {
        if (d2[i] > d1[i]) {
            return cout << "NO", 0;
        }
    }

    cout << "YES";

	return 0;
}
```
