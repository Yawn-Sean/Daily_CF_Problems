**提示 1：** 枚举第一个会议，第二个会议能否快速得到？

**提示 2：** 注意边界情况。

枚举第一个会议，第二个会议需要满足什么条件呢？要最优化什么问题呢？

首先我们将所有的 YN 转为 01，进而将字符串转化为二进制数。

则第二个会议需要满足原本是 0 的位目前都是 1，同时 1 的数量尽可能多。在数量一样多的情况下，需要满足这个会议的下标尽可能小。

我们如何预处理才能快速找到第二个会议呢？

我们现在对应的二进制数的位置，标记第二个会议的下标。接下来我们对其所有子集都可以用这个下标进行更新，而这件事可以用 SOS-DP 完成，即一步步转移各个二进制位，转移的过程中注意数字 1 位数的最大化和下标的最小化。

这样枚举第一个会议就可以快速用取反的记录结果得到答案了。

最后注意，如果存在满位的会议，上述查询结果会导致输出两个相同的会议，此时可以特判，只需找到另一个位数最多的会议即可。

时间复杂度为 $\mathcal{O}(n+m2^m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    vals = [-100] * (1 << m)
    idxs = [0] * (1 << m)
    
    msks = []
    
    for i in range(n):
        s = I()
        msk = 0
        for j in range(m):
            if s[j] == 'Y':
                msk |= 1 << j
        
        msks.append(msk)
        
        if vals[msk] < 0:
            vals[msk] = 0
            idxs[msk] = i
    
    if vals[-1] == 0:
        chosen = -1
        for i in range(n):
            if i != idxs[-1] and (chosen == -1 or msks[chosen].bit_count() < msks[i].bit_count()):
                chosen = i
        
        x, y = chosen, idxs[-1]
        if x > y: x, y = y, x
        print(x + 1, y + 1)
    
    else:
        for i in range(m):
            for j in range(1 << m):
                if j >> i & 1:
                    nj = j ^ (1 << i)
                    
                    if vals[j] + 1 > vals[nj] or (vals[j] + 1 == vals[nj] and idxs[j] < idxs[nj]):
                        vals[nj] = vals[j] + 1
                        idxs[nj] = idxs[j]
    
        cur = -1
        x, y = -1, -1
        for i in range(n):
            v = (1 << m) - 1 - msks[i]
            if vals[v] > cur:
                cur = vals[v]
                x, y = i, idxs[v]
        
        if cur >= 0: print(x + 1, y + 1)
        else: print('No')
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<int> vals(1 << m, -100), idxs(1 << m, 0), msks(n);

	for (int i = 0; i < n; i ++) {
		string s;
		cin >> s;
		
		for (int j = 0; j < m; j ++) {
			if (s[j] == 'Y') {
				msks[i] |= 1 << j;
			}
		}

		if (vals[msks[i]] < 0) {
			vals[msks[i]] = 0;
			idxs[msks[i]] = i;
		}
	}

	if (vals.back() == 0) {
		int x = idxs.back(), y = -1;
		for (int i = 0; i < n; i ++) {
			if (i != idxs.back() && (y == -1 || __popcount(msks[y]) < __popcount(msks[i]))) {
				y = i;
			}
		}
		if (x > y) swap(x, y);
		cout << x + 1 << ' ' << y + 1;
	}
	else {
		for (int i = 0; i < m; i ++) {
			for (int j = 0; j < 1 << m; j ++) {
				if (j >> i & 1) {
					int nj = j ^ (1 << i);
					if (vals[j] + 1 > vals[nj] || (vals[j] + 1 == vals[nj] && idxs[j] < idxs[nj])) {
						vals[nj] = vals[j] + 1;
						idxs[nj] = idxs[j];
					}
				}
			}
		}

		int cur = -1, x = -1, y = -1;

		for (int i = 0; i < n; i ++) {
			int v = (1 << m) - 1 - msks[i];
			if (vals[v] > cur) {
				cur = vals[v];
				x = i;
				y = idxs[v];
			}
		}

		if (cur >= 0) cout << x + 1 << ' ' << y + 1;
		else cout << "No";
	}

	return 0;
}
```
