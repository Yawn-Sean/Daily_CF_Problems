**提示 1：** 考虑每个位，他们是怎么产生贡献的？对答案的贡献如何？

考虑从 $f(k,x)$ 追根溯源，看 $f(0,v)$ 如何影响到它。

考虑某个 $x$ 有的位。考虑从哪里转移，发现是不断取子集，取 $k$ 次到达 $v$ ，最后 $v$ 如果这一位有数值，则会让这一位的贡献加一。

于是如果别的有 $p$ 个位，则这 $p$ 个位可以选择在第 $k,k-1,\dots,1$ 轮变成 $0$ ，也可以不变，因此总共有 $k+1$ 种方案，所以产生的贡献有 $(k+1)^p$ 。

因为每个位的贡献都一样，所以最后只要求 $x\times(k+1)^p$ ，其中 $p$ 等于 $x$ 的二进制中为 $1$ 的数量减去 $1$ 。

预处理后复杂度是 $\mathcal{O}(\log\log n)$ 的。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    mod = 10 ** 9 + 7
    
    for _ in range(t):
        k, x = MII()
        outs.append(x * pow(k + 1, x.bit_count() - 1, mod) % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 1e9 + 7;
	cin >> t;

	while (t --) {
		int k, x;
		cin >> k >> x;

		cout << x * quickPow(k + 1, __popcount(x) - 1, mod) % mod << '\n';
	}

	return 0;
}
```
