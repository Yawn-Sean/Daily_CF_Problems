**提示 1：** 想想这个图应该有啥性质？这个性质下能证明出来吗？

首先每个点的度数必须不超过 $3$ ，否则相邻的四个点都走不完。

而同时，度数为 $3$ 的点必须在一条路径上，否则中间那个度数为 $3$ 的点会产生矛盾，因为必须走向一个方向再走回来。

而如果在一条路径上，剩余点度数不超过 $2$ ，很容易构造出可行方案，就只是一端出发，遇到度数为 $3$ 的点拐弯回来就行（可以自己画个图试试看）。

综上进行检查即可，检查方式可以是以其中一个度数为 $3$ 的点为根，看剩余点是否形成一条根出发的路径。时间复杂度为 $\mathcal{O}(n)$ 。

应该也有难写不少的 DP 做法。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        path = [[] for _ in range(n)]
        
        for _ in range(n - 1):
            u, v = GMI()
            path[u].append(v)
            path[v].append(u)
        
        flg = True
        rt = -1
        for i in range(n):
            if len(path[i]) > 3:
                flg = False
            elif len(path[i]) == 3:
                rt = i
        
        if not flg: outs.append('NO')
        elif rt != -1:
            parent = [-1] * n
            que = [rt]
            
            for u in que:
                for v in path[u]:
                    if parent[u] != v:
                        parent[v] = u
                        que.append(v)
            
            vis = [0] * n
            
            for i in range(n):
                if len(path[i]) == 3:
                    cur = i
                    while cur >= 0 and not vis[cur]:
                        vis[cur] = 1
                        cur = parent[cur]
            
            for i in range(n):
                v = 0
                for j in path[i]:
                    v += vis[j]
                if v >= 3: flg = False
            
            outs.append('YES' if flg else 'NO')
            
        else: outs.append('YES')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        vector<vector<int>> path(n);
        for (int i = 0; i < n - 1; i ++) {
            int u, v;
            cin >> u >> v;
            u --, v --;
            path[u].emplace_back(v);
            path[v].emplace_back(u);
        }

        bool flg = true;
        int rt = -1;

        for (int i = 0; i < n; i ++) {
            if (path[i].size() > 3) flg = false;
            else if (path[i].size() == 3) rt = i;
        }

        if (!flg) cout << "NO\n";
        else if (rt != -1) {
            vector<int> parent(n, -1);
            auto dfs = [&] (auto &self, int u, int p) -> void {
                parent[u] = p;
                for (auto &v: path[u]) {
                    if (v != p) {
                        self(self, v, u);
                    }
                }
            };
            dfs(dfs, rt, -1);

            vector<int> vis(n, 0);
            for (int i = 0; i < n; i ++) {
                if (path[i].size() == 3) {
                    int cur = i;
                    while (cur >= 0 && !vis[cur]) {
                        vis[cur] = 1;
                        cur = parent[cur];
                    }
                }
            }

            for (int i = 0; i < n; i ++) {
                int v = 0;
                for (auto &j: path[i]) v += vis[j];
                if (v >= 3) flg = false;
            }

            cout << (flg ? "YES\n" : "NO\n");
        }
        else cout << "YES\n";
    }

	return 0;
}
```
