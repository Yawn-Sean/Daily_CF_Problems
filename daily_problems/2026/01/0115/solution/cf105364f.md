**提示 1：** 显然是 DP 问题，如何设计状态和最优化目标。

首先我们先分配一组亏钱的，再从这些状态出发，这样就只剩下一个目标的最优化问题了。

我们的目标是对于某一组数量，求出最多的分配组数，这样可以赚到最多的钱。但如果我们枚举新的成组的用了多少 $1,2,3$ 类的物品，显然复杂度就很爆了。

怎么办呢？一个常见的思路就是一步步拆解——一个个添加物品。此时需要多记录的就是——目前形成了几组，还没凑成组的用了多少金子。

这个状态仍然是可以和凑成的组数搭配进行最优化的，关键字组数在前，组数相同时，还没凑成的金子越多越优。

下面的代码略有不同，组数状态填为当前所有的成组元素的总盈利数值，这也是很容易维护的，最后提取答案也很简单。

时间复杂度为 $\mathcal{O}(M^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        v = II() * 100
        a, b, c = MII()
        p1, p2, p3 = MII()
        
        def f(i, j, k):
            return (i * (p2 + 1) + j) * (p3 + 1) + k
        
        inf  = 10 ** 9
        dp = [-inf] * (p1 + 1) * (p2 + 1) * (p3 + 1)
        resid = [0] * (p1 + 1) * (p2 + 1) * (p3 + 1)
        
        for i in range(p1 + 1):
            for j in range(p2 + 1):
                for k in range(p3 + 1):
                    if (i * a + j * b + k * c) * 5 > v:
                        nx = v - (i * a + j * b + k * c) * 5
                        ny = 0
                        nmsk = f(i, j, k)
                        if dp[nmsk] < nx or (dp[nmsk] == nx and resid[nmsk] < ny):
                            dp[nmsk] = nx
                            resid[nmsk] = ny
                        
                        x = dp[nmsk]
                        y = resid[nmsk]
                        
                        if i < p1:
                            nx, ny = x, y
                            nmsk = f(i + 1, j, k)
                            
                            if ny + a < 100:
                                ny += a
                            else:
                                nx = nx + v - (ny + a) * 5
                                ny = 0
                            
                            if dp[nmsk] < nx or (dp[nmsk] == nx and resid[nmsk] < ny):
                                dp[nmsk] = nx
                                resid[nmsk] = ny
                        
                        if j < p2:
                            nx, ny = x, y
                            nmsk = f(i, j + 1, k)
                            
                            if ny + b < 100:
                                ny += b
                            else:
                                nx = nx + v - (ny + b) * 5
                                ny = 0
                            
                            if dp[nmsk] < nx or (dp[nmsk] == nx and resid[nmsk] < ny):
                                dp[nmsk] = nx
                                resid[nmsk] = ny
                        
                        if k < p3:
                            nx, ny = x, y
                            nmsk = f(i, j, k + 1)
                            
                            if ny + c < 100:
                                ny += c
                            else:
                                nx = nx + v - (ny + c) * 5
                                ny = 0
                            
                            if dp[nmsk] < nx or (dp[nmsk] == nx and resid[nmsk] < ny):
                                dp[nmsk] = nx
                                resid[nmsk] = ny
        
        outs.append(max(dp))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int v, a, b, c, p1, p2, p3;
        cin >> v >> a >> b >> c >> p1 >> p2 >> p3;
        v *= 100;

        int inf = 1e9;
        vector<int> dp((p1 + 1) * (p2 + 1) * (p3 + 1), -inf);
        vector<int> resid((p1 + 1) * (p2 + 1) * (p3 + 1), 0);

        auto f = [&] (int i, int j, int k) -> int {
            return (i * (p2 + 1) + j) * (p3 + 1) + k;
        };

        for (int i = 0; i <= p1; i ++) {
            for (int j = 0; j <= p2; j ++) {
                for (int k = 0; k <= p3; k ++) {
                    if ((i * a + j * b + k * c) * 5 > v) {
                        int nx, ny, nmsk;
                        auto update = [&] () -> void {
                            if (dp[nmsk] < nx || (dp[nmsk] == nx && resid[nmsk] < ny)) {
                                dp[nmsk] = nx;
                                resid[nmsk] = ny;
                            }
                        };

                        nx = v - (i * a + j * b + k * c) * 5;
                        ny = 0;
                        nmsk = f(i, j, k);
                        update();

                        int x = dp[nmsk], y = resid[nmsk];
                        if (i < p1) {
                            nx = x, ny = y, nmsk = f(i + 1, j, k);
                            if (ny + a < 100) ny += a;
                            else {
                                nx = nx + v - (ny + a) * 5;
                                ny = 0;
                            }
                            update();
                        }

                        if (j < p2) {
                            nx = x, ny = y, nmsk = f(i, j + 1, k);
                            if (ny + b < 100) ny += b;
                            else {
                                nx = nx + v - (ny + b) * 5;
                                ny = 0;
                            }
                            update();
                        }

                        if (k < p3) {
                            nx = x, ny = y, nmsk = f(i, j, k + 1);
                            if (ny + c < 100) ny += c;
                            else {
                                nx = nx + v - (ny + c) * 5;
                                ny = 0;
                            }
                            update();
                        }
                    }
                }
            }
        }

        cout << *max_element(dp.begin(), dp.end()) << '\n';
    }

	return 0;
}
```
