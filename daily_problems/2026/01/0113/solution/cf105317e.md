**提示 1：** 总共要乘的数越小越好。

**提示 2：** 如果要乘到 $x$ ，最少操作几次？
 
请先看前一问。

而前一问中，我们可以得到当前出现次数还是奇数的质因子，我们最少得把这些质因子都乘上。

这需要多少次操作呢？事实上总共只有 $2^{19}$ 种可能的组合，我们可以用 DP 预处理得到这里需要操作几次。

我们设乘到 $msk$ 这个情况的时候，最少操作的次数是 $v$ ，且操作当前次数时，最后一个位置最少需要乘 $val$ 。

枚举新增的因子，如果 $val$ 乘它不超过 $L$ ，则转移结果是 $(v,val\times x)$ ，否则需要新开一个操作，即转移结果是 $(v+1,x)$ 。

总共有 $\mathcal{O}(2^k)$ 种状态，转移 $\mathcal{O}(k)$ 次，因此符合要求。

用这个 DP 预处理结果后，对于每次查询，只需看对应的 msk 对应的答案就行。

时间复杂度为 $\mathcal{O}(M+k2^k+n\log n+q\log n)$ ，如果你用倍增求 LCA 的话。当然可以进一步优化为别的求 LCA 的方式。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 70
    pr = list(range(M + 1))
    primes = []
    
    for i in range(2, M + 1):
        if pr[i] == i:
            primes.append(i)
            for j in range(i, M + 1, i):
                pr[j] = i
    
    msks = [0] * (M + 1)
    for i in range(19):
        msks[primes[i]] = 1 << i
    
    for i in range(2, M + 1):
        if pr[i] < i:
            msks[i] = msks[i // pr[i]] ^ msks[pr[i]]
    
    n, l = MII()
    
    k = len(primes)
    dp = [100] * (1 << k)
    remaining = [1] * (1 << k)
    
    dp[0] = 1
    for i in range(1 << k):
        for j in range(k):
            if i >> j & 1: continue
            ni = i | (1 << j)
            
            x = dp[i]
            y = remaining[i]
            if y * primes[j] <= l:
                y *= primes[j]
            else:
                x += 1
                y = primes[j]
            
            if x < dp[ni] or (x == dp[ni] and y < remaining[ni]):
                dp[ni] = x
                remaining[ni] = y
    dp[0] = 0
    
    nums = LII()
    for i in range(n):
        nums[i] = msks[nums[i]]
    
    path = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    depth = [0] * n
    parent = [-1] * n
    que = [0]
    
    for u in que:
        for v in path[u]:
            if parent[u] != v:
                parent[v] = u
                depth[v] = depth[u] + 1
                nums[v] ^= nums[u]
                que.append(v)
    
    nth_parent = [[-1] * n for _ in range(20)]
    nth_parent[0] = parent
    
    for i in range(19):
        for j in range(n):
            if nth_parent[i][j] >= 0:
                nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
    def lca(x, y):
        if depth[x] > depth[y]:
            x, y = y, x
        
        d = depth[y] - depth[x]
        while d:
            v = d & -d
            y = nth_parent[v.bit_length() - 1][y]
            d -= v
        
        if x == y: return x
        
        for i in range(19, -1, -1):
            if nth_parent[i][x] != nth_parent[i][y]:
                x = nth_parent[i][x]
                y = nth_parent[i][y]
        
        return parent[x]
    
    q = II()
    outs = []
    
    for _ in range(q):
        u, v = GMI()
        l = lca(u, v)
        
        val = nums[u] ^ nums[v] ^ nums[l]
        if l > 0: val ^= nums[parent[l]]
    
        outs.append(dp[val])
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 70;
	vector<int> pr(M + 1), primes;
	iota(pr.begin(), pr.end(), 0);

	for (int i = 2; i <= M; i ++) {
		if (pr[i] == i) {
			primes.emplace_back(i);
			for (int j = i; j <= M; j += i) {
				pr[j] = i;
			}
		}
	}

	vector<int> msks(M + 1, 0);
	for (int i = 0; i < 19; i ++)
		msks[primes[i]] = 1 << i;
	
	for (int i = 2; i <= M; i ++)
		if (pr[i] < i) msks[i] = msks[pr[i]] ^ msks[i / pr[i]];

	int n, l;
	cin >> n >> l;

	int k = 19;
	vector<pair<int, int>> dp(1 << k, {100, 0});

	dp[0] = {1, 1};
	for (int i = 0; i < (1 << k); i ++) {
		for (int j = 0; j < k; j ++) {
			if (i >> j & 1) continue;

			pair<int, int> to_update = dp[i];
			to_update.second *= primes[j];
			if (to_update.second > l) to_update = {to_update.first + 1, primes[j]};

			dp[i | (1 << j)] = min(dp[i | (1 << j)], to_update);
		}
	}

	dp[0].first = 0;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x, x = msks[x];

	vector<vector<int>> path(n);
	for (int i = 0; i < n - 1; i ++) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		path[u].emplace_back(v);
		path[v].emplace_back(u);
	}

	vector<int> depth(n, 0), parent(n, -1);

	auto dfs = [&] (auto &self, int u, int p) -> void {
		parent[u] = p;
		for (auto &v: path[u]) {
			if (v != p) {
				nums[v] ^= nums[u];
				depth[v] = depth[u] + 1;
				self(self, v, u);
			}
		}
	};

	dfs(dfs, 0, -1);

	vector<vector<int>> nth_parent(20, vector<int>(n, -1));
	nth_parent[0] = parent;

	for (int i = 0; i < 19; i ++) {
		for (int j = 0; j < n; j ++) {
			if (nth_parent[i][j] >= 0) {
				nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
			}
		}
	}

	auto lca = [&] (int x, int y) -> int {
		if (depth[x] > depth[y]) swap(x, y);

		int d = depth[y] - depth[x];
		while (d) {
			y = nth_parent[__builtin_ctz(d)][y];
			d -= d & -d;
		}

		if (x == y) return x;

		for (int i = 19; i >= 0; i --) {
			if (nth_parent[i][x] != nth_parent[i][y]) {
				x = nth_parent[i][x];
				y = nth_parent[i][y];
			}
		}

		return parent[x];
	};

	int q;
	cin >> q;

	while (q --) {
		int u, v;
		cin >> u >> v;
		u --, v --;

		auto l = lca(u, v);
		int val = nums[u] ^ nums[v] ^ nums[l];
		if (l) val ^= nums[parent[l]];

		cout << dp[val].first << '\n';
	}

	return 0;
}
```
