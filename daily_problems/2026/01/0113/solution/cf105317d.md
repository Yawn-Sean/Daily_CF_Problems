**提示 1：** 如果能乘以一个任意的数，则一次操作就够了。

**提示 2：** 如何判断是否需要操作？

因为我们总可以将其中一个结点乘以当前路径结点的总乘积，所以最多只需要一次操作，所以我们只需要判断能否不操作就达成要求。

我们相当于要求路径的乘积，同时，如果一个质因子出现了两次，则可以去掉这两次，因为不影响整体是否是完全平方数。

而 $1\sim 70$ 之间只有 $19$ 个质数，所以可以用一个二进制位表示某个质数，其设定为 $1$ 当且仅当这个质数出现的次数是奇数。于是整体的乘积就变成了求一系列二进制数的异或。

如果异或结果是 $0$ ，则无需操作。否则，操作一次。

怎么求路径的异或和呢？我们只需找到 LCA ，则我们拆分路径为 $u\to LCA\to v$ ，这样，我们可以预处理从根节点到每个结点的路径的异或和，分别得到两部分的异或和，再把两段结果异或组合到一起，就能得到结果。

时间复杂度为 $\mathcal{O}(M+n\log n+q\log n)$ ，如果你用倍增求 LCA 的话，前面部分是预处理每个数对应的 mask 。当然可以进一步优化为别的求 LCA 的方式。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 70
    pr = list(range(M + 1))
    primes = []
    
    for i in range(2, M + 1):
        if pr[i] == i:
            primes.append(i)
            for j in range(i, M + 1, i):
                pr[j] = i
    
    msks = [0] * (M + 1)
    for i in range(19):
        msks[primes[i]] = 1 << i
    
    for i in range(2, M + 1):
        if pr[i] < i:
            msks[i] = msks[i // pr[i]] ^ msks[pr[i]]
    
    n = II()
    nums = LII()
    for i in range(n):
        nums[i] = msks[nums[i]]
    
    path = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    depth = [0] * n
    parent = [-1] * n
    que = [0]
    
    for u in que:
        for v in path[u]:
            if parent[u] != v:
                parent[v] = u
                depth[v] = depth[u] + 1
                nums[v] ^= nums[u]
                que.append(v)
    
    nth_parent = [[-1] * n for _ in range(20)]
    nth_parent[0] = parent
    
    for i in range(19):
        for j in range(n):
            if nth_parent[i][j] >= 0:
                nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
    def lca(x, y):
        if depth[x] > depth[y]:
            x, y = y, x
        
        d = depth[y] - depth[x]
        while d:
            v = d & -d
            y = nth_parent[v.bit_length() - 1][y]
            d -= v
        
        if x == y: return x
        
        for i in range(19, -1, -1):
            if nth_parent[i][x] != nth_parent[i][y]:
                x = nth_parent[i][x]
                y = nth_parent[i][y]
        
        return parent[x]
    
    q = II()
    outs = []
    
    for _ in range(q):
        u, v = GMI()
        l = lca(u, v)
        
        val = nums[u] ^ nums[v] ^ nums[l]
        if l > 0: val ^= nums[parent[l]]
    
        outs.append(1 if val else 0)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 70;
	vector<int> pr(M + 1), primes;
	iota(pr.begin(), pr.end(), 0);

	for (int i = 2; i <= M; i ++) {
		if (pr[i] == i) {
			primes.emplace_back(i);
			for (int j = i; j <= M; j += i) {
				pr[j] = i;
			}
		}
	}

	vector<int> msks(M + 1, 0);
	for (int i = 0; i < 19; i ++)
		msks[primes[i]] = 1 << i;
	
	for (int i = 2; i <= M; i ++)
		if (pr[i] < i) msks[i] = msks[pr[i]] ^ msks[i / pr[i]];

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &x: nums) cin >> x, x = msks[x];

	vector<vector<int>> path(n);
	for (int i = 0; i < n - 1; i ++) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		path[u].emplace_back(v);
		path[v].emplace_back(u);
	}

	vector<int> depth(n, 0), parent(n, -1);

	auto dfs = [&] (auto &self, int u, int p) -> void {
		parent[u] = p;
		for (auto &v: path[u]) {
			if (v != p) {
				nums[v] ^= nums[u];
				depth[v] = depth[u] + 1;
				self(self, v, u);
			}
		}
	};

	dfs(dfs, 0, -1);

	vector<vector<int>> nth_parent(20, vector<int>(n, -1));
	nth_parent[0] = parent;

	for (int i = 0; i < 19; i ++) {
		for (int j = 0; j < n; j ++) {
			if (nth_parent[i][j] >= 0) {
				nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
			}
		}
	}

	auto lca = [&] (int x, int y) -> int {
		if (depth[x] > depth[y]) swap(x, y);

		int d = depth[y] - depth[x];
		while (d) {
			y = nth_parent[__builtin_ctz(d)][y];
			d -= d & -d;
		}

		if (x == y) return x;

		for (int i = 19; i >= 0; i --) {
			if (nth_parent[i][x] != nth_parent[i][y]) {
				x = nth_parent[i][x];
				y = nth_parent[i][y];
			}
		}

		return parent[x];
	};

	int q;
	cin >> q;

	while (q --) {
		int u, v;
		cin >> u >> v;
		u --, v --;

		auto l = lca(u, v);
		int val = nums[u] ^ nums[v] ^ nums[l];
		if (l) val ^= nums[parent[l]];

		cout << (val ? 1 : 0) << '\n';
	}

	return 0;
}
```
