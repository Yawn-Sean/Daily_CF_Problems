**提示 1：** 用总方案数减去不合法的方案数。

首先，如果 $x+y$ 都超过了 $g$ ，则怎么都没办法满足，输出 $0$ 就行。

否则，考虑总方案数 $C_{b+g}^g$ ，其中哪些方案不合法呢？

我们发现第 $b$ 个女生和倒数第 $g$ 个女生之间不能有任何男生，所以可以把她们看成一个整体，于是总共就有 $b+g-1$ 个女生的整体和 $x$ 个男生，排列方式就有 $C_{b+g-1}^x$ 种。

两者相减即答案，你只需要预处理阶乘和阶乘的逆元就行。预处理复杂度 $\mathcal{O}(M)$ ，每次输出答案复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    M = 2 * 10 ** 6
    mod = 10 ** 9 + 7
    f = Factorial(M, mod)
    
    for _ in range(t):
        b, g, x, y = MII()
        if x + y > g: outs.append(0)
        else: outs.append((f.combi(b + g, b) - f.combi(b + x + y - 1, b)) % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 2e6, mod = 1e9 + 7;

	vector<int> f(M + 1), g(M + 1);
	f[0] = 1;
	for (int i = 1; i <= M; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;
	g[M] = quickPow(f[M], mod - 2, mod);
	for (int i = M; i >= 1; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	auto comb = [&] (int x, int y) -> int {
		return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
	};

	int t;
	cin >> t;

	while (t --) {
		int b0, g0, x, y;
		cin >> b0 >> g0 >> x >> y;

		if (x + y > g0) cout << "0\n";
		else {
			int ans = 0;
			ans = (ans + comb(b0 + g0, b0)) % mod;
			ans = (ans + mod - comb(b0 + x + y - 1, b0)) % mod;
			cout << ans << '\n';
		}
	}

	return 0;
}
```
