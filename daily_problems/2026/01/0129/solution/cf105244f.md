**提示 1：** 如果一个元素要变到目标数值，肯定次数越少越好。这一步和别的是独立的。

**提示 2：** 处理完第一步后是经典问题。

如果一个元素要从 $1$ 变成目标的 $b_i$ ，操作次数一定越少越好。所以我们可以预处理这里需要变化多少次。

因为变化的过程是单调递增的，直接顺序进行 DP 即可。

发现这里的步长不超过 $12$ ，所以 $k$ 如果不小于 $12n$ ，其实是都可以变成目标数值的。

接下来相当于每个数字变动的次数是容量，产生的收益是价值，我们只需考虑一个经典的背包问题就好。

时间复杂度为 $\mathcal{O}(n^2M)$ ，其中 $M$ 是变化的步长，不超过 $12$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    k = II()
    
    nums = LII()
    vals = LII()
    
    ops = [1000] * 1001
    ops[0] = ops[1] = 0
    
    for i in range(1, 1001):
        for j in range(1, 1001):
            ni = i + i // j
            if ni <= 1000:
                ops[ni] = fmin(ops[ni], ops[i] + 1)
    
    dp = [0] * 12001
    
    for i in range(n):
        x = ops[nums[i]]
        y = vals[i]
        
        for j in range(12000, x - 1, -1):
            dp[j] = fmax(dp[j], dp[j - x] + y)
    
    print(max(dp[:k + 1]))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e3;
	vector<int> ops(M + 1, M);
	ops[0] = ops[1] = 0;

	for (int i = 1; i <= M; i ++) {
		for (int j = 1; j <= i; j ++) {
			int ni = i + i / j;
			if (ni <= M) {
				ops[ni] = min(ops[ni], ops[i] + 1);
			}
		}
	}

	int n, k;
	cin >> n >> k;

	vector<int> target(n), gains(n);
	for (auto &v: target) cin >> v;
	for (auto &v: gains) cin >> v;

	vector<int> dp(12001, 0);
	for (int i = 0; i < n; i ++) {
		int val = ops[target[i]], gain = gains[i];
		for (int j = 12000; j >= val; j --) {
			dp[j] = max(dp[j], dp[j - val] + gain);
		}
	}

	int ans = 0;
	for (int i = 0; i <= 12000 && i <= k; i ++)
		ans = max(ans, dp[i]);
	cout << ans << '\n';

	return 0;
}
```
