**提示 1：** 两条抛物线不相交需要满足什么条件？

**提示 2：** 根据上面的事安排顺序。

两个函数不相交的话，不可能一会一个大，一会另一个大，不然根据介值原理就矛盾了。

所以一定存在明确的上下关系。

所以我们可以根据 $f(0)=c$ 的数值进行排序，这样就可以从下往上一个个找了。

而要两个二次曲线不相交，相当于方程无解。方程无解有两种情况——对应的二次方程无解 / 对应的方程次数为 $0$ 且恒不成立。

因此我们可以确定选取某一条曲线时，其下方 / 上方分别最多能取多少条曲线。两部分加起来就好。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        xs = []
        ys = []
        zs = []
        
        for _ in range(n):
            x, y, z = MII()
            xs.append(x)
            ys.append(y)
            zs.append(z)
        
        st_range = sorted(range(n), key=lambda x: zs[x])
        
        dp_pref = [1] * n
        
        for i in range(n):
            for j in range(i):
                vi = st_range[i]
                vj = st_range[j]
                
                if xs[vi] == xs[vj]:
                    if ys[vi] == ys[vj]:
                        dp_pref[vi] = fmax(dp_pref[vi], dp_pref[vj] + 1)
                else:
                    a = xs[vi] - xs[vj]
                    b = ys[vi] - ys[vj]
                    c = zs[vi] - zs[vj]
                    
                    if b * b < 4 * a * c:
                        dp_pref[vi] = fmax(dp_pref[vi], dp_pref[vj] + 1)
        
        dp_suff = [1] * n
        
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                vi = st_range[i]
                vj = st_range[j]
                
                if xs[vi] == xs[vj]:
                    if ys[vi] == ys[vj]:
                        dp_suff[vi] = fmax(dp_suff[vi], dp_suff[vj] + 1)
                else:
                    a = xs[vi] - xs[vj]
                    b = ys[vi] - ys[vj]
                    c = zs[vi] - zs[vj]
                    
                    if b * b < 4 * a * c:
                        dp_suff[vi] = fmax(dp_suff[vi], dp_suff[vj] + 1)
        
        outs.append(' '.join(str(x + y - 1) for x, y in zip(dp_pref, dp_suff)))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<array<int, 3>> funcs(n);
		for (auto &[a, b, c]: funcs) cin >> a >> b >> c;
		
		vector<int> order(n);
		iota(order.begin(), order.end(), 0);
		sort(order.begin(), order.end(), [&] (int i, int j) {
			return funcs[i][2] < funcs[j][2];
		});

		vector<int> dp_pref(n, 1), dp_suff(n, 1);

		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < i; j ++) {
				int vi = order[i], vj = order[j];

				if (funcs[vi][0] == funcs[vj][0]) {
					if (funcs[vi][1] == funcs[vj][1])
						dp_pref[vi] = max(dp_pref[vi], dp_pref[vj] + 1);
				}
				else {
					int a = funcs[vi][0] - funcs[vj][0];
					int b = funcs[vi][1] - funcs[vj][1];
					int c = funcs[vi][2] - funcs[vj][2];

					if (1ll * b * b < 4ll * a * c)
						dp_pref[vi] = max(dp_pref[vi], dp_pref[vj] + 1);
				}
			}
		}

		for (int i = n - 1; i >= 0; i --) {
			for (int j = i + 1; j < n; j ++) {
				int vi = order[i], vj = order[j];

				if (funcs[vi][0] == funcs[vj][0]) {
					if (funcs[vi][1] == funcs[vj][1])
						dp_suff[vi] = max(dp_suff[vi], dp_suff[vj] + 1);
				}
				else {
					int a = funcs[vi][0] - funcs[vj][0];
					int b = funcs[vi][1] - funcs[vj][1];
					int c = funcs[vi][2] - funcs[vj][2];

					if (1ll * b * b < 4ll * a * c)
						dp_suff[vi] = max(dp_suff[vi], dp_suff[vj] + 1);
				}
			}
		}

		for (int i = 0; i < n; i ++) cout << dp_pref[i] + dp_suff[i] - 1 << ' ';
		cout << '\n';
	}

	return 0;
}
```
