**提示 1：** 考虑每一个和中 $a_i$ 的权重。如何用它们凑出来答案？

我们先把每一个求和式中 $a_1,a_2,\dots,a_n$ 的权重列出来。

$[0,1,2,\dots,n-1]$

$[1,0,1,\dots,n-2]$

$\dots$

$[n-1,n-2,n-3,\dots,0]$

我们可以发现相邻两个之间是差别很小的。我们作差之后可以发现，前缀是 $1$ ，后缀是 $-1$ 。

这相当于两倍的前缀减去整体的和，整体的和是多少呢？

我们直接将第一行和最后一行相加，每个位置的权重就都是 $n-1$ 了。

所以我们根据这件事求出和，再根据两两相差的结果可以求出其他前缀和，最后用前缀和恢复数组就好。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        total = (nums[0] + nums[-1]) // (n - 1)
        
        ans = [0] * n
        cur = 0
        for i in range(n - 1):
            ans[i] = -(nums[i] - nums[i + 1] - total) // 2 - cur
            cur += ans[i]
        
        ans[-1] = total - cur
        
        outs.append(' '.join(map(str, ans)))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;
		
		vector<long long> nums(n);
		for (auto &v: nums) cin >> v;

		long long total = (nums[0] + nums[n - 1]) / (n - 1);
		int cur = 0;

		for (int i = 0; i < n - 1; i ++) {
			int x = -(nums[i] - nums[i + 1] - total) / 2 - cur;
			cur += x;
			cout << x << ' ';
		}

		cout << total - cur << '\n';
	}

	return 0;
}
```
