**提示 1：** 我们可以将 $(结点，上一条边的颜色)$ 作为状态进行搜索。但这样空间太大了，怎么更小呢？

**提示 2：** 其实不需要记录太多颜色。

先看提示 1 ，基于此怎么优化呢？

事实上只要两种不同的颜色的边都到达了结点 $u$ ，那么此时 $u$ 无论往外走是哪种颜色，都能找到合法的前面的路径。

所以我们只需记录到达每个位置的前两种颜色，这样状态数就被压缩到了 $\mathcal{O}(n)$ ，在这些状态之间进行 BFS / DFS 就好。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, m = MII()
        path = lst_lst(n)
        
        def f(x, y): return x * n + y
        
        for _ in range(m):
            u, v, c = GMI()
            path.append(u, f(c, v))
        
        vis = [[-2] * n for _ in range(2)]
        vis[0][0] = -1
        vis[1][0] = -1
        
        que = [0]
        
        for msk in que:
            u, time = divmod(msk, 2)
            
            for edge in path.iterate(u):
                c, v = divmod(edge, n)
                
                if vis[time][u] != c:
                    if vis[0][v] == -2:
                        vis[0][v] = c
                        que.append(2 * v)
                    elif vis[0][v] == c:
                        continue
                    elif vis[1][v] == -2:
                        vis[1][v] = c
                        que.append(2 * v + 1)
        
        outs.append(' '.join(str(i + 1) for i in range(n) if vis[0][i] != -2))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, m;
		cin >> n >> m;

		vector<vector<pair<int, int>>> path(n);

		while (m --) {
			int u, v, c;
			cin >> u >> v >> c;
			u --, v --, c --;
			path[u].emplace_back(v, c);
		}

		vector<vector<int>> cols(2, vector<int>(n, -2));
		cols[0][0] = -1;
		cols[1][0] = -1;

		auto dfs = [&] (auto &self, int u, int cur) -> void {
			for (auto &[v, c]: path[u]) {
				if (cols[cur][u] != c) {
					if (cols[0][v] == -2) {
						cols[0][v] = c;
						self(self, v, 0);
					}
					else if (cols[0][v] == c) continue;
					else if (cols[1][v] == -2) {
						cols[1][v] = c;
						self(self, v, 1);
					}
				}
			}
		};

		dfs(dfs, 0, 0);

		for (int i = 0; i < n; i ++) {
			if (cols[0][i] != -2) {
				cout << i + 1 << ' ';
			}
		}
		cout << '\n';
	}

	return 0;
}
```
