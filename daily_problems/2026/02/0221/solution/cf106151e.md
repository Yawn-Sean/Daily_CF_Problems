**提示 1：** 如果选定了最终的集合，我们应该按照什么顺序操作呢？

如果我们选定了集合的话，那么第一部分的成本一定，第二部分的权值是递增的，所以应该按照第二类成本的系数递减的顺序进行。

因此先按照这个逻辑进行排序，再按顺序 DP 进行转移，就能保证选取的顺序满足前面提到的事了。

假设前 $i$ 个选了 $j$ 个，接下来枚举下一个要不要，就可以进行真正的 DP 转移了。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, b = MII()
    xs = LII()
    ys = LII()
    
    inf = 2 * 10 ** 9
    dp = [inf] * (n + 1)
    dp[0] = 0
    
    order = sorted(range(n), key=lambda x: -ys[x])
    
    for i in range(n):
        idx = order[i]
        x = xs[idx]
        y = ys[idx]
        
        for j in range(i, -1, -1):
            dp[j + 1] = fmin(dp[j + 1], dp[j] + x + y * j)
    
    for i in range(n, -1, -1):
        if dp[i] <= b:
            print(i, dp[i])
            break
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, b;
	cin >> n >> b;

	vector<int> xs(n), ys(n);
	for (auto &x: xs) cin >> x;
	for (auto &y: ys) cin >> y;

	vector<int> order(n);
	iota(order.begin(), order.end(), 0);
	sort(order.begin(), order.end(), [&] (int i, int j) {
		return ys[i] > ys[j];
	});

	long long inf = 2e9;
	vector<long long> dp(n + 1, inf);

	dp[0] = 0;

	for (int i = 0; i < n; i ++) {
		int idx = order[i];
		int x = xs[idx], y = ys[idx];

		for (int j = i; j >= 0; j --) {
			dp[j + 1] = min(dp[j + 1], dp[j] + x + 1ll * j * y);
		}
	}

	for (int i = n; i >= 0; i --) {
		if (dp[i] <= b) {
			cout << i << ' ' << dp[i] << '\n';
			break;
		}
	}

	return 0;
}
```
