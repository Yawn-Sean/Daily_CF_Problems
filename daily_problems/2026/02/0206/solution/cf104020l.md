**提示 1：** 点是随机的，所以答案不会很大。

**提示 2：** 利用上面这件事。

首先，点应该比较均匀的分布在整个空间内，从这个角度来看，答案不可能很大。

具体而言，我们可以拆成 $10^9$ 个大小为 $10^6$ 的立方体， $n$ 个点恰好在完全不同的立方体的概率仅为千分之 $6$ 左右（类似于生日悖论），所以答案是这个量级的。

既然答案很小，我们就没必要检查太远的两个点。如何筛选两个没那么远的点呢？我们直接关于横坐标排序，横坐标之差不能超过 $10^6$ 往上的一个量级。同时如果横坐标是均匀的话，相邻两个差是 $10^4$ ，所以大概只需遍历间隔 $100$ 量级以内的点就够了。

时间复杂度为 $\mathcal{O}(n\log n+nk)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    pts = []
    
    for _ in range(n):
        pts.append(tuple(MII()))
    
    pts.sort()
    ans = 4 * 10 ** 18
    
    for i in range(n):
        x1, y1, z1 = pts[i]
        for j in range(fmax(i - 100, 0), i):
            x2, y2, z2 = pts[j]
            ans = fmin(ans, (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1))
    
    print(math.sqrt(ans))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<array<int, 3>> pts(n);
	for (auto &[x, y, z]: pts) cin >> x >> y >> z;

	sort(pts.begin(), pts.end());

	long long ans = 4e18;

	for (int i = 0; i < n; i ++) {
		auto [x1, y1, z1] = pts[i];

		for (int j = max(0, i - 100); j < i; j ++) {
			auto [x2, y2, z2] = pts[j];

			ans = min(ans, 1ll * (x2 - x1) * (x2 - x1) + 1ll * (y2 - y1) * (y2 - y1) + 1ll * (z2 - z1) * (z2 - z1));
		}
	}

	cout << fixed << setprecision(10) << sqrtl(ans);

	return 0;
}
```
