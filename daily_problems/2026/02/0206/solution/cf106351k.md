**提示 1：** 考虑枚举。怎么枚举可以保证总枚举次数不大呢？

考虑枚举最小公倍数。

那么两个数本身都是最小公倍数的因子。而 $10^5$ 以内的数的因子个数不会太多，因此考虑枚举所有的因子对，看其是否满足最小公倍数是目标的最小公倍数，且最大公约数是否满足要求。

如果满足要求，答案加上两个数的出现频率之积。

当然取的两个数可能数值相等，补上这部分就好。

时间复杂度为 $\mathcal{O}(\log M\sum d^2(i))$ ，其中 $d(i)$ 表示 $i$ 因子个数。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    M = 100000
    factors = [[] for _ in range(M + 1)]
    
    for i in range(1, M + 1):
        for j in range(i, M + 1, i):
            factors[j].append(i)
    
    n, x, y = MII()
    nums = LII()
    
    cnt = [0] * (M + 1)
    for v in nums:
        cnt[v] += 1
    
    ans = 0
    
    for i in range(x, y + 1):
        ans += cnt[i] * (cnt[i] - 1) // 2
        
        l = len(factors[i])
        for j in range(l):
            for k in range(j):
                g = math.gcd(factors[i][j], factors[i][k])
                if g >= x and factors[i][j] * factors[i][k] // g == i:
                    ans += cnt[factors[i][j]] * cnt[factors[i][k]]
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int M = 1e5;
	vector<vector<int>> factors(M + 1);

	for (int i = 1; i <= M; i ++) {
		for (int j = i; j <= M; j += i) {
			factors[j].emplace_back(i);
		}
	}

	int n, x, y;
	cin >> n >> x >> y;

	vector<int> cnt(M + 1, 0);
	while (n --) {
		int x;
		cin >> x;
		cnt[x] ++;
	}

	long long ans = 0;

	for (int i = x; i <= y; i ++) {
		ans += 1ll * cnt[i] * (cnt[i] - 1) / 2;
		for (int j = 0; j < factors[i].size(); j ++) {
			for (int k = 0; k < j; k ++) {
				int g = gcd(factors[i][j], factors[i][k]);
				if (g >= x && 1ll * factors[i][j] * factors[i][k] / g == i) {
					ans += 1ll * cnt[factors[i][j]] * cnt[factors[i][k]];
				}
			}
		}
	}

	cout << ans;

	return 0;
}
```
