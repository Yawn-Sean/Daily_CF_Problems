**提示 1：** 考虑块内和块间的逆序对。

每个块内的逆序对数很容易统计。可以用树状数组，也可以直接利用字符集较小，统计前面更大的字符数量做到。这个答案需要乘 $n$ 。

而块间，只要两个字符 $s_i,s_j$ 不同，任选两个块，那么要么 $s_i$ 在前形成逆序对，要么 $s_j$ 在前形成逆序对。所以任意一对不同的字符在任意两个不同的块间恰好形成一个逆序对。因此只需统计对应字符对的个数，再乘 $\frac{n(n-1)}{2}$ 种选块的方法就好。

注意 $n$ 较大，但 $n$ 在后续处理前先取模不影响结果，所以开头取模就好。

时间复杂度为 $\mathcal{O}(n|\Sigma|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    s = I()
    n = II()
    mod = 10 ** 9 + 7
    
    n %= mod
    
    ans = 0
    cnt = [0] * 26
    
    for c in s:
        ch = ord(c) - ord('a')
        
        for i in range(ch + 1, 26):
            ans += cnt[i]
        
        cnt[ch] += 1
    
    ans = n * ans % mod
    
    for i in range(26):
        for j in range(i):
            ans += n * (n - 1) // 2 % mod * cnt[i] % mod * cnt[j] % mod
            ans %= mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

    string s;
    long long n;
    int mod = 1e9 + 7;

    cin >> s >> n;
    n %= mod;

    vector<int> cnt(26, 0);
    int ans = 0;

    for (auto &c: s) {
        int ch = c - 'a';
        for (int j = ch + 1; j < 26; j ++) {
            ans += cnt[j];
            ans %= mod;
        }
        cnt[ch] ++;
    }

    ans = n * ans % mod;

    for (int i = 0; i < 26; i ++) {
        for (int j = 0; j < i; j ++) {
            ans += n * (n - 1) / 2 % mod * cnt[i] % mod * cnt[j] % mod;
            ans %= mod;
        }
    }

    cout << ans;

	return 0;
}
```
