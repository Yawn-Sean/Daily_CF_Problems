**提示 1：** 需要检查什么条件？

**提示 2：** 条件下如何构造？

首先，要将数组分配成两部分，使得两部分和相等，这件事显然可以检查和的一半能否用数组中的元素凑到，而这可以用背包问题解决。

于是我们预先确定了两个人分别拿哪些东西，接下来就考虑顺序就好。

我们只需在第一个人的和更少的时候分配给第一个人，否则分配给第二个人就行。这样做的合法性 / 可以完全构造是很容易验证的。

时间复杂度为 $\mathcal{O}(n^2M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    total = sum(nums)
    
    if total % 2:
        print(-1)
    else:
        M = total // 2
    
        dp = [-2] * (M + 1)
        dp[0] = -1
        
        for i in range(n):
            x = nums[i]
            
            for j in range(M, x - 1, -1):
                if dp[j - x] != -2 and dp[j] == -2:
                    dp[j] = i
        
        if dp[M] == -2:
            print(-1)
        else:
            vis = [0] * n
            cur = M
            
            while cur:
                vis[dp[cur]] = 1
                cur -= nums[dp[cur]]
            
            v1 = [nums[i] for i in range(n) if vis[i]]
            v2 = [nums[i] for i in range(n) if not vis[i]]
            
            s1 = s2 = 0
            pt1 = pt2 = 0
            
            ans = []
            
            while pt1 < len(v1) or pt2 < len(v2):
                if s1 <= s2:
                    s1 += v1[pt1]
                    ans.append(v1[pt1])
                    pt1 += 1
                else:
                    s2 += v2[pt2]
                    ans.append(v2[pt2])
                    pt2 += 1
            
            print(*ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	int total = 0;
	vector<int> nums(n);

	for (auto &v: nums) cin >> v, total += v;

	if (total & 1) cout << -1;
	else {
		int M = total / 2;

		vector<int> dp(M + 1, -2);
		dp[0] = -1;

		for (int i = 0; i < n; i ++) {
			int x = nums[i];
			for (int j = M; j >= x; j --) {
				if (dp[j - x] != -2 && dp[j] == -2) {
					dp[j] = i;
				}
			}
		}

		if (dp[M] == -2) cout << -1;
		else {
			vector<int> vis(n, 0);
			int cur = M;

			while (cur) {
				vis[dp[cur]] = 1;
				cur -= nums[dp[cur]];
			}

			vector<int> v1, v2;
			for (int i = 0; i < n; i ++) {
				if (vis[i]) v1.emplace_back(nums[i]);
				else v2.emplace_back(nums[i]);
			}

			int s1 = 0, s2 = 0, pt1 = 0, pt2 = 0;

			while (pt1 < v1.size() || pt2 < v2.size()) {
				if (s1 <= s2) {
					cout << v1[pt1] << ' ';
					s1 += v1[pt1];
					pt1 ++;
				}
				else {
					cout << v2[pt2] << ' ';
					s2 += v2[pt2];
					pt2 ++;
				}
			}
		}
	}

	return 0;
}
```
