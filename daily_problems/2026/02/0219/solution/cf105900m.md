**提示 1：** 首先求最短路。

**提示 2：** 考虑 DP ，转移都在最短路上。

因为答案有最短路，同时后面的一项也要求是最短路上的，所以先求最短路。

接下来考虑 DP，到 $x$ 为止用最短路用的最长边的最小值。

则从 $u$ 到 $v$ 怎么状态转移呢？

我们先看其最短路长度的差是否是 $w$ ，如果是则可以转移。

此时 $v$ 可以用 $\max(ans[u],w)$ 进行更新。

如何保证是按照拓扑序进行更新的呢？事实上只需按照最短路长度从小到大为顺序进行 DP 就行，而这个顺序在求最短路的过程中很容易得到。

这似乎比官方题解好写多了。

时间复杂度为 $\mathcal{O}(m+n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    path = [[] for _ in range(n)]
    
    def f(d, u):
        return d * n + u
    
    for _ in range(m):
        u, v, w = MII()
        u -= 1
        v -= 1
        path[u].append(f(w, v))
    
    inf = 10 ** 12
    
    dis = [inf] * n
    dis[0] = 0
    
    pq = [f(0, 0)]
    
    order = []
    
    while pq:
        d, u = divmod(heappop(pq), n)
        if dis[u] == d:
            order.append(u)
            for msk in path[u]:
                w, v = divmod(msk, n)
                if dis[v] > dis[u] + w:
                    dis[v] = dis[u] + w
                    heappush(pq, f(dis[v], v))
    
    ans = [inf] * n
    ans[0] = 0
    
    for u in order:
        for msk in path[u]:
            w, v = divmod(msk, n)
            if dis[v] == dis[u] + w:
                ans[v] = fmin(ans[v], fmax(ans[u], w))
    
    print(dis[n - 1], ans[n - 1])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<vector<pair<int, int>>> path(n);

	while (m --) {
		int u, v, w;
		cin >> u >> v >> w;
		u --, v --;
		path[u].emplace_back(v, w);
	}

	long long inf = 1e12;
	vector<long long> dis(n, inf);

	dis[0] = 0;

	priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
	pq.push({0, 0});

	vector<int> order;

	while (!pq.empty()) {
		auto [d, u] = pq.top(); pq.pop();
		if (dis[u] == d) {
			order.emplace_back(u);
			for (auto &[v, w]: path[u]) {
				if (dis[v] > d + w) {
					dis[v] = d + w;
					pq.push({dis[v], v});
				}
			}
		}
	}

	vector<int> ans(n, 1'000'000);
	ans[0] = 0;

	for (auto &u: order) {
		for (auto &[v, w]: path[u]) {
			if (dis[v] == dis[u] + w) {
				ans[v] = min(ans[v], max(ans[u], w));
			}
		}
	}

	cout << dis[n - 1] << ' ' << ans[n - 1];

	return 0;
}
```
