**提示 1：** 原数减去 $k$ 满足啥条件？

首先，数字减去 $k$ 得同时是所有 $a_i$ 的倍数。所以你只要求所有 $a_i$ 的最小公倍数，保证答案是这个数的倍数 $+k$ 就行。

几个需要处理的细节：

- 最小公倍数太大了咋办？跟一个大数取最小值，进行截断。

- 因为 $k$ 是余数，所以必须比 $a_i$ 中每个数都要小。否则直接无法构造。

最后我们怎么找到 $[l,r]$ 之间的数呢？减去 $k$ 的数据范围是 $[l-k,r-k]$ ，为此我们直接求 $r-k$ 以下最大的倍数，看是否大于 $l-k$ 就行。

时间复杂度为 $\mathcal{O}(n+\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, l, r, k = MII()
    nums = LII()
    
    if min(nums) <= k: print(-1)
    else:
        ans = 1
        bound = 10 ** 12
        for x in nums:
            ans = math.lcm(x, ans)
            ans = fmin(ans, bound)
        
        ans = (r - k) // ans * ans + k
        print(ans if l <= ans <= r else -1)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	long long l, r, k;
	cin >> n >> l >> r >> k;

	vector<long long> nums(n);
	for (auto &v: nums) cin >> v;

	if (*min_element(nums.begin(), nums.end()) <= k || r < k)
		cout << -1;
	else {
		long long ans = 1;
		__int128_t bound = 1e12;

		for (auto &x: nums)
			ans = min((__int128_t)x * ans / gcd(x, ans), bound);

		ans = (r - k) / ans * ans + k;
		cout << (ans >= l && ans <= r ? ans : -1);
	}

	return 0;
}
```
