**提示 1：** 数组一般是递增的。如果某个位置非递增呢？

**提示 2：** 剩余的情况？

这个数组几乎每个位置都是递增的，但如果有个位置非递增，那一定跨行了。

而某两个数跨行了的话，第二个数就一定是行号了，此时第一个数在前一行，我们就能很快算出第一个数是第几列，也就找到答案了。

否则数组单调递增，此时直接考虑最后一个元素在第几行第几列即可。此时整体是等差数列，我们只需计算公差就知道是第几行，进而用除法可以快速算出是在第几列。

出题人还是比较善良的，保证了 $n\geq 2$ ，不然你还得找下 $n$ 的因子。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        for i in range(n - 1):
            if nums[i] >= nums[i + 1]:
                outs.append(nums[i] // (nums[i + 1] - 1))
                break
        else:
            outs.append(fmax(nums[-1] - nums[-2], nums[-1] // (nums[-1] - nums[-2])))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		int ans = -1;
		for (int i = 1; i < n; i ++) {
			if (nums[i] <= nums[i - 1]) {
				ans = nums[i - 1] / (nums[i] - 1);
			}
		}

		if (ans == -1) ans = max(nums[n - 1] - nums[n - 2], nums[n - 1] / (nums[n - 1] - nums[n - 2]));
		cout << ans << '\n';
	}

	return 0;
}
```
