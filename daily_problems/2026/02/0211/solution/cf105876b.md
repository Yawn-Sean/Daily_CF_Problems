**提示 1：** 可以打表找下规律。想想为什么？

首先 $n\bmod 4=3$ 时，显然无法构造，因为所有数的异或和刚好是 $0$ 。

对于其他情况，字典序最小的排列是 $[1,2,\dots,n]$ ，但这样 $4k+3$ 的位置都会矛盾。如何尽可能少的调整呢？发现跟 $4k+4$ 进行交换就够了。这样调整显然使得字典序的增大幅度最小。

可以顺便复习下 $1\sim i$ 的异或和。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    if n % 4 == 3: print(-1)
    else:
        ans = list(range(1, n + 1))
        
        for i in range(3, n, 4):
            ans[i - 1], ans[i] = ans[i], ans[i - 1]
        
        print(*ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	if (n % 4 == 3) cout << -1;
	else {
		vector<int> nums(n);
		iota(nums.begin(), nums.end(), 1);

		for (int i = 3; i < n; i += 4)
			swap(nums[i - 1], nums[i]);

		for (auto &x: nums) cout << x << ' ';
	}

	return 0;
}
```
