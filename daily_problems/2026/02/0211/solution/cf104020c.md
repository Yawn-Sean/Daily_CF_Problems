**提示 1：** 如果打了 $x$ 个字，下一个操作是什么？

**提示 2：** 根据上述过程设计 DP 。

如果我们目前保证打了 $x$ 个字且保存了，下一步是什么？

下一步是打到 $y$ 个字的时候保存。（不会受当前打了几个字影响）

所以我们只需记录到第 $x$ 个字时保存所需的最小总时间作为 $DP[x]$ 即可。我们只需枚举最近一次保存是啥时候。

接下来我们只需计算相邻两次之间转移所需的时间，即打到 $v$ 个字的期望时间，再加上保存时间。

有 $f(v)=f(v-1)+1+p(r+f(v))$ ，相当于你得先敲上 $v-1$ 个字符并多一份时间。其中还有 $p$ 的概率你要重开，时间是 $r+f(v)$ 。于是你得到了相邻的 $v$ 之间的 $f(v)$ 的递推关系，数值也就很好求了。

时间复杂度为 $\mathcal{O}(c^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    c, t, r = map(int, input().split())
    p = float(input())
    
    time = [0] * (c + 1)
    
    for i in range(c):
        time[i + 1] = (time[i] + 1 + p * r) / (1 - p)
    
    inf = 10 ** 18
    dp = [inf] * (c + 1)
    dp[0] = 0
    
    for i in range(1, c + 1):
        for j in range(i + 1):
            dp[i] = fmin(dp[i], dp[i - j] + time[j] + t)
    
    print(dp[c])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int c, t, r;
	double p;
	cin >> c >> t >> r >> p;

	vector<double> time(c + 1, 0);
	for (int i = 0; i < c; i ++)
		time[i + 1] = (time[i] + 1 + p * r) / (1 - p);

	vector<double> dp(c + 1, 1e18);
	dp[0] = 0;
	for (int i = 1; i <= c; i ++) {
		for (int j = 0; j <= i; j ++) {
			dp[i] = min(dp[i], dp[i - j] + time[j] + t);
		}
	}

	cout << fixed << setprecision(10) << dp[c];

	return 0;
}
```
