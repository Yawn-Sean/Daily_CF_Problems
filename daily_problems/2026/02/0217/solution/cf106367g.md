**提示 1：** 每个元素只用删一次，所以只需较快地（如 $\mathcal{O}(\log n)$ ）时间找到元素并删除就好。

先看提示。

怎么找到元素呢，我们可以找 $l$ 右侧第一个不小于 $x$ 的数，这件事显然可以用最大值线段树进行树上二分找到。如果位置大于 $r$ 则退出，否则我们找到了第一个数。

接下来为了让这个位置废掉，我们直接赋值为 $-1$ ，重复上述步骤直到区间 $[l,r]$ 内没有更大的数。

这样每次查询需要开头确定区间内是否有需要删掉的数，接下来每个删掉的数需要 $\mathcal{O}(\log n)$ 复杂度，同时删掉的数之后不会带来新的复杂度。

时间复杂度为 $\mathcal{O}(n\log n+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, q = MII()
    nums = LII()
    seg = SegTree(fmax, -1, nums)
    
    outs = []
    for _ in range(q):
        l, r, val = MII()
        l -= 1
        
        ans = 0
        
        while True:
            l = seg.max_right(l, lambda x: x < val)
            if l >= r: break
            
            ans += nums[l]
            seg.set(l, -1)
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int op(int x, int y) {return max(x, y);}

int e() {return -1;}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, q;
	cin >> n >> q;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	atcoder::segtree<int, op, e> seg(nums);

	while (q --) {
		int l, r, x;
		cin >> l >> r >> x;
		l --;

		long long ans = 0;

		while (true) {
			l = seg.max_right(l, [&] (int v) {return v < x;});
			if (l >= r) break;
			ans += nums[l];
			seg.set(l, -1);
		}

		cout << ans << '\n';
	}

	return 0;
}
```
