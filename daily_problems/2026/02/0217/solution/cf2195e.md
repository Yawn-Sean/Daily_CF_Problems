**提示 1：** 将走到 $0$ 的过程一步步考虑。

**提示 2：** 有些成分是一样的。

每个点是怎么走到 $0$ 的呢？

首先，会先遍历一遍子树，然后走到父节点。而走到父节点后又跟起点是父节点是一回事了。

所以每个结点的答案等于该子树遍历的总边数 + 1 + 父节点的答案。

子树遍历的总边数等于 2 乘子树的边数，这件事很容易用树上 DP 快速解决。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    mod = 10 ** 9 + 7
    
    for _ in range(t):
        n = II()
        path = [[] for _ in range(n + 1)]
        path[0].append(1)
        for i in range(1, n + 1):
            u, v = MII()
            if u and v:
                path[i].append(u)
                path[i].append(v)
    
        que = [0]
        parent = [-1] * (n + 1)
        for u in que:
            for v in path[u]:
                parent[v] = u
                que.append(v)
    
        sz = [0] * (n + 1)
        
        for i in reversed(que):
            if path[i] and i > 0:
                u, v = path[i]
                sz[i] = (sz[u] + 2 + sz[v] + 2) % mod
        
        for i in que:
            for j in path[i]:
                sz[j] += sz[i] + 1
                sz[j] %= mod
        
        outs.append(' '.join(map(str, sz[1:])))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t, mod = 1e9 + 7;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<pair<int, int>> path(n + 1);
		path[0].first = 1, path[0].second = 0;

		for (int i = 1; i <= n; i ++)
			cin >> path[i].first >> path[i].second;

		vector<int> sz(n + 1, 0);
		auto dfs = [&] (auto &self, int u, int p) -> void {
			if (path[u].first) {
				self(self, path[u].first, u);
				sz[u] += sz[path[u].first] + 2;
				self(self, path[u].second, u);
				sz[u] += sz[path[u].second] + 2;
			}
		};

		dfs(dfs, 1, 0);

		auto dfs1 = [&] (auto &self, int u, int p) -> void {
			if (path[u].first) {
				sz[path[u].first] += sz[u] + 1;
				sz[path[u].first] %= mod;
				self(self, path[u].first, u);
				sz[path[u].second] += sz[u] + 1;
				sz[path[u].second] %= mod;
				self(self, path[u].second, u);
			}
		};

		dfs1(dfs1, 1, 0);

		for (int i = 1; i <= n; i ++) cout << (sz[i] + 1) % mod << ' ';
		cout << '\n';
	}

	return 0;
}
```
