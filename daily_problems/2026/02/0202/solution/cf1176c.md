**提示 1：** 考虑最多能凑出来多少子序列。

**提示 2：** 考虑到第 $i$ 个位置最优的组合情况。

我们只需考虑最后留下了多少子序列，那么最后剩下的元素可以计算，要删掉多少个也就知道了。

考虑到第 $i$ 个元素。此时凑的子序列有 $6$ 种：只包含前 $1,2,3,4,5,6$ 个元素的。

那么新增一个元素时，如果它是第 $i$ 个元素，则如果有以第 $i-1$ 作结尾的序列，那就对其添加元素，这样贪心是最优的（严格证明好像容易但是繁杂就不写了，希望能理解到）。

而我们也只需统计各个序列的数量。每遍历一个元素只对最多两个序列的数量进行更新，也就完成了问题。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    d = {
        4: 1,
        8: 2,
        15: 3,
        16: 4,
        23: 5,
        42: 6
    }
    
    n = II()
    nums = LII()
    
    cnt = [0] * 7
    cnt[0] = n
    
    for x in nums:
        x = d[x]
        
        if cnt[x - 1]:
            cnt[x - 1] -= 1
            cnt[x] += 1
    
    print(n - 6 * cnt[6])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	map<int, int> mp;
	mp[4] = 1, mp[8] = 2, mp[15] = 3, mp[16] = 4, mp[23] = 5, mp[42] = 6;

	vector<int> cnt(7, 0);
	cnt[0] = n;

	for (int i = 0; i < n; i ++) {
		int x;
		cin >> x;

		x = mp[x];
		if (cnt[x - 1]) cnt[x - 1] --, cnt[x] ++;
	}

	cout << n - 6 * cnt[6];

	return 0;
}
```
