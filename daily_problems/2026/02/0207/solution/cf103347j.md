**提示 1：** 枚举 $k\bmod p$ ，则 $x^k$ 需要满足什么条件？

**提示 2：** 如何找到满足两个条件的 $k$ ？

首先，我们枚举 $k\bmod p=i$ ，则找到对应的逆元可以找到 $x^k$ 需要满足的取模结果。

而由于 $x^{p-1}\bmod p=1$ ，所以后者是循环的，且循环节是 $p-1$ 的因子，所以设循环节是 $v$ ， $k$ 需要同时满足 $k\bmod v=j$ 。

设 $k$ 是 $pX+i$ ，则 $pX+i=(p-1)X+X+i$ ，于是关于 $v$ 的取模结果就是 $X+i$ ，所以可以直接根据 $(X+i)\bmod v=j$ 得到一组可行的 $X_0$ ，进而得到一组可行的 $k_0$ ，于是 $k_0+K\times v\times p$ 都是解，统计在区间内的个数就好。

时间复杂度为 $\mathcal{O}(p)$ ，因为下面代码里面的逆元可以 $\mathcal{O}(p)$ 预处理。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    p, x, y, a = MII()
    
    mods = [1]
    
    for _ in range(p):
        mods.append(mods[-1] * x % p)
        if mods[-1] == 1:
            mods.pop()
            break
    
    k = len(mods)
    pos = [-1] * p
    
    for i in range(k):
        pos[mods[i]] = i
    
    ans = 0
    for i in range(1, p):
        v = pow(i, p - 2, p) * y % p
        if pos[v] >= 0:
            j = pos[v]
            res = ((j - i) * p + i) % (k * p)
            ans += (a - res) // (k * p) + 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int p, x, y;
	long long a;
	cin >> p >> x >> y >> a;

	vector<int> mods = {1};
	
	for (int i = 0; i < p; i ++) {
		mods.emplace_back(1ll * mods.back() * x % p);

		if (mods.back() == 1) {
			mods.pop_back();
			break;
		}
	}

	int k = mods.size();
	vector<int> pos(p, -1);

	for (int i = 0; i < k; i ++)
		pos[mods[i]] = i;

	long long ans = 0, cycle = 1ll * k * p;
	for (int i = 1; i < p; i ++) {
		int v = quickPow(i, p - 2, p) * y % p;
		if (pos[v] >= 0) {
			long long res = (1ll * (pos[v] - i) * p + i) % cycle;
			if (res < 0) res += cycle;
			if (a >= res) ans += (a - res) / cycle + 1;
		}
	}

	cout << ans;

	return 0;
}
```
