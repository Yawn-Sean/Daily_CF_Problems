**提示 1：** 每一位独立，可以单独考虑再乘起来。注意细节。

先看提示。接下来考虑各个细节。

考虑某一位。

如果 AND 的数值是 $1$ ，则每一位都只能是 $1$ ，如果 OR 和 XOR 数值都是对的，则方案数是 $1$ ，否则是 $0$ 。

不然的话， AND 的数值就是 $0$ 。如果 OR 的数值是 $0$ 则只能每个数都是 $0$ 了，如果 XOR 符合要求则方案数是 $1$ ，否则是 $0$ 。

只剩下 AND 是 $0$ ， OR 是 $1$ 的情况了。我们先忽略这两个条件。 XOR 符合要求的方案数是 $2^{n-1}$ 种。

其中是否有不满足上面 AND / OR 的条件的呢？不满足 AND 的条件的只能是全都是 $1$ 的情况，不满足 OR 条件的只能是全都是 $0$ 的情况。如果这两种情况 XOR 符合要求，则意味着在之前的方案数中被计入了，而实际上不应该计入，因此应该去掉它们。（后面代码中写得蛮清楚）

时间复杂度为 $\mathcal{O}(\log m+|s|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    and_val = [int(c) for c in I()]
    or_val = [int(c) for c in I()]
    xor_val = [int(c) for c in I()]
    
    k = len(and_val)
    
    ans = 1
    mod = 10 ** 9 + 7
    
    saved = pow(2, n - 1, mod)
    
    for i in range(k):
        res = 0
        
        if and_val[i]:
            if or_val[i] and n % 2 == xor_val[i]:
                res = 1
        else:
            if or_val[i] == 0:
                if xor_val[i] == 0:
                    res = 1
            else:
                if n >= 2:
                    res = saved
                    if xor_val[i] == 0:
                        res -= 1
                        res %= mod
                    if n % 2 == xor_val[i]:
                        res -= 1
                        res %= mod
        
        ans = ans * res % mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	long long n;
	cin >> n;

	string and_val, or_val, xor_val;
	cin >> and_val >> or_val >> xor_val;

	int k = and_val.size();
	int ans = 1, mod = 1e9 + 7;

	int saved = quickPow(2, n - 1, mod);

	for (int i = 0; i < k; i ++) {
		int res = 0;
		if (and_val[i] == '1') {
			if (or_val[i] == '1' && n % 2 == xor_val[i] - '0') {
				res = 1;
			}
		}
		else {
			if (or_val[i] == '0') {
				if (xor_val[i] == '0') {
					res = 1;
				}
			}
			else {
				if (n >= 2) {
					res = saved;
					if (xor_val[i] == '0') res = (res + mod - 1) % mod;
					if (n % 2 == xor_val[i] - '0') res = (res + mod - 1) % mod;
				}
			}
		}

		ans = 1ll * ans * res % mod;
	}

	cout << ans;

	return 0;
}
```
