**提示 1：** 如果不加入新物品，咋处理？

**提示 2：** 新物品可能带来什么改变？

如果不加入新物品，考虑枚举最小的 $y$ ，则我们可以在满足这样的 $y$ 的元素中选取 $y+1$ 个数值最大的。

为此，我们可以从大到小遍历所有的 $y$ ，这样可选集不断变大，我们相当于增加元素的情况下选取 $y+1$ 个最大的元素，这件事可以用堆快速维护。

接下来，新增元素 $(x',y')$ 个怎么办？如果新增元素不选，显然已经处理过了。

否则，我们在初始情况下，预处理选取 $y$ 最小值为 $y_0$ 的情况下，选取 $y_0$ 个元素的最大和。这件事跟前面的贪心过程只差了一个元素，可以快速维护。则我们可选的 $y'\leq y_0$ ，也就是一个前缀，我们只需记录下前缀最大值就可以快速选出来了。

时间复杂度为 $\mathcal{O}(n\log n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n, m = MII()
        
        tmp = [[] for _ in range(n + 1)]
        for _ in range(n):
            x, y = MII()
            tmp[y].append(x)
        
        ans = 0
        to_add = [0] * (n + 1)
        
        pq = []
        cur = 0
        
        for i in range(n, -1, -1):
            for x in tmp[i]:
                heappush(pq, x)
                cur += x
            while len(pq) > i + 1:
                cur -= heappop(pq)
            
            ans = fmax(ans, cur)
            to_add[i] = cur - (pq[0] if len(pq) == i + 1 else 0)
        
        for i in range(1, n + 1):
            to_add[i] = fmax(to_add[i], to_add[i - 1])
        
        res = []
        for _ in range(m):
            x, y = MII()
            res.append(fmax(ans, to_add[y] + x))
        
        outs.append(' '.join(map(str, res)))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, q;
		cin >> n >> q;

		vector<vector<int>> tmp(n + 1);

		for (int i = 0; i < n; i ++) {
			int x, y;
			cin >> x >> y;
			tmp[y].emplace_back(x);
		}

		long long ans = 0;
		vector<long long> to_add(n + 1, 0);
		priority_queue<int, vector<int>, greater<int>> pq;
		long long cur = 0;

		for (int i = n; i >= 0; i --) {
			for (auto &x: tmp[i]) {
				pq.push(x);
				cur += x;
			}
			while (pq.size() > i + 1) {
				cur -= pq.top();
				pq.pop();
			}

			ans = max(ans, cur);
			to_add[i] = cur - (pq.size() == i + 1 ? pq.top() : 0);
		}

		for (int i = 1; i <= n; i ++)
			to_add[i] = max(to_add[i], to_add[i - 1]);

		while (q --) {
			int x, y;
			cin >> x >> y;
			cout << max(ans, to_add[y] + x) << ' ';
		}
		cout << '\n';
	}

	return 0;
}
```
