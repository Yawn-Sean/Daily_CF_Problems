**提示 1：** 尝试固定一些什么。

**提示 2：** 设点到下底的距离是 $x$ 。答案咋办？

设点到下底的距离是 $x$ ，则下面部分的面积是 $\frac{b_1x}{2}$ ，上面部分的面积是 $\frac{b_2(h-x)}{2}$ 。

此时左右两边的面积和是确定的，同时可以任意分配，显然均分是最好的。

所以四块面积都表示出来了，都是 $x$ 的一次函数。

这个函数实际上是凸的，所以可以使用二分快速解决。同时取等时，上述三者一定至少有两个相等，因此也可以解方程找 $x$ 最后推答案。

时间复杂度为 $\mathcal{O}(1)$ 或 $\mathcal{O}(\log\frac{1}{\epsilon^{-1}})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    b1, b2, h = MII()
    
    def f(x):
        tmp = [b1 * x, b2 * (h - x), ((b1 + b2) * h - b1 * x - b2 * (h - x)) / 2]
        return max(tmp) - min(tmp)
    
    l, r = 0, h
    
    for _ in range(100):
        mid1 = (l * 2 + r) / 3
        mid2 = (l + r * 2) / 3
        
        if f(mid1) < f(mid2): r = mid2
        else: l = mid1
    
    print(f((l + r) / 2) / 2)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int b1, b2, h;
	cin >> b1 >> b2 >> h;

	auto f = [&] (long double x) -> long double {
		vector<long double> tmp = {
			b1 * x,
			b2 * (h - x),
			((b1 + b2) * h - b1 * x - b2 * (h - x)) / 2
		};

		return *max_element(tmp.begin(), tmp.end()) - *min_element(tmp.begin(), tmp.end());
	};

	long double l = 0, r = h;

	for (int i = 0; i < 100; i ++) {
		long double mid1 = (l * 2 + r) / 3;
		long double mid2 = (l + r * 2) / 3;

		if (f(mid1) < f(mid2)) r = mid2;
		else l = mid1;
	}

	cout << fixed << setprecision(20) << f((l + r) / 2) / 2;

	return 0;
}
```
