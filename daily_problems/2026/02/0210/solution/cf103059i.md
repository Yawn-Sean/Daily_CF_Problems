**提示 1：** 先根据题目猜一下什么 $n$ 可构造。尝试证明一下。

**提示 2：** 对于可构造的，尝试固定结果。

如果 $n$ 存在两个以上的不同质因子 $p,q$ ，则因为变成 $p$ 的倍数后就变不回来了，所以最后 $n/p$ 项是 $p$ 的倍数。同理，最后 $n/q$ 项是 $q$ 的倍数。

不妨 $p\lt q$ ，则最后 $n/q$ 项是 $pq$ 的倍数，但没那么多 $pq$ 的倍数，所以矛盾。

所以 $n$ 只能是质数的幂次，即 $n=p^a$ 。如果 $a\geq 2$ ，则最后 $a$ 项是 $p$ 的倍数，但实际上有 $p^{a-1}$ 个 $p$ 的倍数，所以 $p^{a-1}\leq a$ ，只有解 $(p,a)=(2,2)$ 。

所以你需要单独构造下 $n=4$ 的情况。

只剩下 $n=1$ 或者质数了。前者显然。对于后者，我们不妨令前缀乘积的取模结果是 $[1,2,\dots,n-1,0]$ 。

这样中间的值会重复吗？事实上，相当于 $\frac{i+1}{i}$ 的形式在取模意义下是否会重复，而这等价于 $\frac{1}{i}$ 是否重复。不同整数逆元显然不同，所以不会重复，也就得到了合法构造。

时间复杂度为 $\mathcal{O}(n)$ ，下面代码中逆元复杂度稍高。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    
    if n == 1:
        print('1')
    elif n == 4:
        print('1 3 2 4')
    else:
        for i in range(2, n):
            if n % i == 0:
                print(-1)
                break
        else:
            ans = [1]
            for i in range(2, n):
                ans.append(i * pow(i - 1, -1, n) % n)
            ans.append(n)
            print(*ans)
```

C++ 做法如下——

```cpp []
long long quickPow(long long base, long long power, long long mod) {
    if (power == 0) return 1 % mod;
    long long cur = quickPow(base, power / 2, mod);
    return power & 1 ? base * cur % mod * cur % mod : cur * cur % mod; 
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	if (n == 1) cout << "1";
	else if (n == 4) cout << "1 3 2 4";
	else {
		bool flg = true;
		for (int i = 2; i < n; i ++) {
			if (n % i == 0) {
				flg = false;
			}
		}

		if (flg) {
			cout << "1 ";
			for (int i = 2; i < n; i ++)
				cout << 1ll * i * quickPow(i - 1, n - 2, n) % n << ' ';
			cout << n;
		}
		else cout << "-1";
	}

	return 0;
}
```
