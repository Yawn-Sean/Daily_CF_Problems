**提示 1：** 查询结果是最大值，所以不如找最大值的位置。

**提示 2：** 总得遍历一边数组吧 —— 接下来咋办？

我们要想办法找到相同的元素，对比其下标。

而查询结果是最大值，所以找 $n$ 比较合适。

我们肯定要遍历数组才能保证找到 $n$ 。我们不能两个下标都动，不然的话也太乱了。所以先查询 $(0,0),(0,1),\dots,(0,n-1)$ 。

如果数值都是 $n$ ，就意味着 $a_0=n$ 。接下来看 $(a_1,i)$ 的查询结果，如果是 $n$ ，我们就找到第二个数组的 $n$ 的位置了，也就能得到答案了。

否则我们找到了第二个数组中 $n$ 的位置，接下来找到第一个数组中 $n$ 的位置就行。我们直接查询第一个数组中每一个位置和第二个数组的非最大值位置就行。

共需要 $2n$ 次。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def query(i, j):
        print('?', i, j, flush=True)
        return II()
    
    def answer(x):
        print('!', x)
    
    n = II()
    vals = [query(0, i) for i in range(n)]
    
    if min(vals) == n:
        for i in range(n):
            if query(1, i) == n:
                answer(i)
                break
    else:
        idx = vals.index(n)
        to_query = idx - 1 if idx else idx + 1
        for i in range(n):
            if query(i, to_query) == n:
                answer((idx - i) % n)
                break
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	auto query = [&] (int i, int j) -> int {
		cout << "? " << i << ' ' << j << endl;
		int x; cin >> x;
		return x;
	};

	int idx = -1;
	bool flg = false;

	for (int i = 0; i < n; i ++) {
		if (query(0, i) == n) {
			if (idx != -1) flg = true;
			idx = i;
		}
	}

	if (!flg) {
		int to_query = (idx ? idx - 1 : 1);

		for (int i = 0; i < n; i ++) {
			if (query(i, to_query) == n) {
				cout << "! " << (idx - i + n) % n;
				break;
			}
		}
	}
	else {
		for (int i = 0; i < n; i ++) {
			if (query(1, i) == n) {
				cout << "! " << i;
				break;
			}
		}
	}

	return 0;
}
```
