**提示 1：** 从成本和操作来看，其实没那么多删子数组的方式。

**提示 2：** 子数组是一块块被删掉的。先预处理块，再最终 DP 。

首先，如果你删掉了一个长度不小于 $4$ 的子数组，你可以不断拆分为大小为 $2$ 或 $3$ 的数组，且总成本不增加，同时每个子数组仍然满足极差不超过 $k$ 。

所以删去的子数组长度只需考虑 $2,3$ 。

从最后结果来看，删去的子数组是一段段的，每一段相互独立。这样我们只要预处理每一段子数组的最小删除成本，再用线性 DP 进行后续处理就好了。

具体的，前面如何得到删掉 $[l,r]$ 的最小成本呢？考虑删除方式：

- 如果 $l,r$ 不是一起被删除的，则一定存在中间分割点，前面部分和后面部分的操作独立。也就用 $dp[l][i]+dp[i+1][r]$ 表示。

- 如果 $l,r$ 同时被删除，且是作为长度为 $2$ 的子数组。这样成本就应该用 $dp[l+1][r-1]+1$ 更新。

- 如果 $l,r$ 同时被删除，且是作为长度为 $3$ 的子数组。此时应该枚举中间跟 $l,r$ 同时被删除的元素 $i$ ，用 $dp[l+1][i-1]+dp[i+1][r-1]+1$ 更新。

当然上面删除的时候需要判断下最大值减最小值是否在范围内的条件。

而最终结果的 DP 数组的转移就可以利用前面区间处理的结果。

$dp_1[i]$ 可以不删除第 $i+1$ 个元素转移到 $dp_1[i+1]$ ，也可以删去 $[i+1,j]$ 的元素转移到 $dp_1[j]$ ，这就覆盖了所有的状态转移了。注意这里状态转移时，第一目标是数组长度最小，第二目标是成本最低。

时间复杂度为 $\mathcal{O}(n^3)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    def check(x):
        ans = 0
        while x:
            ans += x
            x //= 10
        return ans
    
    for _ in range(t):
        n = II()
        l, r = 1, 10 ** 18
        
        while l <= r:
            mid = (l + r) // 2
            
            if check(mid) > n: r = mid - 1
            else: l = mid + 1
        
        outs.append(n - r)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	auto check = [&] (long long x) -> long long {
		long long ans = 0;
		while (x) {
			ans += x;
			x /= 10;
		}
		return ans;
	};

	while (t --) {
		long long n;
		cin >> n;

		long long l = 1, r = n;
		while (l <= r) {
			long long mid = (l + r) / 2;
			if (check(mid) > n) r = mid - 1;
			else l = mid + 1;
		}

		cout << n - r << '\n';
	}

	return 0;
}
```
