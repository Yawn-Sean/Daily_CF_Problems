**提示 1：** 每个数的 cascading number 都不相等，且是关于这个数递增的。

**提示 2：** 可以将求的数映射回去。

先看提示 1，因为本质上相当于把第 $i$ 个位上的 $\times 10^i$ 变成了 $\times (10^i+10^{i-1}+\dots+1)$ ，一定关于原数递增，且不会相等。

所以为了求 $n$ 以下多少数不能被表示为 cascading number ，相当于求多少个数可以被表示，也就是有多少个数的 cascading number 不超过 $n$ 。

因此直接二分这个数就好，求 cascading number 显然对数复杂度，这是足够的了。

时间复杂度为 $\mathcal{O}(\log^2M)$ ，可以想想能否进一步优化。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    def check(x):
        ans = 0
        while x:
            ans += x
            x //= 10
        return ans
    
    for _ in range(t):
        n = II()
        l, r = 1, 10 ** 18
        
        while l <= r:
            mid = (l + r) // 2
            
            if check(mid) > n: r = mid - 1
            else: l = mid + 1
        
        outs.append(n - r)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	auto check = [&] (long long x) -> long long {
		long long ans = 0;
		while (x) {
			ans += x;
			x /= 10;
		}
		return ans;
	};

	while (t --) {
		long long n;
		cin >> n;

		long long l = 1, r = n;
		while (l <= r) {
			long long mid = (l + r) / 2;
			if (check(mid) > n) r = mid - 1;
			else l = mid + 1;
		}

		cout << n - r << '\n';
	}

	return 0;
}
```
