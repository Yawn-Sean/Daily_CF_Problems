**提示 1：** 如果一个排列本身几乎有序，如何从被扰乱交换的过程中恢复过来？

**提示 2：** 上述操作是否能重复进行直到整体排序？

如果一个排好序的数组我们交换了两个位置，我们可以怎么办呢？

我们可以顺序交换所有相邻对，再逆序来一遍，这样一定都回去了。

上述逻辑很类似于冒泡排序之类。我们执行 $n-1$ 轮，如果没有捣乱的话也就排好序了。而每次捣乱后，只需执行过上面的操作，前一轮的捣乱也就失去作用了。所以我们只需不断执行上述交换相邻对的操作即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def swap(i, j):
        print(i, j, flush=True)
        if I()[0] == 'W': exit()
    
    n = II()
    
    for _ in range(n):
        for i in range(1, n):
            swap(i, i + 1)
        
        for i in range(n, 2, -1):
            swap(i - 1, i)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	auto op = [&] (int x, int y) -> void {
		cout << x << ' ' << y << endl;
		string s; cin >> s;
		if (s == "WIN") exit(0);
	};

	int n;
	cin >> n;

	for (int i = 0; i < n; i ++) {
		for (int j = 2; j <= n; j ++) op(j - 1, j);
		for (int j = n; j >= 2; j --) op(j - 1, j);
	}

	return 0;
}
```
