**提示 1：** 因为路径的边权是从小到大的，所以按照这个顺序依次考虑各条边。

因为要求路径的 $t$ 是递增的，所以按照递增的顺序遍历各条边，这样一定能顺序遍历从 $1$ 走到 $n$ 的路径。

假设遍历到边 $(u,v,w)$ 了，则 $v$ 的答案可以用 $u$ 更新，因为可以直接走；同时 $u$ 的答案可以用 $v$ 的结果 $+1$ 更新，因为此时可以反着走这条边。

注意，这里 $w$ 是允许相等的，所以我们要避免同时用两个 $w$ 相等的边。我们可以将 $w$ 相等的答案更新最后一起进行，这样就没有问题了。

时间复杂度为 $\mathcal{O}(n+m\log m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    inf = 10 ** 9
    
    for _ in range(t):
        n, m = MII()
        us = []
        vs = []
        ws = []
        
        for _ in range(m):
            u, v, w = GMI()
            us.append(u)
            vs.append(v)
            ws.append(w)
        
        st_range = sorted(range(m), key=lambda x: ws[x])
        dis = [inf] * n
        dis[0] = 0
        
        pt = 0
        while pt < m:
            npt = pt
            while npt < m and ws[st_range[npt]] == ws[st_range[pt]]:
                npt += 1
            
            updates = []
            for i in range(pt, npt):
                u = us[st_range[i]]
                v = vs[st_range[i]]
                updates.append((u, dis[v] + 1))
                updates.append((v, dis[u]))
            
            for u, d in updates:
                dis[u] = fmin(dis[u], d)
            
            pt = npt
        
        outs.append(dis[-1] if dis[-1] < inf else -1)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n, m;
		cin >> n >> m;

		vector<array<int, 3>> edges(m);
		for (auto &[u, v, w]: edges) {
			cin >> u >> v >> w;
			u --, v --;
		}

		sort(edges.begin(), edges.end(), [&] (array<int, 3> &x, array<int, 3> &y) {return x[2] < y[2];});

		vector<int> ans(n, n);
		ans[0] = 0;

		int pt = 0;
		while (pt < m) {
			int npt = pt;
			while (npt < m && edges[pt][2] == edges[npt][2])
				npt ++;
			
			vector<pair<int, int>> updates;
			for (int i = pt; i < npt; i ++) {
				auto [u, v, w] = edges[i];
				updates.emplace_back(v, ans[u]);
				updates.emplace_back(u, ans[v] + 1);
			}

			for (auto &[u, d]: updates)
				ans[u] = min(ans[u], d);
			
			pt = npt;
		}

		cout << (ans[n - 1] < n ? ans[n - 1] : -1) << '\n';
	}

	return 0;
}
```
