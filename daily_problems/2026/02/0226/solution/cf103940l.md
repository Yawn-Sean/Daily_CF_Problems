**提示 1：** 典型 DP 计数，用什么当状态呢？转移如何？

很明显是一个 DP 计数的问题。

我们考虑到第 $i$ 项的和是 $X$ ，则其能转移到的状态是 $i+1$ 和 $X+1\sim 2X$ 。

发现 $i$ 是不重要的，关键在于 $X$ 。所以我们以 $X$ 为状态，考虑和为 $v$ 的满足条件的序列数量为 $dp[v]$ 。

则上述过程可以理解为状态转移到一个区间，也可以理解为一个区间的状态转移到 $x$ ，可以用差分更新 / 前缀和进行优化。

时间复杂度为 $\mathcal{O}(k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    mod = 10 ** 9 + 7
    
    dp = [0] * (n + 1)
    acc = [0] * (n + 1)
    
    dp[1] = acc[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = (acc[i - 1] - acc[i - i // 2 - 1]) % mod
        acc[i] = (acc[i - 1] + dp[i]) % mod
    
    print(dp[n])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mod = 1e9 + 7;
	cin >> n;

	vector<int> dp(n + 1, 0), acc(n + 1, 0);
	dp[1] = 1, acc[1] = 1;

	for (int i = 2; i <= n; i ++) {
		dp[i] = (acc[i - 1] + mod - acc[i - i / 2 - 1]) % mod;
		acc[i] = (acc[i - 1] + dp[i]) % mod;
	}

	cout << dp[n];

	return 0;
}
```
