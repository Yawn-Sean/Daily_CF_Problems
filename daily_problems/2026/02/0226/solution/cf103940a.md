**提示 1：** 分两步——每个物品的最低成本，求方案数。

**提示 2：** 其实不用松弛太多次。

我们求完每个物品的最低成本后，就可以用背包问题求解后半部分了。

前半部分怎么求呢？注意到物品成本大于 $c+1$ 时就不需考虑了。我们用合成所需的总价格对 $cost[u]$ 进行松弛操作，每次松弛成本至少 $+1$ ，所以走到 $u$ 结点前经过的松弛操作小于 $c$ 。于是进行这么多轮就可以得到成本了。

时间复杂度为 $\mathcal{O}((n+m)c)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m, c = MII()
    mod = 10 ** 9 + 7
    
    needed = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v, w = MII()
        u -= 1
        v -= 1
        needed[v].append((u, w))
    
    dis = [c + 1] * n
    dis[0] = 1
    
    for _ in range(c):
        for u in range(1, n):
            res = 0
            for v, w in needed[u]:
                res += dis[v] + w
            dis[u] = fmin(dis[u], res)
    
    dp = [0] * (c + 1)
    dp[0] = 1
    
    for x in dis:
        for i in range(x, c + 1):
            dp[i] += dp[i - x]
            dp[i] %= mod
    
    print(sum(dp[1:]) % mod)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m, c, mod = 1e9 + 7;
	cin >> n >> m >> c;

	vector<vector<pair<int, int>>> needed(n);
	while (m --) {
		int u, v, w;
		cin >> u >> v >> w;
		u --, v --;
		needed[v].emplace_back(u, w);
	}

	vector<int> dis(n, c + 1);
	dis[0] = 1;

	for (int i = 0; i < c; i ++) {
		for (int u = 1; u < n; u ++) {
			int res = 0;
			for (auto &[v, w]: needed[u]) res += dis[v] + w;
			dis[u] = min(dis[u], res);
		}
	}

	vector<int> dp(c + 1, 0);
	dp[0] = 1;

	for (auto &x: dis)
		for (int i = x; i <= c; i ++)
			dp[i] = (dp[i] + dp[i - x]) % mod;

	int ans = 0;
	for (int i = 1; i <= c; i ++)
		ans = (ans + dp[i]) % mod;

	cout << ans;

	return 0;
}
```
