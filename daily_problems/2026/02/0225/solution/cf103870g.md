**提示 1：** 如果你不熟悉 $x$ 和 $x+1$ 的异或结果，可以打表找找规律。

**提示 2：** 我们要找的书要满足啥要求？

根据推导 / 打表可以知道， $x$ 和 $x+1$ 的异或结果取决于 $x$ 二进制表示结尾有多少个 $1$ ，如果有 $k$ 个，异或结果就是 $2^{k+1}-1$ 。

于是我们找到最小的使得 $2^{k+1}-1\geq M$ 的 $k$ ，则我们要求的就是二进制表示结尾至少有 $k$ 个 $1$ 的数。

这种数显然关于 $2^k$ 取模结果是 $2^k-1$ 。我们只需求区间内满足这个条件的数就好，为此更容易的写法是求 $[0,r]$ 内满足条件的数的个数减去 $[0,l-1]$ 内满足条件的数的个数。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        l, r, m = MII()
        v = 1 << m.bit_length() - 1
        outs.append((r + 1) // v - l // v)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int l, r, m;
		cin >> l >> r >> m;
		int bit = 31 - __builtin_clz(m);
		cout << ((r + 1) >> bit) - (l >> bit) << '\n';
	}

	return 0;
}
```
