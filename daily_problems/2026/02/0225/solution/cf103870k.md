**提示 1：** DP，如何转移？

假设 $i$ 对应的答案是 $dp[i]$ 。

则当前局不平局的概率是：先钦定两个可选的 $3$ 种方案，对应概率是 $\left(\frac{2}{3}\right)^i$ ，所以共计 $3\times\left(\frac{2}{3}\right)^i$ 。

这样多算了所有人都出同个手势的概率，且都出剪刀的算了 $2$ 次，别的也类似，所以多算的概率是 $2\times\left(\frac{1}{3}\right)^i\times 3$ 。

所以期望成功概率（即决出胜负）是 $3\times\left(\frac{2}{3}\right)^i-6\times\left(\frac{1}{3}\right)^i$ ，对应的期望次数就是 $\frac{1}{3\times\left(\frac{2}{3}\right)^i-6\times\left(\frac{1}{3}\right)^i}$ 。

而假设这一轮之后剩下了 $j$ 个人，则选取方案有 $C_i^j$ 种，出现这种情况的概率是 $\frac{C_i^j}{2^i-2}$ 。

所以 $dp[i]=\frac{1}{3\times\left(\frac{2}{3}\right)^i-6\times\left(\frac{1}{3}\right)^i}+\sum\limits_j\frac{C_i^j}{2^i-2}dp[j]$ 。预处理完逆元 / 组合数后，这个递推可以 $\mathcal{O}(n)$ 完成，也就解决了问题。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, mod = MII()
    f = Factorial(n, mod)
    
    dp = [0] * (n + 1)
    
    p1 = pow(3, -1, mod)
    p2 = 2 * p1 % mod
    
    v = 2
    v1 = p1
    v2 = p2
    
    for i in range(2, n + 1):
        v = v * 2 % mod
        v1 = v1 * p1 % mod
        v2 = v2 * p2 % mod
    
        for j in range(i):
            dp[i] += f.combi(i, j) * dp[j]
            dp[i] %= mod
    
        dp[i] = dp[i] * pow(v - 2, -1, mod) % mod
        
        dp[i] += pow(3 * v2 - 6 * v1, -1, mod)
        dp[i] %= mod
    
    print(*dp[1:])
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, mod;
	cin >> n >> mod;

	vector<int> f(n + 1), g(n + 1);
	f[0] = 1;
	for (int i = 1; i <= n; i ++)
		f[i] = 1ll * i * f[i - 1] % mod;
	g[n] = quickPow(f[n], mod - 2, mod);
	for (int i = n; i >= 1; i --)
		g[i - 1] = 1ll * i * g[i] % mod;

	int p1 = quickPow(3, mod - 2, mod), p2 = 2ll * p1 % mod;
	int v = 2, v1 = p1, v2 = p2;

	auto comb = [&] (int i, int j) -> int {
		return 1ll * f[i] * g[j] % mod * g[i - j] % mod;
	};

	vector<int> dp(n + 1, 0);

	for (int i = 2; i <= n; i ++) {
		v = 2ll * v % mod;
		v1 = 1ll * v1 * p1 % mod;
		v2 = 1ll * v2 * p2 % mod;

		for (int j = 0; j < i; j ++)
			dp[i] = (dp[i] + 1ll * comb(i, j) * dp[j]) % mod;

		dp[i] = 1ll * dp[i] * quickPow(v - 2, mod - 2, mod) % mod;
		int val = 3ll * v2 % mod - 6ll * v1 % mod;
		val = (val + mod) % mod;
		dp[i] = (dp[i] + quickPow(val, mod - 2, mod)) % mod;
	}

	for (int i = 1; i <= n; i ++) cout << dp[i] << ' ';

	return 0;
}
```
