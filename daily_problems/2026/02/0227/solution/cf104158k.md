**提示 1：** 两个路径相交，满足什么性质？

**提示 2：** 要统计什么？怎么保证不重不漏？

两条路径相交，则一条路径的最浅点（即两端端点的 LCA）在另一条路径上。

所以我们对每条路径，统计在其上的 LCA 数量。我们相当于树上每个点有个权值（这里就是 LCA 数量），求路径上权值和。我们可以预处理根节点到当前结点的总权值，再用 $val[u]+val[v]-val[lca(u,v)]-val[parent[lca(u,v)]]$ 得到答案。

对于满足条件的一对路径会被计算几次呢？如果两条路径 LCA 不同，则只计算一次：更浅的 LCA 上统计一次。否则会被多次统计。

我们只需将这部分剔除就好。我们既然得到了每个点作为 LCA 的出现次数，则其任选两个都是被多统计的元素对，去掉它们就行。（每条路径和自身也被多计算了一次）

这里用的倍增法求 LCA，所以下面的代码复杂度是 $\mathcal{O}(n\log n+m\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n, m = MII()
    
    path = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    us = []
    vs = []
    
    for _ in range(m):
        u, v = GMI()
        us.append(u)
        vs.append(v)
    
    parent = [-1] * n
    depth = [0] * n
    que = [0]
    
    for u in que:
        for v in path[u]:
            if parent[u] != v:
                parent[v] = u
                depth[v] = depth[u] + 1
                que.append(v)
    
    nth_parent = [[-1] * n for _ in range(20)]
    nth_parent[0] = parent
    
    for i in range(19):
        for j in range(n):
            if nth_parent[i][j] >= 0:
                nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
    ls = []
    
    for i in range(m):
        u = us[i]
        v = vs[i]
        
        if depth[u] > depth[v]:
            u, v = v, u
        
        d = depth[v] - depth[u]
        
        while d:
            x = d & -d
            v = nth_parent[x.bit_length() - 1][v]
            d -= x
        
        if u == v: ls.append(u)
        else:
            for i in range(19, -1, -1):
                if nth_parent[i][u] != nth_parent[i][v]:
                    u = nth_parent[i][u]
                    v = nth_parent[i][v]
            ls.append(parent[u])
    
    ans = 0
    
    cnt = [0] * n
    
    for u in ls:
        cnt[u] += 1
        ans -= cnt[u]
    
    for u in que:
        if u:
            cnt[u] += cnt[parent[u]]
    
    for i in range(m):
        u = us[i]
        v = vs[i]
        l = ls[i]
        
        ans += cnt[u] + cnt[v] - cnt[l]
        if parent[l] >= 0: ans -= cnt[parent[l]]
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<vector<int>> path(n);
	for (int i = 0; i < n - 1; i ++) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		path[u].emplace_back(v);
		path[v].emplace_back(u);
	}

	vector<pair<int, int>> routes(m);
	for (auto &[u, v]: routes) {
		cin >> u >> v;
		u --, v --;
	}

	vector<int> parent(n, -1), depth(n, 0);
	auto dfs = [&] (auto &self, int u, int p) -> void {
		for (auto &v: path[u]) {
			if (v != p) {
				parent[v] = u;
				depth[v] = depth[u] + 1;
				self(self, v, u); 
			}
		}
	};

	dfs(dfs, 0, -1);

	vector<vector<int>> nth_parent(20, vector<int>(n, -1));
	nth_parent[0] = parent;

	for (int i = 0; i < 19; i ++) {
		for (int j = 0; j < n; j ++) {
			if (nth_parent[i][j] != -1) {
				nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
			}
		}
	}

	auto lca = [&] (int u, int v) -> int {
		if (depth[u] > depth[v]) swap(u, v);

		int d = depth[v] - depth[u];
		for (int i = 0; i < 20; i ++) {
			if (d >> i & 1) {
				v = nth_parent[i][v];
			}
		}

		if (u == v) return u;

		for (int i = 19; i >= 0; i --) {
			if (nth_parent[i][u] != nth_parent[i][v]) {
				u = nth_parent[i][u];
				v = nth_parent[i][v];
			}
		}

		return parent[u];
	};

	long long ans = 0;
	vector<int> ls(m), cnt(n, 0);

	for (int i = 0; i < m; i ++) {
		auto [u, v] = routes[i];
		ls[i] = lca(u, v);
		cnt[ls[i]] ++;
		ans -= cnt[ls[i]];
	}

	auto dfs1 = [&] (auto &self, int u, int p) -> void {
		for (auto &v: path[u]) {
			if (v != p) {
				cnt[v] += cnt[u];
				self(self, v, u); 
			}
		}
	};

	dfs1(dfs1, 0, -1);

	for (int i = 0; i < m; i ++) {
		auto [u, v] = routes[i];
		ans += cnt[u] + cnt[v] - cnt[ls[i]];
		if (ls[i]) ans -= cnt[parent[ls[i]]];
	}

	cout << ans;

	return 0;
}
```
