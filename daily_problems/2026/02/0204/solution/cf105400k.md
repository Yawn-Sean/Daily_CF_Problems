**提示 1：** 想想不同元素的操作顺序。

**提示 2：** 要检查的条件是？

考虑每个元素至少需要移动几次。这取决于前面有几个元素比它大。这件事离线查询后，相当于从大到小遍历元素并对对应位置进行标记，过程中查询前缀中被标记的元素个数。这显然可以用树状数组解决。

而我们应该先移动最小的元素，因为操作对小元素的限制更大。这样可以保证把不小于 $x$ 的数都操作完成的情况下，总操作次数最少。

所以我们只需先统计每个元素的操作次数，进而得到不超过 $x$ 的数的操作次数，看是否超过 $x$ 即可。如果超过了 $x$ ，则前缀的操作种一定有第 $x+1$ 次往后进行的，一定不符合要求。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        st_range = sorted(range(n), key=lambda x: nums[x])
        fen = FenwickTree(n)
        
        res = [0] * n
        for i in range(n - 1, -1, -1):
            res[i] = fen.rsum(0, st_range[i])
            fen.add(st_range[i], 1)
        
        for i in range(1, n):
            res[i] += res[i - 1]
        
        flg = True
        for i in range(n):
            if nums[st_range[i]] < res[i]:
                flg = False
        
        outs.append('YES' if flg else 'NO')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> nums(n);
		for (auto &v: nums) cin >> v;

		vector<int> order(n);
		iota(order.begin(), order.end(), 0);
		sort(order.begin(), order.end(), [&] (int i, int j) {return nums[i] < nums[j];});

		atcoder::fenwick_tree<int> fen(n);
		vector<int> res(n, 0);

		for (int i = n - 1; i >= 0; i --) {
			res[i] = fen.sum(0, order[i]);
			fen.add(order[i], 1);
		}

		int cur = 0;
		bool flg = true;

		for (int i = 0; i < n; i ++) {
			cur += res[i];
			if (cur > nums[order[i]]) {
				flg = false;
				break;
			}
		}

		cout << (flg ? "YES" : "NO") << '\n';
	}

	return 0;
}
```
