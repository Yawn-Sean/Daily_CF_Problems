**提示 1：** 拆贡献。怎么拆？

**提示 2：** 如何更新贡献？

考虑覆盖每个点的子数组 $[l,r]$ 其 MEX 是 $k$ 。考虑计算覆盖 $i$ 的 MEX 不小于 $v$ 的子数组的个数，将 $v$ 关于 $1,2,\dots, n$ 求和， $[l,r]$ 这个子数组刚好被数 $k$ 次。

所以我们直接求 MEX 不小于 $v$ 的子数组有多少个覆盖了位置 $i$ ，将各个 $v$ 的结果累加即可。

因为整个数组是个排列，所以我们直接找到所有 $0,1,\dots,v-1$ 所在的位置，则子数组需要覆盖它们。我们只需从小到大遍历 $v$ ，维护左右端点 $[l_0,r_0]$ （这里取 $0$ -index ）即可。

如果 $i$ 在区间内，则有 $(l_0+1)\times(n-r_0)$ 个。

如果 $i\lt l_0$ ，则有 $(i+1)\times(n-r_0)$ 个。

如果 $i\gt r_0$ ，则有 $(l_0+1)\times(n-i)$ 个。

整体分为三段，每段都更新一个一次函数，因此只需用差分更新一次函数的一次项系数和常数系数即可。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    pos = [0] * n
    for i in range(n):
        pos[nums[i]] = i
    
    l, r = pos[0], pos[0]
    
    diff_0 = [0] * (n + 1)
    diff_1 = [0] * (n + 1)
    
    for i in range(n):
        l = fmin(l, pos[i])
        r = fmax(r, pos[i])
        
        diff_0[l] += (n - r) * (l + 1)
        diff_0[r + 1] -= (n - r) * (l + 1)
        
        diff_1[0] += n - r
        diff_1[l] -= n - r
        diff_0[0] += n - r
        diff_0[l] -= n - r
    
        diff_1[r + 1] -= l + 1
        diff_1[n] += l + 1
        diff_0[r + 1] += (l + 1) * n
        diff_0[n] -= (l + 1) * n
    
    for i in range(n):
        diff_0[i + 1] += diff_0[i]
        diff_1[i + 1] += diff_1[i]
    
    print('\n'.join(str(diff_1[i] * i + diff_0[i]) for i in range(n)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n), pos(n);
	for (int i = 0; i < n; i ++) {
		int v;
		cin >> v;
		nums[i] = v;
		pos[v] = i;
	}

	int l = pos[0], r = pos[0];

	vector<long long> diff_0(n + 1, 0), diff_1(n + 1, 0);

	for (int i = 0; i < n; i ++) {
		l = min(l, pos[i]);
		r = max(r, pos[i]);

		diff_0[l] += 1ll * (n - r) * (l + 1);
		diff_0[r + 1] -= 1ll * (n - r) * (l + 1);

		diff_1[0] += n - r;
		diff_1[l] -= n - r;
		diff_0[0] += n - r;
		diff_0[l] -= n - r;

		diff_1[r + 1] -= l + 1;
		diff_1[n] += l + 1;
		diff_0[r + 1] += 1ll * (l + 1) * n;
		diff_0[n] -= 1ll * (l + 1) * n;
	}

	for (int i = 0; i < n; i ++) {
		diff_1[i + 1] += diff_1[i];
		diff_0[i + 1] += diff_0[i];
		cout << diff_1[i] * i + diff_0[i] << '\n';
	}

	return 0;
}
```
